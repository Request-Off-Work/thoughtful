(function(e, a) { for(var i in a) e[i] = a[i]; }(exports, /******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId])
/******/ 			return installedModules[moduleId].exports;
/******/
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// identity function for calling harmony imports with the correct context
/******/ 	__webpack_require__.i = function(value) { return value; };
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, {
/******/ 				configurable: false,
/******/ 				enumerable: true,
/******/ 				get: getter
/******/ 			});
/******/ 		}
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 0);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/* unknown exports provided */
/* all exports used */
/*!**********************!*\
  !*** ./src/index.ts ***!
  \**********************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nfunction __export(m) {\n    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];\n}\nObject.defineProperty(exports, \"__esModule\", { value: true });\n__export(__webpack_require__(/*! ./matrix */ 12));\nvar ann_matrix_1 = __webpack_require__(/*! ./NeuralNetworks/ann.matrix */ 2);\nexports.FeedForwardANNMatrixBeta = ann_matrix_1.FeedForward;\n__export(__webpack_require__(/*! ./NeuralNetworks/ann */ 13));\n__export(__webpack_require__(/*! ./NeuralNetworks/activationFunctions */ 1));\n__export(__webpack_require__(/*! ./NeuralNetworks/errorFunctions */ 3));\n__export(__webpack_require__(/*! ./helper/utilities */ 9));\n__export(__webpack_require__(/*! ./helper/classToValue */ 4));\n__export(__webpack_require__(/*! ./helper/distances */ 5));\n__export(__webpack_require__(/*! ./helper/normalization */ 8));\n__export(__webpack_require__(/*! ./helper/maths */ 7));\n__export(__webpack_require__(/*! ./helper/generators */ 6));\n__export(__webpack_require__(/*! ./knn */ 11));\n__export(__webpack_require__(/*! ./k-means */ 10));\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMC5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL3NyYy9pbmRleC50cz9kMWU3Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuZnVuY3Rpb24gX19leHBvcnQobSkge1xuICAgIGZvciAodmFyIHAgaW4gbSkgaWYgKCFleHBvcnRzLmhhc093blByb3BlcnR5KHApKSBleHBvcnRzW3BdID0gbVtwXTtcbn1cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbl9fZXhwb3J0KHJlcXVpcmUoXCIuL21hdHJpeFwiKSk7XG52YXIgYW5uX21hdHJpeF8xID0gcmVxdWlyZShcIi4vTmV1cmFsTmV0d29ya3MvYW5uLm1hdHJpeFwiKTtcbmV4cG9ydHMuRmVlZEZvcndhcmRBTk5NYXRyaXhCZXRhID0gYW5uX21hdHJpeF8xLkZlZWRGb3J3YXJkO1xuX19leHBvcnQocmVxdWlyZShcIi4vTmV1cmFsTmV0d29ya3MvYW5uXCIpKTtcbl9fZXhwb3J0KHJlcXVpcmUoXCIuL05ldXJhbE5ldHdvcmtzL2FjdGl2YXRpb25GdW5jdGlvbnNcIikpO1xuX19leHBvcnQocmVxdWlyZShcIi4vTmV1cmFsTmV0d29ya3MvZXJyb3JGdW5jdGlvbnNcIikpO1xuX19leHBvcnQocmVxdWlyZShcIi4vaGVscGVyL3V0aWxpdGllc1wiKSk7XG5fX2V4cG9ydChyZXF1aXJlKFwiLi9oZWxwZXIvY2xhc3NUb1ZhbHVlXCIpKTtcbl9fZXhwb3J0KHJlcXVpcmUoXCIuL2hlbHBlci9kaXN0YW5jZXNcIikpO1xuX19leHBvcnQocmVxdWlyZShcIi4vaGVscGVyL25vcm1hbGl6YXRpb25cIikpO1xuX19leHBvcnQocmVxdWlyZShcIi4vaGVscGVyL21hdGhzXCIpKTtcbl9fZXhwb3J0KHJlcXVpcmUoXCIuL2hlbHBlci9nZW5lcmF0b3JzXCIpKTtcbl9fZXhwb3J0KHJlcXVpcmUoXCIuL2tublwiKSk7XG5fX2V4cG9ydChyZXF1aXJlKFwiLi9rLW1lYW5zXCIpKTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vc3JjL2luZGV4LnRzXG4vLyBtb2R1bGUgaWQgPSAwXG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Iiwic291cmNlUm9vdCI6IiJ9");

/***/ }),
/* 1 */
/* unknown exports provided */
/* all exports used */
/*!***************************************************!*\
  !*** ./src/NeuralNetworks/activationFunctions.ts ***!
  \***************************************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar Activations = (function () {\n    function Activations() {\n    }\n    return Activations;\n}());\nActivations.TANH = {\n    output: function (x) { return Math.tanh(x); },\n    der: function (x) {\n        var output = Activations.TANH.output(x);\n        return 1 - output * output;\n    }\n};\nActivations.SIGMOID = {\n    output: function (x) { return 1 / (1 + Math.exp(-x)); },\n    der: function (x) {\n        var output = Activations.SIGMOID.output(x);\n        return output * (1 - output);\n    }\n};\nActivations.RELU = {\n    output: function (x) { return Math.max(0, x); },\n    der: function (x) { return x <= 0 ? 0 : 1; }\n};\nActivations.LINEAR = {\n    output: function (x) { return x; },\n    der: function (x) { return 1; }\n};\nexports.Activations = Activations;\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMS5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL3NyYy9OZXVyYWxOZXR3b3Jrcy9hY3RpdmF0aW9uRnVuY3Rpb25zLnRzP2NkZmQiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgQWN0aXZhdGlvbnMgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIEFjdGl2YXRpb25zKCkge1xuICAgIH1cbiAgICByZXR1cm4gQWN0aXZhdGlvbnM7XG59KCkpO1xuQWN0aXZhdGlvbnMuVEFOSCA9IHtcbiAgICBvdXRwdXQ6IGZ1bmN0aW9uICh4KSB7IHJldHVybiBNYXRoLnRhbmgoeCk7IH0sXG4gICAgZGVyOiBmdW5jdGlvbiAoeCkge1xuICAgICAgICB2YXIgb3V0cHV0ID0gQWN0aXZhdGlvbnMuVEFOSC5vdXRwdXQoeCk7XG4gICAgICAgIHJldHVybiAxIC0gb3V0cHV0ICogb3V0cHV0O1xuICAgIH1cbn07XG5BY3RpdmF0aW9ucy5TSUdNT0lEID0ge1xuICAgIG91dHB1dDogZnVuY3Rpb24gKHgpIHsgcmV0dXJuIDEgLyAoMSArIE1hdGguZXhwKC14KSk7IH0sXG4gICAgZGVyOiBmdW5jdGlvbiAoeCkge1xuICAgICAgICB2YXIgb3V0cHV0ID0gQWN0aXZhdGlvbnMuU0lHTU9JRC5vdXRwdXQoeCk7XG4gICAgICAgIHJldHVybiBvdXRwdXQgKiAoMSAtIG91dHB1dCk7XG4gICAgfVxufTtcbkFjdGl2YXRpb25zLlJFTFUgPSB7XG4gICAgb3V0cHV0OiBmdW5jdGlvbiAoeCkgeyByZXR1cm4gTWF0aC5tYXgoMCwgeCk7IH0sXG4gICAgZGVyOiBmdW5jdGlvbiAoeCkgeyByZXR1cm4geCA8PSAwID8gMCA6IDE7IH1cbn07XG5BY3RpdmF0aW9ucy5MSU5FQVIgPSB7XG4gICAgb3V0cHV0OiBmdW5jdGlvbiAoeCkgeyByZXR1cm4geDsgfSxcbiAgICBkZXI6IGZ1bmN0aW9uICh4KSB7IHJldHVybiAxOyB9XG59O1xuZXhwb3J0cy5BY3RpdmF0aW9ucyA9IEFjdGl2YXRpb25zO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9zcmMvTmV1cmFsTmV0d29ya3MvYWN0aXZhdGlvbkZ1bmN0aW9ucy50c1xuLy8gbW9kdWxlIGlkID0gMVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTsiLCJzb3VyY2VSb290IjoiIn0=");

/***/ }),
/* 2 */
/* unknown exports provided */
/* all exports used */
/*!******************************************!*\
  !*** ./src/NeuralNetworks/ann.matrix.ts ***!
  \******************************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar __1 = __webpack_require__(/*! .. */ 0);\nvar FeedForward;\n(function (FeedForward) {\n    var Network = (function () {\n        function Network(options) {\n            this.options = options;\n            this.weights = [];\n            this.deltas = [];\n            this.layers = [];\n            this.inputs = [];\n            // Create weight matrices\n            for (var j = 0; j < this.options.layers.length - 1; j++) {\n                // + 1 for bias neuron\n                var neuronsInLayerI = this.options.layers[j] + 1;\n                var neuronsInLayerK = this.options.layers[j + 1];\n                this.weights.push(__1.Matrix.rand(neuronsInLayerI, neuronsInLayerK));\n            }\n        }\n        Network.prototype.forwardPass = function (inputs) {\n            var _this = this;\n            // clear inputs and layer\n            this.layers = [];\n            this.inputs = [];\n            // I for input Matrix\n            var I = inputs instanceof __1.Matrix ? inputs : __1.Matrix.rowVector.apply(__1.Matrix, inputs);\n            // T for temporary calculation Matrix         \n            var T = I;\n            for (var j = 0; j < this.options.layers.length - 1; j++) {\n                // Add bias input\n                T = __1.Matrix.join(T, __1.Matrix.ones(T.getNumberOfRows(), 1), 'right');\n                // Save copy of neuron outputs for back propagation\n                this.layers.push(T.copy());\n                // Calculate neuron input in layer J\n                T = T.dot(this.weights[j]);\n                // Save inputs\n                this.inputs.push(T.copy());\n                // Calculate output using activation function\n                T.map(function (v) { return _this.options.activationFunction.output(v); });\n            }\n            // Save output layer to layers\n            this.layers.push(T);\n            return T;\n        };\n        Network.prototype.backwardPass = function (targets) {\n            var _this = this;\n            // T for targets\n            var T = targets instanceof __1.Matrix ? targets : new __1.Matrix([targets]);\n            // Output Layer Error Function derivative            \n            var dE = this.layers[this.layers.length - 1].copy().map(function (val, row, column) {\n                return _this.options.errorFunction.der(val, T.get(row, column));\n            });\n            // Calc derivative of activation fro Output Layer Delta\n            var outputLayerDelta = this.inputs[this.inputs.length - 1].map(function (val) { return _this.options.activationFunction.der(val); });\n            this.deltas[this.layers.length - 1] = outputLayerDelta;\n            // Hidden Layer Deltas\n            for (var layer = this.layers.length - 2; layer > 0; layer--) {\n                var L = this.layers[layer];\n                var W = this.weights[layer].copy();\n                var PrevDeltas = this.deltas[layer + 1].copy();\n                var Delta = PrevDeltas.dot(W.transpose().slice(0, -1, 0, -2));\n                this.deltas[layer] = Delta;\n            }\n            // Test size\n            //console.log(this.deltas.map(d => d.size()));\n        };\n        Network.prototype.updateWeights = function () {\n            // Calculate Derivatives\n            var _this = this;\n            var Derivatives = [];\n            for (var layer = this.layers.length - 1; layer > 0; layer--) {\n                var Delta = this.deltas[layer].copy();\n                var PrevLayerActivity = this.layers[layer - 1].copy();\n                var Derivate = PrevLayerActivity.transpose().dot(Delta);\n                Derivatives.unshift(Derivate);\n            }\n            this.weights.forEach(function (W, i) { return W.subtract(Derivatives[i].scale(_this.options.learningRate)); });\n        };\n        Network.prototype.error = function (inputs, targets) {\n            var _this = this;\n            var O = this.forwardPass(inputs);\n            var T = targets instanceof __1.Matrix ? targets : __1.Matrix.rowVector.apply(__1.Matrix, targets);\n            var E = new __1.Matrix(O.getNumberOfRows(), 1);\n            var _loop_1 = function (r) {\n                var output = O.getRowAsRowVector(r).getArray()[0];\n                var target = T.getRowAsRowVector(r).getArray()[0];\n                var error = output.reduce(function (s, o, i) {\n                    return s + _this.options.errorFunction.error(o, target[i]);\n                }, 0);\n                E.set(r, 0, error);\n            };\n            for (var r = 0; r < O.getNumberOfRows(); r++) {\n                _loop_1(r);\n            }\n            return E;\n        };\n        return Network;\n    }());\n    FeedForward.Network = Network;\n})(FeedForward = exports.FeedForward || (exports.FeedForward = {}));\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMi5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL3NyYy9OZXVyYWxOZXR3b3Jrcy9hbm4ubWF0cml4LnRzP2QyZTciXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgX18xID0gcmVxdWlyZShcIi4uXCIpO1xudmFyIEZlZWRGb3J3YXJkO1xuKGZ1bmN0aW9uIChGZWVkRm9yd2FyZCkge1xuICAgIHZhciBOZXR3b3JrID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZnVuY3Rpb24gTmV0d29yayhvcHRpb25zKSB7XG4gICAgICAgICAgICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zO1xuICAgICAgICAgICAgdGhpcy53ZWlnaHRzID0gW107XG4gICAgICAgICAgICB0aGlzLmRlbHRhcyA9IFtdO1xuICAgICAgICAgICAgdGhpcy5sYXllcnMgPSBbXTtcbiAgICAgICAgICAgIHRoaXMuaW5wdXRzID0gW107XG4gICAgICAgICAgICAvLyBDcmVhdGUgd2VpZ2h0IG1hdHJpY2VzXG4gICAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IHRoaXMub3B0aW9ucy5sYXllcnMubGVuZ3RoIC0gMTsgaisrKSB7XG4gICAgICAgICAgICAgICAgLy8gKyAxIGZvciBiaWFzIG5ldXJvblxuICAgICAgICAgICAgICAgIHZhciBuZXVyb25zSW5MYXllckkgPSB0aGlzLm9wdGlvbnMubGF5ZXJzW2pdICsgMTtcbiAgICAgICAgICAgICAgICB2YXIgbmV1cm9uc0luTGF5ZXJLID0gdGhpcy5vcHRpb25zLmxheWVyc1tqICsgMV07XG4gICAgICAgICAgICAgICAgdGhpcy53ZWlnaHRzLnB1c2goX18xLk1hdHJpeC5yYW5kKG5ldXJvbnNJbkxheWVySSwgbmV1cm9uc0luTGF5ZXJLKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgTmV0d29yay5wcm90b3R5cGUuZm9yd2FyZFBhc3MgPSBmdW5jdGlvbiAoaW5wdXRzKSB7XG4gICAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICAgICAgLy8gY2xlYXIgaW5wdXRzIGFuZCBsYXllclxuICAgICAgICAgICAgdGhpcy5sYXllcnMgPSBbXTtcbiAgICAgICAgICAgIHRoaXMuaW5wdXRzID0gW107XG4gICAgICAgICAgICAvLyBJIGZvciBpbnB1dCBNYXRyaXhcbiAgICAgICAgICAgIHZhciBJID0gaW5wdXRzIGluc3RhbmNlb2YgX18xLk1hdHJpeCA/IGlucHV0cyA6IF9fMS5NYXRyaXgucm93VmVjdG9yLmFwcGx5KF9fMS5NYXRyaXgsIGlucHV0cyk7XG4gICAgICAgICAgICAvLyBUIGZvciB0ZW1wb3JhcnkgY2FsY3VsYXRpb24gTWF0cml4ICAgICAgICAgXG4gICAgICAgICAgICB2YXIgVCA9IEk7XG4gICAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IHRoaXMub3B0aW9ucy5sYXllcnMubGVuZ3RoIC0gMTsgaisrKSB7XG4gICAgICAgICAgICAgICAgLy8gQWRkIGJpYXMgaW5wdXRcbiAgICAgICAgICAgICAgICBUID0gX18xLk1hdHJpeC5qb2luKFQsIF9fMS5NYXRyaXgub25lcyhULmdldE51bWJlck9mUm93cygpLCAxKSwgJ3JpZ2h0Jyk7XG4gICAgICAgICAgICAgICAgLy8gU2F2ZSBjb3B5IG9mIG5ldXJvbiBvdXRwdXRzIGZvciBiYWNrIHByb3BhZ2F0aW9uXG4gICAgICAgICAgICAgICAgdGhpcy5sYXllcnMucHVzaChULmNvcHkoKSk7XG4gICAgICAgICAgICAgICAgLy8gQ2FsY3VsYXRlIG5ldXJvbiBpbnB1dCBpbiBsYXllciBKXG4gICAgICAgICAgICAgICAgVCA9IFQuZG90KHRoaXMud2VpZ2h0c1tqXSk7XG4gICAgICAgICAgICAgICAgLy8gU2F2ZSBpbnB1dHNcbiAgICAgICAgICAgICAgICB0aGlzLmlucHV0cy5wdXNoKFQuY29weSgpKTtcbiAgICAgICAgICAgICAgICAvLyBDYWxjdWxhdGUgb3V0cHV0IHVzaW5nIGFjdGl2YXRpb24gZnVuY3Rpb25cbiAgICAgICAgICAgICAgICBULm1hcChmdW5jdGlvbiAodikgeyByZXR1cm4gX3RoaXMub3B0aW9ucy5hY3RpdmF0aW9uRnVuY3Rpb24ub3V0cHV0KHYpOyB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIFNhdmUgb3V0cHV0IGxheWVyIHRvIGxheWVyc1xuICAgICAgICAgICAgdGhpcy5sYXllcnMucHVzaChUKTtcbiAgICAgICAgICAgIHJldHVybiBUO1xuICAgICAgICB9O1xuICAgICAgICBOZXR3b3JrLnByb3RvdHlwZS5iYWNrd2FyZFBhc3MgPSBmdW5jdGlvbiAodGFyZ2V0cykge1xuICAgICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgICAgIC8vIFQgZm9yIHRhcmdldHNcbiAgICAgICAgICAgIHZhciBUID0gdGFyZ2V0cyBpbnN0YW5jZW9mIF9fMS5NYXRyaXggPyB0YXJnZXRzIDogbmV3IF9fMS5NYXRyaXgoW3RhcmdldHNdKTtcbiAgICAgICAgICAgIC8vIE91dHB1dCBMYXllciBFcnJvciBGdW5jdGlvbiBkZXJpdmF0aXZlICAgICAgICAgICAgXG4gICAgICAgICAgICB2YXIgZEUgPSB0aGlzLmxheWVyc1t0aGlzLmxheWVycy5sZW5ndGggLSAxXS5jb3B5KCkubWFwKGZ1bmN0aW9uICh2YWwsIHJvdywgY29sdW1uKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIF90aGlzLm9wdGlvbnMuZXJyb3JGdW5jdGlvbi5kZXIodmFsLCBULmdldChyb3csIGNvbHVtbikpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAvLyBDYWxjIGRlcml2YXRpdmUgb2YgYWN0aXZhdGlvbiBmcm8gT3V0cHV0IExheWVyIERlbHRhXG4gICAgICAgICAgICB2YXIgb3V0cHV0TGF5ZXJEZWx0YSA9IHRoaXMuaW5wdXRzW3RoaXMuaW5wdXRzLmxlbmd0aCAtIDFdLm1hcChmdW5jdGlvbiAodmFsKSB7IHJldHVybiBfdGhpcy5vcHRpb25zLmFjdGl2YXRpb25GdW5jdGlvbi5kZXIodmFsKTsgfSk7XG4gICAgICAgICAgICB0aGlzLmRlbHRhc1t0aGlzLmxheWVycy5sZW5ndGggLSAxXSA9IG91dHB1dExheWVyRGVsdGE7XG4gICAgICAgICAgICAvLyBIaWRkZW4gTGF5ZXIgRGVsdGFzXG4gICAgICAgICAgICBmb3IgKHZhciBsYXllciA9IHRoaXMubGF5ZXJzLmxlbmd0aCAtIDI7IGxheWVyID4gMDsgbGF5ZXItLSkge1xuICAgICAgICAgICAgICAgIHZhciBMID0gdGhpcy5sYXllcnNbbGF5ZXJdO1xuICAgICAgICAgICAgICAgIHZhciBXID0gdGhpcy53ZWlnaHRzW2xheWVyXS5jb3B5KCk7XG4gICAgICAgICAgICAgICAgdmFyIFByZXZEZWx0YXMgPSB0aGlzLmRlbHRhc1tsYXllciArIDFdLmNvcHkoKTtcbiAgICAgICAgICAgICAgICB2YXIgRGVsdGEgPSBQcmV2RGVsdGFzLmRvdChXLnRyYW5zcG9zZSgpLnNsaWNlKDAsIC0xLCAwLCAtMikpO1xuICAgICAgICAgICAgICAgIHRoaXMuZGVsdGFzW2xheWVyXSA9IERlbHRhO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gVGVzdCBzaXplXG4gICAgICAgICAgICAvL2NvbnNvbGUubG9nKHRoaXMuZGVsdGFzLm1hcChkID0+IGQuc2l6ZSgpKSk7XG4gICAgICAgIH07XG4gICAgICAgIE5ldHdvcmsucHJvdG90eXBlLnVwZGF0ZVdlaWdodHMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAvLyBDYWxjdWxhdGUgRGVyaXZhdGl2ZXNcbiAgICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgICAgICB2YXIgRGVyaXZhdGl2ZXMgPSBbXTtcbiAgICAgICAgICAgIGZvciAodmFyIGxheWVyID0gdGhpcy5sYXllcnMubGVuZ3RoIC0gMTsgbGF5ZXIgPiAwOyBsYXllci0tKSB7XG4gICAgICAgICAgICAgICAgdmFyIERlbHRhID0gdGhpcy5kZWx0YXNbbGF5ZXJdLmNvcHkoKTtcbiAgICAgICAgICAgICAgICB2YXIgUHJldkxheWVyQWN0aXZpdHkgPSB0aGlzLmxheWVyc1tsYXllciAtIDFdLmNvcHkoKTtcbiAgICAgICAgICAgICAgICB2YXIgRGVyaXZhdGUgPSBQcmV2TGF5ZXJBY3Rpdml0eS50cmFuc3Bvc2UoKS5kb3QoRGVsdGEpO1xuICAgICAgICAgICAgICAgIERlcml2YXRpdmVzLnVuc2hpZnQoRGVyaXZhdGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy53ZWlnaHRzLmZvckVhY2goZnVuY3Rpb24gKFcsIGkpIHsgcmV0dXJuIFcuc3VidHJhY3QoRGVyaXZhdGl2ZXNbaV0uc2NhbGUoX3RoaXMub3B0aW9ucy5sZWFybmluZ1JhdGUpKTsgfSk7XG4gICAgICAgIH07XG4gICAgICAgIE5ldHdvcmsucHJvdG90eXBlLmVycm9yID0gZnVuY3Rpb24gKGlucHV0cywgdGFyZ2V0cykge1xuICAgICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgICAgIHZhciBPID0gdGhpcy5mb3J3YXJkUGFzcyhpbnB1dHMpO1xuICAgICAgICAgICAgdmFyIFQgPSB0YXJnZXRzIGluc3RhbmNlb2YgX18xLk1hdHJpeCA/IHRhcmdldHMgOiBfXzEuTWF0cml4LnJvd1ZlY3Rvci5hcHBseShfXzEuTWF0cml4LCB0YXJnZXRzKTtcbiAgICAgICAgICAgIHZhciBFID0gbmV3IF9fMS5NYXRyaXgoTy5nZXROdW1iZXJPZlJvd3MoKSwgMSk7XG4gICAgICAgICAgICB2YXIgX2xvb3BfMSA9IGZ1bmN0aW9uIChyKSB7XG4gICAgICAgICAgICAgICAgdmFyIG91dHB1dCA9IE8uZ2V0Um93QXNSb3dWZWN0b3IocikuZ2V0QXJyYXkoKVswXTtcbiAgICAgICAgICAgICAgICB2YXIgdGFyZ2V0ID0gVC5nZXRSb3dBc1Jvd1ZlY3RvcihyKS5nZXRBcnJheSgpWzBdO1xuICAgICAgICAgICAgICAgIHZhciBlcnJvciA9IG91dHB1dC5yZWR1Y2UoZnVuY3Rpb24gKHMsIG8sIGkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHMgKyBfdGhpcy5vcHRpb25zLmVycm9yRnVuY3Rpb24uZXJyb3IobywgdGFyZ2V0W2ldKTtcbiAgICAgICAgICAgICAgICB9LCAwKTtcbiAgICAgICAgICAgICAgICBFLnNldChyLCAwLCBlcnJvcik7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgZm9yICh2YXIgciA9IDA7IHIgPCBPLmdldE51bWJlck9mUm93cygpOyByKyspIHtcbiAgICAgICAgICAgICAgICBfbG9vcF8xKHIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIEU7XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBOZXR3b3JrO1xuICAgIH0oKSk7XG4gICAgRmVlZEZvcndhcmQuTmV0d29yayA9IE5ldHdvcms7XG59KShGZWVkRm9yd2FyZCA9IGV4cG9ydHMuRmVlZEZvcndhcmQgfHwgKGV4cG9ydHMuRmVlZEZvcndhcmQgPSB7fSkpO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9zcmMvTmV1cmFsTmV0d29ya3MvYW5uLm1hdHJpeC50c1xuLy8gbW9kdWxlIGlkID0gMlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Iiwic291cmNlUm9vdCI6IiJ9");

/***/ }),
/* 3 */
/* unknown exports provided */
/* all exports used */
/*!**********************************************!*\
  !*** ./src/NeuralNetworks/errorFunctions.ts ***!
  \**********************************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar Errors = (function () {\n    function Errors() {\n    }\n    return Errors;\n}());\nErrors.SQUARE = {\n    error: function (output, target) { return 0.5 * Math.pow(output - target, 2); },\n    der: function (output, target) { return output - target; }\n};\nErrors.CROSS_ENTROPY = {\n    error: function (output, target) {\n        return -(target * Math.log(output) + (1 - target) * Math.log(1 - output));\n    },\n    der: function (output, target) {\n        return (output - target) / ((1 - output) * output);\n    }\n};\nexports.Errors = Errors;\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL3NyYy9OZXVyYWxOZXR3b3Jrcy9lcnJvckZ1bmN0aW9ucy50cz9kYzkzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIEVycm9ycyA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gRXJyb3JzKCkge1xuICAgIH1cbiAgICByZXR1cm4gRXJyb3JzO1xufSgpKTtcbkVycm9ycy5TUVVBUkUgPSB7XG4gICAgZXJyb3I6IGZ1bmN0aW9uIChvdXRwdXQsIHRhcmdldCkgeyByZXR1cm4gMC41ICogTWF0aC5wb3cob3V0cHV0IC0gdGFyZ2V0LCAyKTsgfSxcbiAgICBkZXI6IGZ1bmN0aW9uIChvdXRwdXQsIHRhcmdldCkgeyByZXR1cm4gb3V0cHV0IC0gdGFyZ2V0OyB9XG59O1xuRXJyb3JzLkNST1NTX0VOVFJPUFkgPSB7XG4gICAgZXJyb3I6IGZ1bmN0aW9uIChvdXRwdXQsIHRhcmdldCkge1xuICAgICAgICByZXR1cm4gLSh0YXJnZXQgKiBNYXRoLmxvZyhvdXRwdXQpICsgKDEgLSB0YXJnZXQpICogTWF0aC5sb2coMSAtIG91dHB1dCkpO1xuICAgIH0sXG4gICAgZGVyOiBmdW5jdGlvbiAob3V0cHV0LCB0YXJnZXQpIHtcbiAgICAgICAgcmV0dXJuIChvdXRwdXQgLSB0YXJnZXQpIC8gKCgxIC0gb3V0cHV0KSAqIG91dHB1dCk7XG4gICAgfVxufTtcbmV4cG9ydHMuRXJyb3JzID0gRXJyb3JzO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9zcmMvTmV1cmFsTmV0d29ya3MvZXJyb3JGdW5jdGlvbnMudHNcbi8vIG1vZHVsZSBpZCA9IDNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOyIsInNvdXJjZVJvb3QiOiIifQ==");

/***/ }),
/* 4 */
/* unknown exports provided */
/* all exports used */
/*!************************************!*\
  !*** ./src/helper/classToValue.ts ***!
  \************************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar ClassToValue = (function () {\n    function ClassToValue() {\n        this.dictionary = [];\n    }\n    ClassToValue.prototype.toValue = function (className) {\n        if (this.dictionary.includes(className)) {\n            return this.dictionary.indexOf(className);\n        }\n        else {\n            this.dictionary.push(className);\n            return this.dictionary.length - 1;\n        }\n    };\n    ClassToValue.prototype.toClass = function (value) {\n        return this.dictionary[value];\n    };\n    return ClassToValue;\n}());\nexports.ClassToValue = ClassToValue;\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNC5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL3NyYy9oZWxwZXIvY2xhc3NUb1ZhbHVlLnRzPzhkZTUiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgQ2xhc3NUb1ZhbHVlID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBDbGFzc1RvVmFsdWUoKSB7XG4gICAgICAgIHRoaXMuZGljdGlvbmFyeSA9IFtdO1xuICAgIH1cbiAgICBDbGFzc1RvVmFsdWUucHJvdG90eXBlLnRvVmFsdWUgPSBmdW5jdGlvbiAoY2xhc3NOYW1lKSB7XG4gICAgICAgIGlmICh0aGlzLmRpY3Rpb25hcnkuaW5jbHVkZXMoY2xhc3NOYW1lKSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZGljdGlvbmFyeS5pbmRleE9mKGNsYXNzTmFtZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmRpY3Rpb25hcnkucHVzaChjbGFzc05hbWUpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZGljdGlvbmFyeS5sZW5ndGggLSAxO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBDbGFzc1RvVmFsdWUucHJvdG90eXBlLnRvQ2xhc3MgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZGljdGlvbmFyeVt2YWx1ZV07XG4gICAgfTtcbiAgICByZXR1cm4gQ2xhc3NUb1ZhbHVlO1xufSgpKTtcbmV4cG9ydHMuQ2xhc3NUb1ZhbHVlID0gQ2xhc3NUb1ZhbHVlO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9zcmMvaGVscGVyL2NsYXNzVG9WYWx1ZS50c1xuLy8gbW9kdWxlIGlkID0gNFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTsiLCJzb3VyY2VSb290IjoiIn0=");

/***/ }),
/* 5 */
/* unknown exports provided */
/* all exports used */
/*!*********************************!*\
  !*** ./src/helper/distances.ts ***!
  \*********************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar Distances = (function () {\n    function Distances() {\n    }\n    return Distances;\n}());\nDistances.EUCLIDEAN = function (a, b) {\n    return Math.sqrt(a.reduce(function (s, a, i) {\n        return s + Math.pow(a - b[i], 2);\n    }, 0));\n};\nDistances.TAXI = function (a, b) {\n    return a.reduce(function (s, a, i) {\n        return s + Math.abs(a - b[i]);\n    }, 0);\n};\n// TODO: Understand\n// https://en.wikibooks.org/wiki/Algorithm_Implementation/Strings/Levenshtein_distance#JavaScript\nDistances.LEVENSHTEIN = function (a, b) {\n    if (a.length === 0)\n        return b.length;\n    if (b.length === 0)\n        return a.length;\n    return Math.min(Distances.LEVENSHTEIN(a.substr(1), b) + 1, Distances.LEVENSHTEIN(b.substr(1), a) + 1, Distances.LEVENSHTEIN(a.substr(1), b.substr(1)) + (a[0] !== b[0] ? 1 : 0));\n};\nexports.Distances = Distances;\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNS5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL3NyYy9oZWxwZXIvZGlzdGFuY2VzLnRzPzBmNzMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgRGlzdGFuY2VzID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBEaXN0YW5jZXMoKSB7XG4gICAgfVxuICAgIHJldHVybiBEaXN0YW5jZXM7XG59KCkpO1xuRGlzdGFuY2VzLkVVQ0xJREVBTiA9IGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgcmV0dXJuIE1hdGguc3FydChhLnJlZHVjZShmdW5jdGlvbiAocywgYSwgaSkge1xuICAgICAgICByZXR1cm4gcyArIE1hdGgucG93KGEgLSBiW2ldLCAyKTtcbiAgICB9LCAwKSk7XG59O1xuRGlzdGFuY2VzLlRBWEkgPSBmdW5jdGlvbiAoYSwgYikge1xuICAgIHJldHVybiBhLnJlZHVjZShmdW5jdGlvbiAocywgYSwgaSkge1xuICAgICAgICByZXR1cm4gcyArIE1hdGguYWJzKGEgLSBiW2ldKTtcbiAgICB9LCAwKTtcbn07XG4vLyBUT0RPOiBVbmRlcnN0YW5kXG4vLyBodHRwczovL2VuLndpa2lib29rcy5vcmcvd2lraS9BbGdvcml0aG1fSW1wbGVtZW50YXRpb24vU3RyaW5ncy9MZXZlbnNodGVpbl9kaXN0YW5jZSNKYXZhU2NyaXB0XG5EaXN0YW5jZXMuTEVWRU5TSFRFSU4gPSBmdW5jdGlvbiAoYSwgYikge1xuICAgIGlmIChhLmxlbmd0aCA9PT0gMClcbiAgICAgICAgcmV0dXJuIGIubGVuZ3RoO1xuICAgIGlmIChiLmxlbmd0aCA9PT0gMClcbiAgICAgICAgcmV0dXJuIGEubGVuZ3RoO1xuICAgIHJldHVybiBNYXRoLm1pbihEaXN0YW5jZXMuTEVWRU5TSFRFSU4oYS5zdWJzdHIoMSksIGIpICsgMSwgRGlzdGFuY2VzLkxFVkVOU0hURUlOKGIuc3Vic3RyKDEpLCBhKSArIDEsIERpc3RhbmNlcy5MRVZFTlNIVEVJTihhLnN1YnN0cigxKSwgYi5zdWJzdHIoMSkpICsgKGFbMF0gIT09IGJbMF0gPyAxIDogMCkpO1xufTtcbmV4cG9ydHMuRGlzdGFuY2VzID0gRGlzdGFuY2VzO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9zcmMvaGVscGVyL2Rpc3RhbmNlcy50c1xuLy8gbW9kdWxlIGlkID0gNVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTsiLCJzb3VyY2VSb290IjoiIn0=");

/***/ }),
/* 6 */
/* unknown exports provided */
/* all exports used */
/*!**********************************!*\
  !*** ./src/helper/generators.ts ***!
  \**********************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar __1 = __webpack_require__(/*! .. */ 0);\nvar Generators;\n(function (Generators) {\n    function clouds(clouds, dataPointsForCloud, dimensions, min, max, spread) {\n        if (dataPointsForCloud === void 0) { dataPointsForCloud = 10; }\n        if (dimensions === void 0) { dimensions = 2; }\n        if (min === void 0) { min = 0; }\n        if (max === void 0) { max = 1; }\n        if (spread === void 0) { spread = 0.1; }\n        var range = max - min;\n        var clusterCenters = new Array(clouds).fill(0).map(function (c) { return new Array(dimensions).fill(0).map(function (c) { return __1.Maths.random(min, max); }); });\n        var data = [];\n        for (var _i = 0, clusterCenters_1 = clusterCenters; _i < clusterCenters_1.length; _i++) {\n            var center = clusterCenters_1[_i];\n            var points = [];\n            for (var i = 0; i < dataPointsForCloud; i++) {\n                points.push(center.map(function (c) { return c += (__1.Maths.randomBool() ? -1 : 1) * spread * __1.Maths.random(min, max); }));\n            }\n            data.push({ center: center, points: points });\n        }\n        return data;\n    }\n    Generators.clouds = clouds;\n})(Generators = exports.Generators || (exports.Generators = {}));\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNi5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL3NyYy9oZWxwZXIvZ2VuZXJhdG9ycy50cz85M2ZiIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIF9fMSA9IHJlcXVpcmUoXCIuLlwiKTtcbnZhciBHZW5lcmF0b3JzO1xuKGZ1bmN0aW9uIChHZW5lcmF0b3JzKSB7XG4gICAgZnVuY3Rpb24gY2xvdWRzKGNsb3VkcywgZGF0YVBvaW50c0ZvckNsb3VkLCBkaW1lbnNpb25zLCBtaW4sIG1heCwgc3ByZWFkKSB7XG4gICAgICAgIGlmIChkYXRhUG9pbnRzRm9yQ2xvdWQgPT09IHZvaWQgMCkgeyBkYXRhUG9pbnRzRm9yQ2xvdWQgPSAxMDsgfVxuICAgICAgICBpZiAoZGltZW5zaW9ucyA9PT0gdm9pZCAwKSB7IGRpbWVuc2lvbnMgPSAyOyB9XG4gICAgICAgIGlmIChtaW4gPT09IHZvaWQgMCkgeyBtaW4gPSAwOyB9XG4gICAgICAgIGlmIChtYXggPT09IHZvaWQgMCkgeyBtYXggPSAxOyB9XG4gICAgICAgIGlmIChzcHJlYWQgPT09IHZvaWQgMCkgeyBzcHJlYWQgPSAwLjE7IH1cbiAgICAgICAgdmFyIHJhbmdlID0gbWF4IC0gbWluO1xuICAgICAgICB2YXIgY2x1c3RlckNlbnRlcnMgPSBuZXcgQXJyYXkoY2xvdWRzKS5maWxsKDApLm1hcChmdW5jdGlvbiAoYykgeyByZXR1cm4gbmV3IEFycmF5KGRpbWVuc2lvbnMpLmZpbGwoMCkubWFwKGZ1bmN0aW9uIChjKSB7IHJldHVybiBfXzEuTWF0aHMucmFuZG9tKG1pbiwgbWF4KTsgfSk7IH0pO1xuICAgICAgICB2YXIgZGF0YSA9IFtdO1xuICAgICAgICBmb3IgKHZhciBfaSA9IDAsIGNsdXN0ZXJDZW50ZXJzXzEgPSBjbHVzdGVyQ2VudGVyczsgX2kgPCBjbHVzdGVyQ2VudGVyc18xLmxlbmd0aDsgX2krKykge1xuICAgICAgICAgICAgdmFyIGNlbnRlciA9IGNsdXN0ZXJDZW50ZXJzXzFbX2ldO1xuICAgICAgICAgICAgdmFyIHBvaW50cyA9IFtdO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBkYXRhUG9pbnRzRm9yQ2xvdWQ7IGkrKykge1xuICAgICAgICAgICAgICAgIHBvaW50cy5wdXNoKGNlbnRlci5tYXAoZnVuY3Rpb24gKGMpIHsgcmV0dXJuIGMgKz0gKF9fMS5NYXRocy5yYW5kb21Cb29sKCkgPyAtMSA6IDEpICogc3ByZWFkICogX18xLk1hdGhzLnJhbmRvbShtaW4sIG1heCk7IH0pKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGRhdGEucHVzaCh7IGNlbnRlcjogY2VudGVyLCBwb2ludHM6IHBvaW50cyB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZGF0YTtcbiAgICB9XG4gICAgR2VuZXJhdG9ycy5jbG91ZHMgPSBjbG91ZHM7XG59KShHZW5lcmF0b3JzID0gZXhwb3J0cy5HZW5lcmF0b3JzIHx8IChleHBvcnRzLkdlbmVyYXRvcnMgPSB7fSkpO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9zcmMvaGVscGVyL2dlbmVyYXRvcnMudHNcbi8vIG1vZHVsZSBpZCA9IDZcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOyIsInNvdXJjZVJvb3QiOiIifQ==");

/***/ }),
/* 7 */
/* unknown exports provided */
/* all exports used */
/*!*****************************!*\
  !*** ./src/helper/maths.ts ***!
  \*****************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar __1 = __webpack_require__(/*! .. */ 0);\nvar Maths;\n(function (Maths) {\n    function randomInt(min, max) {\n        return Math.floor(Math.random() * (max + 1 - min) + min);\n    }\n    Maths.randomInt = randomInt;\n    function random(min, max) {\n        return Math.random() * (max - min) + min;\n    }\n    Maths.random = random;\n    function argmax(args) {\n        var record = {};\n        args.forEach(function (a) { return record[a] = record[a] + 1 || 1; });\n        var max = record[args[0]];\n        var arg = args[0];\n        for (var _i = 0, args_1 = args; _i < args_1.length; _i++) {\n            var key = args_1[_i];\n            if (record[key] > max) {\n                max = record[key];\n                arg = key;\n            }\n        }\n        return arg;\n    }\n    Maths.argmax = argmax;\n    function randomBool() {\n        return Math.random() > 0.5 ? true : false;\n    }\n    Maths.randomBool = randomBool;\n    function round(value, decimals) {\n        if (decimals === void 0) { decimals = 1; }\n        var f = Math.pow(10, decimals);\n        return Math.round(value * f) / f;\n    }\n    Maths.round = round;\n    function sum(c) {\n        var M = c instanceof __1.Matrix ? c.getColumnAsRowVector(0).getArray()[0] : c;\n        return M.reduce(function (s, x) { return s + x; }, 0);\n    }\n    Maths.sum = sum;\n})(Maths = exports.Maths || (exports.Maths = {}));\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL3NyYy9oZWxwZXIvbWF0aHMudHM/YWE4MyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBfXzEgPSByZXF1aXJlKFwiLi5cIik7XG52YXIgTWF0aHM7XG4oZnVuY3Rpb24gKE1hdGhzKSB7XG4gICAgZnVuY3Rpb24gcmFuZG9tSW50KG1pbiwgbWF4KSB7XG4gICAgICAgIHJldHVybiBNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiAobWF4ICsgMSAtIG1pbikgKyBtaW4pO1xuICAgIH1cbiAgICBNYXRocy5yYW5kb21JbnQgPSByYW5kb21JbnQ7XG4gICAgZnVuY3Rpb24gcmFuZG9tKG1pbiwgbWF4KSB7XG4gICAgICAgIHJldHVybiBNYXRoLnJhbmRvbSgpICogKG1heCAtIG1pbikgKyBtaW47XG4gICAgfVxuICAgIE1hdGhzLnJhbmRvbSA9IHJhbmRvbTtcbiAgICBmdW5jdGlvbiBhcmdtYXgoYXJncykge1xuICAgICAgICB2YXIgcmVjb3JkID0ge307XG4gICAgICAgIGFyZ3MuZm9yRWFjaChmdW5jdGlvbiAoYSkgeyByZXR1cm4gcmVjb3JkW2FdID0gcmVjb3JkW2FdICsgMSB8fCAxOyB9KTtcbiAgICAgICAgdmFyIG1heCA9IHJlY29yZFthcmdzWzBdXTtcbiAgICAgICAgdmFyIGFyZyA9IGFyZ3NbMF07XG4gICAgICAgIGZvciAodmFyIF9pID0gMCwgYXJnc18xID0gYXJnczsgX2kgPCBhcmdzXzEubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgICB2YXIga2V5ID0gYXJnc18xW19pXTtcbiAgICAgICAgICAgIGlmIChyZWNvcmRba2V5XSA+IG1heCkge1xuICAgICAgICAgICAgICAgIG1heCA9IHJlY29yZFtrZXldO1xuICAgICAgICAgICAgICAgIGFyZyA9IGtleTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYXJnO1xuICAgIH1cbiAgICBNYXRocy5hcmdtYXggPSBhcmdtYXg7XG4gICAgZnVuY3Rpb24gcmFuZG9tQm9vbCgpIHtcbiAgICAgICAgcmV0dXJuIE1hdGgucmFuZG9tKCkgPiAwLjUgPyB0cnVlIDogZmFsc2U7XG4gICAgfVxuICAgIE1hdGhzLnJhbmRvbUJvb2wgPSByYW5kb21Cb29sO1xuICAgIGZ1bmN0aW9uIHJvdW5kKHZhbHVlLCBkZWNpbWFscykge1xuICAgICAgICBpZiAoZGVjaW1hbHMgPT09IHZvaWQgMCkgeyBkZWNpbWFscyA9IDE7IH1cbiAgICAgICAgdmFyIGYgPSBNYXRoLnBvdygxMCwgZGVjaW1hbHMpO1xuICAgICAgICByZXR1cm4gTWF0aC5yb3VuZCh2YWx1ZSAqIGYpIC8gZjtcbiAgICB9XG4gICAgTWF0aHMucm91bmQgPSByb3VuZDtcbiAgICBmdW5jdGlvbiBzdW0oYykge1xuICAgICAgICB2YXIgTSA9IGMgaW5zdGFuY2VvZiBfXzEuTWF0cml4ID8gYy5nZXRDb2x1bW5Bc1Jvd1ZlY3RvcigwKS5nZXRBcnJheSgpWzBdIDogYztcbiAgICAgICAgcmV0dXJuIE0ucmVkdWNlKGZ1bmN0aW9uIChzLCB4KSB7IHJldHVybiBzICsgeDsgfSwgMCk7XG4gICAgfVxuICAgIE1hdGhzLnN1bSA9IHN1bTtcbn0pKE1hdGhzID0gZXhwb3J0cy5NYXRocyB8fCAoZXhwb3J0cy5NYXRocyA9IHt9KSk7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL3NyYy9oZWxwZXIvbWF0aHMudHNcbi8vIG1vZHVsZSBpZCA9IDdcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOyIsInNvdXJjZVJvb3QiOiIifQ==");

/***/ }),
/* 8 */
/* unknown exports provided */
/* all exports used */
/*!*************************************!*\
  !*** ./src/helper/normalization.ts ***!
  \*************************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar Normalization;\n(function (Normalization) {\n    var MinMaxNormalizer = (function () {\n        function MinMaxNormalizer(data) {\n            this.data = data;\n            this.minValues = [];\n            this.maxValues = [];\n            var columns = data[0].length;\n            var _loop_1 = function (c) {\n                var column = data.map(function (r) { return r[c]; });\n                this_1.minValues.push(Math.min.apply(Math, column));\n                this_1.maxValues.push(Math.max.apply(Math, column));\n            };\n            var this_1 = this;\n            for (var c = 0; c < columns; c++) {\n                _loop_1(c);\n            }\n        }\n        MinMaxNormalizer.prototype.normalizeExampleData = function () {\n            var _this = this;\n            return this.data.map(function (row, r) { return row.map(function (x, column) {\n                return (x - _this.minValues[column]) / (_this.maxValues[column] - _this.minValues[column]);\n            }); });\n        };\n        MinMaxNormalizer.prototype.normalizeNewDataRow = function (row) {\n            var _this = this;\n            return row.map(function (value, v) {\n                return (v - _this.minValues[v]) / (_this.maxValues[v] - _this.minValues[v]);\n            });\n        };\n        MinMaxNormalizer.prototype.denormalize = function (row) {\n            var _this = this;\n            return row.map(function (value, v) {\n                return v * (_this.maxValues[v] - _this.minValues[v]) + _this.minValues[v];\n            });\n        };\n        return MinMaxNormalizer;\n    }());\n    Normalization.MinMaxNormalizer = MinMaxNormalizer;\n})(Normalization = exports.Normalization || (exports.Normalization = {}));\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiOC5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL3NyYy9oZWxwZXIvbm9ybWFsaXphdGlvbi50cz9jZjJjIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIE5vcm1hbGl6YXRpb247XG4oZnVuY3Rpb24gKE5vcm1hbGl6YXRpb24pIHtcbiAgICB2YXIgTWluTWF4Tm9ybWFsaXplciA9IChmdW5jdGlvbiAoKSB7XG4gICAgICAgIGZ1bmN0aW9uIE1pbk1heE5vcm1hbGl6ZXIoZGF0YSkge1xuICAgICAgICAgICAgdGhpcy5kYXRhID0gZGF0YTtcbiAgICAgICAgICAgIHRoaXMubWluVmFsdWVzID0gW107XG4gICAgICAgICAgICB0aGlzLm1heFZhbHVlcyA9IFtdO1xuICAgICAgICAgICAgdmFyIGNvbHVtbnMgPSBkYXRhWzBdLmxlbmd0aDtcbiAgICAgICAgICAgIHZhciBfbG9vcF8xID0gZnVuY3Rpb24gKGMpIHtcbiAgICAgICAgICAgICAgICB2YXIgY29sdW1uID0gZGF0YS5tYXAoZnVuY3Rpb24gKHIpIHsgcmV0dXJuIHJbY107IH0pO1xuICAgICAgICAgICAgICAgIHRoaXNfMS5taW5WYWx1ZXMucHVzaChNYXRoLm1pbi5hcHBseShNYXRoLCBjb2x1bW4pKTtcbiAgICAgICAgICAgICAgICB0aGlzXzEubWF4VmFsdWVzLnB1c2goTWF0aC5tYXguYXBwbHkoTWF0aCwgY29sdW1uKSk7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgdmFyIHRoaXNfMSA9IHRoaXM7XG4gICAgICAgICAgICBmb3IgKHZhciBjID0gMDsgYyA8IGNvbHVtbnM7IGMrKykge1xuICAgICAgICAgICAgICAgIF9sb29wXzEoYyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgTWluTWF4Tm9ybWFsaXplci5wcm90b3R5cGUubm9ybWFsaXplRXhhbXBsZURhdGEgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZGF0YS5tYXAoZnVuY3Rpb24gKHJvdywgcikgeyByZXR1cm4gcm93Lm1hcChmdW5jdGlvbiAoeCwgY29sdW1uKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICh4IC0gX3RoaXMubWluVmFsdWVzW2NvbHVtbl0pIC8gKF90aGlzLm1heFZhbHVlc1tjb2x1bW5dIC0gX3RoaXMubWluVmFsdWVzW2NvbHVtbl0pO1xuICAgICAgICAgICAgfSk7IH0pO1xuICAgICAgICB9O1xuICAgICAgICBNaW5NYXhOb3JtYWxpemVyLnByb3RvdHlwZS5ub3JtYWxpemVOZXdEYXRhUm93ID0gZnVuY3Rpb24gKHJvdykge1xuICAgICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgICAgIHJldHVybiByb3cubWFwKGZ1bmN0aW9uICh2YWx1ZSwgdikge1xuICAgICAgICAgICAgICAgIHJldHVybiAodiAtIF90aGlzLm1pblZhbHVlc1t2XSkgLyAoX3RoaXMubWF4VmFsdWVzW3ZdIC0gX3RoaXMubWluVmFsdWVzW3ZdKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9O1xuICAgICAgICBNaW5NYXhOb3JtYWxpemVyLnByb3RvdHlwZS5kZW5vcm1hbGl6ZSA9IGZ1bmN0aW9uIChyb3cpIHtcbiAgICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgICAgICByZXR1cm4gcm93Lm1hcChmdW5jdGlvbiAodmFsdWUsIHYpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdiAqIChfdGhpcy5tYXhWYWx1ZXNbdl0gLSBfdGhpcy5taW5WYWx1ZXNbdl0pICsgX3RoaXMubWluVmFsdWVzW3ZdO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBNaW5NYXhOb3JtYWxpemVyO1xuICAgIH0oKSk7XG4gICAgTm9ybWFsaXphdGlvbi5NaW5NYXhOb3JtYWxpemVyID0gTWluTWF4Tm9ybWFsaXplcjtcbn0pKE5vcm1hbGl6YXRpb24gPSBleHBvcnRzLk5vcm1hbGl6YXRpb24gfHwgKGV4cG9ydHMuTm9ybWFsaXphdGlvbiA9IHt9KSk7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL3NyYy9oZWxwZXIvbm9ybWFsaXphdGlvbi50c1xuLy8gbW9kdWxlIGlkID0gOFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTsiLCJzb3VyY2VSb290IjoiIn0=");

/***/ }),
/* 9 */
/* unknown exports provided */
/* all exports used */
/*!*********************************!*\
  !*** ./src/helper/utilities.ts ***!
  \*********************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar __1 = __webpack_require__(/*! .. */ 0);\nvar Utilities;\n(function (Utilities) {\n    function repeat(func, iterations) {\n        for (var i = 0; i < iterations; i++) {\n            func(i);\n        }\n    }\n    Utilities.repeat = repeat;\n    function csvStringToJSON(csv, tryObjectParseIfPossible, columnSeparator, rowSeparator) {\n        if (tryObjectParseIfPossible === void 0) { tryObjectParseIfPossible = true; }\n        if (columnSeparator === void 0) { columnSeparator = ','; }\n        if (rowSeparator === void 0) { rowSeparator = '\\r\\n'; }\n        var data = csv.trim().split(rowSeparator).map(function (r) { return r.split(columnSeparator).map(function (c) { return isNaN(c) ? c : parseFloat(c); }); });\n        if (data[0].every(function (c) { return typeof c == 'string'; }) && tryObjectParseIfPossible) {\n            var labels_1 = data.splice(0, 1)[0];\n            var jsonData = data.map(function (r, i) {\n                var rowObject = {};\n                for (var i_1 = 0; i_1 < labels_1.length; i_1++) {\n                    rowObject[labels_1[i_1]] = r[i_1];\n                }\n                return rowObject;\n            });\n            return jsonData;\n        }\n        else {\n            return data;\n        }\n    }\n    Utilities.csvStringToJSON = csvStringToJSON;\n    function pickRandomFromArray(array) {\n        return array[__1.Maths.randomInt(0, array.length - 1)];\n    }\n    Utilities.pickRandomFromArray = pickRandomFromArray;\n})(Utilities = exports.Utilities || (exports.Utilities = {}));\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiOS5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL3NyYy9oZWxwZXIvdXRpbGl0aWVzLnRzP2VlYmQiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgX18xID0gcmVxdWlyZShcIi4uXCIpO1xudmFyIFV0aWxpdGllcztcbihmdW5jdGlvbiAoVXRpbGl0aWVzKSB7XG4gICAgZnVuY3Rpb24gcmVwZWF0KGZ1bmMsIGl0ZXJhdGlvbnMpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBpdGVyYXRpb25zOyBpKyspIHtcbiAgICAgICAgICAgIGZ1bmMoaSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgVXRpbGl0aWVzLnJlcGVhdCA9IHJlcGVhdDtcbiAgICBmdW5jdGlvbiBjc3ZTdHJpbmdUb0pTT04oY3N2LCB0cnlPYmplY3RQYXJzZUlmUG9zc2libGUsIGNvbHVtblNlcGFyYXRvciwgcm93U2VwYXJhdG9yKSB7XG4gICAgICAgIGlmICh0cnlPYmplY3RQYXJzZUlmUG9zc2libGUgPT09IHZvaWQgMCkgeyB0cnlPYmplY3RQYXJzZUlmUG9zc2libGUgPSB0cnVlOyB9XG4gICAgICAgIGlmIChjb2x1bW5TZXBhcmF0b3IgPT09IHZvaWQgMCkgeyBjb2x1bW5TZXBhcmF0b3IgPSAnLCc7IH1cbiAgICAgICAgaWYgKHJvd1NlcGFyYXRvciA9PT0gdm9pZCAwKSB7IHJvd1NlcGFyYXRvciA9ICdcXHJcXG4nOyB9XG4gICAgICAgIHZhciBkYXRhID0gY3N2LnRyaW0oKS5zcGxpdChyb3dTZXBhcmF0b3IpLm1hcChmdW5jdGlvbiAocikgeyByZXR1cm4gci5zcGxpdChjb2x1bW5TZXBhcmF0b3IpLm1hcChmdW5jdGlvbiAoYykgeyByZXR1cm4gaXNOYU4oYykgPyBjIDogcGFyc2VGbG9hdChjKTsgfSk7IH0pO1xuICAgICAgICBpZiAoZGF0YVswXS5ldmVyeShmdW5jdGlvbiAoYykgeyByZXR1cm4gdHlwZW9mIGMgPT0gJ3N0cmluZyc7IH0pICYmIHRyeU9iamVjdFBhcnNlSWZQb3NzaWJsZSkge1xuICAgICAgICAgICAgdmFyIGxhYmVsc18xID0gZGF0YS5zcGxpY2UoMCwgMSlbMF07XG4gICAgICAgICAgICB2YXIganNvbkRhdGEgPSBkYXRhLm1hcChmdW5jdGlvbiAociwgaSkge1xuICAgICAgICAgICAgICAgIHZhciByb3dPYmplY3QgPSB7fTtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpXzEgPSAwOyBpXzEgPCBsYWJlbHNfMS5sZW5ndGg7IGlfMSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIHJvd09iamVjdFtsYWJlbHNfMVtpXzFdXSA9IHJbaV8xXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJvd09iamVjdDtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIGpzb25EYXRhO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIGRhdGE7XG4gICAgICAgIH1cbiAgICB9XG4gICAgVXRpbGl0aWVzLmNzdlN0cmluZ1RvSlNPTiA9IGNzdlN0cmluZ1RvSlNPTjtcbiAgICBmdW5jdGlvbiBwaWNrUmFuZG9tRnJvbUFycmF5KGFycmF5KSB7XG4gICAgICAgIHJldHVybiBhcnJheVtfXzEuTWF0aHMucmFuZG9tSW50KDAsIGFycmF5Lmxlbmd0aCAtIDEpXTtcbiAgICB9XG4gICAgVXRpbGl0aWVzLnBpY2tSYW5kb21Gcm9tQXJyYXkgPSBwaWNrUmFuZG9tRnJvbUFycmF5O1xufSkoVXRpbGl0aWVzID0gZXhwb3J0cy5VdGlsaXRpZXMgfHwgKGV4cG9ydHMuVXRpbGl0aWVzID0ge30pKTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vc3JjL2hlbHBlci91dGlsaXRpZXMudHNcbi8vIG1vZHVsZSBpZCA9IDlcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTsiLCJzb3VyY2VSb290IjoiIn0=");

/***/ }),
/* 10 */
/* unknown exports provided */
/* all exports used */
/*!************************!*\
  !*** ./src/k-means.ts ***!
  \************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar _1 = __webpack_require__(/*! . */ 0);\nvar KMeans = (function () {\n    function KMeans(data, numberOfClusters) {\n        var _this = this;\n        this.data = data;\n        this.numberOfClusters = numberOfClusters;\n        this.clusters = [];\n        _1.Utilities.repeat(function () {\n            _this.clusters.push(_1.Utilities.pickRandomFromArray(data));\n        }, numberOfClusters);\n    }\n    KMeans.prototype.fitClusters = function (distanceFunction) {\n        /*console.log('Data');\n        console.log(this.data[0]);*/\n        var _this = this;\n        if (distanceFunction === void 0) { distanceFunction = _1.Distances.EUCLIDEAN; }\n        var clusterChanged;\n        var _loop_1 = function () {\n            clusterChanged = false;\n            var clusterRecord = [];\n            var _loop_2 = function (point) {\n                var distances = this_1.clusters.map(function (c) { return distanceFunction(point, c); });\n                //console.log(distances);\n                var min = Math.min.apply(Math, distances);\n                var clusterIndex = distances.indexOf(min);\n                clusterRecord.push(clusterIndex);\n            };\n            for (var _i = 0, _a = this_1.data; _i < _a.length; _i++) {\n                var point = _a[_i];\n                _loop_2(point);\n            }\n            //console.log(clusterRecord);\n            this_1.clusters.forEach(function (c, ci) {\n                var pointsForCluster = clusterRecord.map(function (cr, i) { return cr == ci ? _this.data[i] : null; }).filter(function (c) { return c != null; });\n                var numberOfPoints = pointsForCluster.length;\n                var meanPoint = pointsForCluster.reduce(function (s, p) {\n                    if (p != undefined) {\n                        return s.map(function (v, i) { return v + p[i]; });\n                    }\n                }, new Array(_this.data[0].length).fill(0)).map(function (c) { return c / numberOfPoints; });\n                if (meanPoint.every(function (v, i) { return v != c[i]; })) {\n                    _this.clusters[ci] = meanPoint;\n                    clusterChanged = true;\n                }\n            });\n        };\n        var this_1 = this;\n        do {\n            _loop_1();\n        } while (clusterChanged);\n        return this.clusters;\n    };\n    return KMeans;\n}());\nexports.KMeans = KMeans;\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTAuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvay1tZWFucy50cz83NDgyIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIF8xID0gcmVxdWlyZShcIi5cIik7XG52YXIgS01lYW5zID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBLTWVhbnMoZGF0YSwgbnVtYmVyT2ZDbHVzdGVycykge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB0aGlzLmRhdGEgPSBkYXRhO1xuICAgICAgICB0aGlzLm51bWJlck9mQ2x1c3RlcnMgPSBudW1iZXJPZkNsdXN0ZXJzO1xuICAgICAgICB0aGlzLmNsdXN0ZXJzID0gW107XG4gICAgICAgIF8xLlV0aWxpdGllcy5yZXBlYXQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgX3RoaXMuY2x1c3RlcnMucHVzaChfMS5VdGlsaXRpZXMucGlja1JhbmRvbUZyb21BcnJheShkYXRhKSk7XG4gICAgICAgIH0sIG51bWJlck9mQ2x1c3RlcnMpO1xuICAgIH1cbiAgICBLTWVhbnMucHJvdG90eXBlLmZpdENsdXN0ZXJzID0gZnVuY3Rpb24gKGRpc3RhbmNlRnVuY3Rpb24pIHtcbiAgICAgICAgLypjb25zb2xlLmxvZygnRGF0YScpO1xuICAgICAgICBjb25zb2xlLmxvZyh0aGlzLmRhdGFbMF0pOyovXG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIGlmIChkaXN0YW5jZUZ1bmN0aW9uID09PSB2b2lkIDApIHsgZGlzdGFuY2VGdW5jdGlvbiA9IF8xLkRpc3RhbmNlcy5FVUNMSURFQU47IH1cbiAgICAgICAgdmFyIGNsdXN0ZXJDaGFuZ2VkO1xuICAgICAgICB2YXIgX2xvb3BfMSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGNsdXN0ZXJDaGFuZ2VkID0gZmFsc2U7XG4gICAgICAgICAgICB2YXIgY2x1c3RlclJlY29yZCA9IFtdO1xuICAgICAgICAgICAgdmFyIF9sb29wXzIgPSBmdW5jdGlvbiAocG9pbnQpIHtcbiAgICAgICAgICAgICAgICB2YXIgZGlzdGFuY2VzID0gdGhpc18xLmNsdXN0ZXJzLm1hcChmdW5jdGlvbiAoYykgeyByZXR1cm4gZGlzdGFuY2VGdW5jdGlvbihwb2ludCwgYyk7IH0pO1xuICAgICAgICAgICAgICAgIC8vY29uc29sZS5sb2coZGlzdGFuY2VzKTtcbiAgICAgICAgICAgICAgICB2YXIgbWluID0gTWF0aC5taW4uYXBwbHkoTWF0aCwgZGlzdGFuY2VzKTtcbiAgICAgICAgICAgICAgICB2YXIgY2x1c3RlckluZGV4ID0gZGlzdGFuY2VzLmluZGV4T2YobWluKTtcbiAgICAgICAgICAgICAgICBjbHVzdGVyUmVjb3JkLnB1c2goY2x1c3RlckluZGV4KTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBmb3IgKHZhciBfaSA9IDAsIF9hID0gdGhpc18xLmRhdGE7IF9pIDwgX2EubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgICAgICAgdmFyIHBvaW50ID0gX2FbX2ldO1xuICAgICAgICAgICAgICAgIF9sb29wXzIocG9pbnQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy9jb25zb2xlLmxvZyhjbHVzdGVyUmVjb3JkKTtcbiAgICAgICAgICAgIHRoaXNfMS5jbHVzdGVycy5mb3JFYWNoKGZ1bmN0aW9uIChjLCBjaSkge1xuICAgICAgICAgICAgICAgIHZhciBwb2ludHNGb3JDbHVzdGVyID0gY2x1c3RlclJlY29yZC5tYXAoZnVuY3Rpb24gKGNyLCBpKSB7IHJldHVybiBjciA9PSBjaSA/IF90aGlzLmRhdGFbaV0gOiBudWxsOyB9KS5maWx0ZXIoZnVuY3Rpb24gKGMpIHsgcmV0dXJuIGMgIT0gbnVsbDsgfSk7XG4gICAgICAgICAgICAgICAgdmFyIG51bWJlck9mUG9pbnRzID0gcG9pbnRzRm9yQ2x1c3Rlci5sZW5ndGg7XG4gICAgICAgICAgICAgICAgdmFyIG1lYW5Qb2ludCA9IHBvaW50c0ZvckNsdXN0ZXIucmVkdWNlKGZ1bmN0aW9uIChzLCBwKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChwICE9IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHMubWFwKGZ1bmN0aW9uICh2LCBpKSB7IHJldHVybiB2ICsgcFtpXTsgfSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9LCBuZXcgQXJyYXkoX3RoaXMuZGF0YVswXS5sZW5ndGgpLmZpbGwoMCkpLm1hcChmdW5jdGlvbiAoYykgeyByZXR1cm4gYyAvIG51bWJlck9mUG9pbnRzOyB9KTtcbiAgICAgICAgICAgICAgICBpZiAobWVhblBvaW50LmV2ZXJ5KGZ1bmN0aW9uICh2LCBpKSB7IHJldHVybiB2ICE9IGNbaV07IH0pKSB7XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLmNsdXN0ZXJzW2NpXSA9IG1lYW5Qb2ludDtcbiAgICAgICAgICAgICAgICAgICAgY2x1c3RlckNoYW5nZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9O1xuICAgICAgICB2YXIgdGhpc18xID0gdGhpcztcbiAgICAgICAgZG8ge1xuICAgICAgICAgICAgX2xvb3BfMSgpO1xuICAgICAgICB9IHdoaWxlIChjbHVzdGVyQ2hhbmdlZCk7XG4gICAgICAgIHJldHVybiB0aGlzLmNsdXN0ZXJzO1xuICAgIH07XG4gICAgcmV0dXJuIEtNZWFucztcbn0oKSk7XG5leHBvcnRzLktNZWFucyA9IEtNZWFucztcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vc3JjL2stbWVhbnMudHNcbi8vIG1vZHVsZSBpZCA9IDEwXG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOyIsInNvdXJjZVJvb3QiOiIifQ==");

/***/ }),
/* 11 */
/* unknown exports provided */
/* all exports used */
/*!********************!*\
  !*** ./src/knn.ts ***!
  \********************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar _1 = __webpack_require__(/*! . */ 0);\nvar KNNClassifier = (function () {\n    function KNNClassifier(k, distanceFunction) {\n        if (k === void 0) { k = 3; }\n        if (distanceFunction === void 0) { distanceFunction = _1.Distances.EUCLIDEAN; }\n        this.k = k;\n        this.distanceFunction = distanceFunction;\n        this.data = [];\n        return this;\n    }\n    KNNClassifier.prototype.addData = function (classes, data) {\n        var _this = this;\n        classes.forEach(function (c, i) {\n            _this.data.push({\n                c: c,\n                attr: data[i]\n            });\n        });\n        return this;\n    };\n    KNNClassifier.prototype.predict = function (input, c2v) {\n        var _this = this;\n        var distances = [];\n        // Calculate distances\n        this.data.forEach(function (entry, i) {\n            return distances.push({\n                index: i,\n                distance: _this.distanceFunction(input, entry.attr)\n            });\n        });\n        // Sort distances\n        distances = distances.sort(function (a, b) {\n            if (a.distance > b.distance)\n                return 1;\n            if (a.distance < b.distance)\n                return -1;\n            return 0;\n        });\n        // get k smallest distances\n        var kNearest = distances.slice(0, this.k);\n        // get classes to those k distances from data array\n        var kNearestClasses = kNearest.map(function (e) { return _this.data[e.index].c; });\n        // get the most often occurring class\n        var c = _1.Maths.argmax(kNearestClasses);\n        // return value or class if c2v is passed\n        return c2v ? c2v.toClass(c) : c;\n    };\n    return KNNClassifier;\n}());\nexports.KNNClassifier = KNNClassifier;\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTEuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMva25uLnRzPzAzYjciXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgXzEgPSByZXF1aXJlKFwiLlwiKTtcbnZhciBLTk5DbGFzc2lmaWVyID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBLTk5DbGFzc2lmaWVyKGssIGRpc3RhbmNlRnVuY3Rpb24pIHtcbiAgICAgICAgaWYgKGsgPT09IHZvaWQgMCkgeyBrID0gMzsgfVxuICAgICAgICBpZiAoZGlzdGFuY2VGdW5jdGlvbiA9PT0gdm9pZCAwKSB7IGRpc3RhbmNlRnVuY3Rpb24gPSBfMS5EaXN0YW5jZXMuRVVDTElERUFOOyB9XG4gICAgICAgIHRoaXMuayA9IGs7XG4gICAgICAgIHRoaXMuZGlzdGFuY2VGdW5jdGlvbiA9IGRpc3RhbmNlRnVuY3Rpb247XG4gICAgICAgIHRoaXMuZGF0YSA9IFtdO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgS05OQ2xhc3NpZmllci5wcm90b3R5cGUuYWRkRGF0YSA9IGZ1bmN0aW9uIChjbGFzc2VzLCBkYXRhKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIGNsYXNzZXMuZm9yRWFjaChmdW5jdGlvbiAoYywgaSkge1xuICAgICAgICAgICAgX3RoaXMuZGF0YS5wdXNoKHtcbiAgICAgICAgICAgICAgICBjOiBjLFxuICAgICAgICAgICAgICAgIGF0dHI6IGRhdGFbaV1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcbiAgICBLTk5DbGFzc2lmaWVyLnByb3RvdHlwZS5wcmVkaWN0ID0gZnVuY3Rpb24gKGlucHV0LCBjMnYpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdmFyIGRpc3RhbmNlcyA9IFtdO1xuICAgICAgICAvLyBDYWxjdWxhdGUgZGlzdGFuY2VzXG4gICAgICAgIHRoaXMuZGF0YS5mb3JFYWNoKGZ1bmN0aW9uIChlbnRyeSwgaSkge1xuICAgICAgICAgICAgcmV0dXJuIGRpc3RhbmNlcy5wdXNoKHtcbiAgICAgICAgICAgICAgICBpbmRleDogaSxcbiAgICAgICAgICAgICAgICBkaXN0YW5jZTogX3RoaXMuZGlzdGFuY2VGdW5jdGlvbihpbnB1dCwgZW50cnkuYXR0cilcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICAgICAgLy8gU29ydCBkaXN0YW5jZXNcbiAgICAgICAgZGlzdGFuY2VzID0gZGlzdGFuY2VzLnNvcnQoZnVuY3Rpb24gKGEsIGIpIHtcbiAgICAgICAgICAgIGlmIChhLmRpc3RhbmNlID4gYi5kaXN0YW5jZSlcbiAgICAgICAgICAgICAgICByZXR1cm4gMTtcbiAgICAgICAgICAgIGlmIChhLmRpc3RhbmNlIDwgYi5kaXN0YW5jZSlcbiAgICAgICAgICAgICAgICByZXR1cm4gLTE7XG4gICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgfSk7XG4gICAgICAgIC8vIGdldCBrIHNtYWxsZXN0IGRpc3RhbmNlc1xuICAgICAgICB2YXIga05lYXJlc3QgPSBkaXN0YW5jZXMuc2xpY2UoMCwgdGhpcy5rKTtcbiAgICAgICAgLy8gZ2V0IGNsYXNzZXMgdG8gdGhvc2UgayBkaXN0YW5jZXMgZnJvbSBkYXRhIGFycmF5XG4gICAgICAgIHZhciBrTmVhcmVzdENsYXNzZXMgPSBrTmVhcmVzdC5tYXAoZnVuY3Rpb24gKGUpIHsgcmV0dXJuIF90aGlzLmRhdGFbZS5pbmRleF0uYzsgfSk7XG4gICAgICAgIC8vIGdldCB0aGUgbW9zdCBvZnRlbiBvY2N1cnJpbmcgY2xhc3NcbiAgICAgICAgdmFyIGMgPSBfMS5NYXRocy5hcmdtYXgoa05lYXJlc3RDbGFzc2VzKTtcbiAgICAgICAgLy8gcmV0dXJuIHZhbHVlIG9yIGNsYXNzIGlmIGMydiBpcyBwYXNzZWRcbiAgICAgICAgcmV0dXJuIGMydiA/IGMydi50b0NsYXNzKGMpIDogYztcbiAgICB9O1xuICAgIHJldHVybiBLTk5DbGFzc2lmaWVyO1xufSgpKTtcbmV4cG9ydHMuS05OQ2xhc3NpZmllciA9IEtOTkNsYXNzaWZpZXI7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL3NyYy9rbm4udHNcbi8vIG1vZHVsZSBpZCA9IDExXG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Iiwic291cmNlUm9vdCI6IiJ9");

/***/ }),
/* 12 */
/* unknown exports provided */
/* all exports used */
/*!***********************!*\
  !*** ./src/matrix.ts ***!
  \***********************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar Matrix = (function () {\n    function Matrix(p1, p2) {\n        if (typeof p1 == 'object') {\n            this.data = p1;\n        }\n        else {\n            this.data = Matrix.get2DArray(p1, p2);\n        }\n    }\n    Matrix.get2DArray = function (m, n, fill) {\n        if (fill === void 0) { fill = 0; }\n        return new Array(m).fill(0).map(function (r) { return new Array(n).fill(fill); });\n    };\n    Matrix.rowVector = function () {\n        var components = [];\n        for (var _i = 0; _i < arguments.length; _i++) {\n            components[_i] = arguments[_i];\n        }\n        return new Matrix([components]);\n    };\n    Matrix.columnVector = function () {\n        var components = [];\n        for (var _i = 0; _i < arguments.length; _i++) {\n            components[_i] = arguments[_i];\n        }\n        var v = components.map(function (c) { return [c]; });\n        return new Matrix(v);\n    };\n    Matrix.rand = function (rows, columns) {\n        var m = new Matrix(rows, columns);\n        m.map(function (v) { return Math.random(); });\n        return m;\n    };\n    Matrix.ones = function (rows, columns) {\n        var m = new Matrix(rows, columns);\n        m.fill(1);\n        return m;\n    };\n    Matrix.eye = function (size) {\n        var m = new Matrix(size, size);\n        for (var i = 0; i < size; i++)\n            m.set(i, i, 1);\n        return m;\n    };\n    Matrix.join = function (m1, m2, pos) {\n        if (pos === void 0) { pos = 'bottom'; }\n        var newData;\n        switch (pos) {\n            case 'top':\n                newData = m2.data.concat(m1.data);\n                break;\n            case 'bottom':\n                newData = m1.data.concat(m2.data);\n                break;\n            case 'left':\n                newData = m1.data.map(function (r, i) { return m2.data[i].concat(r); });\n                break;\n            case 'right':\n                newData = m1.data.map(function (r, i) { return r.concat(m2.data[i]); });\n                break;\n            default:\n                break;\n        }\n        return new Matrix(newData);\n    };\n    Matrix.prototype.size = function () {\n        return [this.getNumberOfRows(), this.getNumberOfColumns()];\n    };\n    Matrix.prototype.getNumberOfRows = function () {\n        return this.data.length;\n    };\n    Matrix.prototype.getNumberOfColumns = function () {\n        return this.data[0].length;\n    };\n    Matrix.prototype.getDimensions = function () {\n        return [this.getNumberOfRows(), this.getNumberOfColumns()];\n    };\n    Matrix.prototype.set = function (row, column, val) {\n        this.data[row][column] = val;\n    };\n    Matrix.prototype.get = function (row, column) {\n        return this.data[row][column];\n    };\n    Matrix.prototype.getRowAsRowVector = function (row) {\n        // Copy without reference\n        var v = new Matrix([this.data[row].slice()]);\n        return v;\n    };\n    Matrix.prototype.getColumnAsRowVector = function (column) {\n        // Copy without reference\n        var v = [];\n        for (var _i = 0, _a = this.data; _i < _a.length; _i++) {\n            var row = _a[_i];\n            v.push(row[column]);\n        }\n        return new Matrix([v]);\n    };\n    Matrix.prototype.getAsScalar = function () {\n        if (this.getDimensions().every(function (d) { return d == 1; })) {\n            return this.get(0, 0);\n        }\n        else {\n            this.error('size', 'getAsFloat (matrix must be 1x1)');\n        }\n    };\n    Matrix.prototype.getArray = function () {\n        // Deep copy without reference\n        return this.data.map(function (r) { return r.slice(); });\n    };\n    Matrix.prototype.copy = function () {\n        return new Matrix(this.getArray());\n    };\n    // endRow and endColumn exclusive if positive\n    // startRow and startColumn exclusive if negative\n    Matrix.prototype.slice = function (startRow, endRow, startColumn, endColumn) {\n        //Handle negatives\n        if (endRow < 0) {\n            endRow = this.getNumberOfRows() + (endRow + 1);\n        }\n        if (startRow < 0) {\n            startRow = this.getNumberOfRows() + (startRow + 1);\n        }\n        if (endColumn < 0) {\n            endColumn = this.getNumberOfColumns() + (endColumn + 1);\n        }\n        if (startColumn < 0) {\n            startColumn = this.getNumberOfColumns() + (startColumn + 1);\n        }\n        var res = new Matrix(endRow - startRow, endColumn - startColumn);\n        for (var row = startRow; row < endRow; row++) {\n            for (var column = startColumn; column < endColumn; column++) {\n                res.set(row - startRow, column - startColumn, this.get(row, column));\n            }\n        }\n        return res;\n    };\n    Matrix.prototype.map = function (func) {\n        for (var i = 0; i < this.getNumberOfRows(); i++) {\n            for (var j = 0; j < this.getNumberOfColumns(); j++) {\n                this.data[i][j] = func(this.data[i][j], i, j);\n            }\n        }\n        return this;\n    };\n    Matrix.prototype.forEach = function (func) {\n        for (var i = 0; i < this.getNumberOfRows(); i++) {\n            for (var j = 0; j < this.getNumberOfColumns(); j++) {\n                func(this.data[i][j], i, j);\n            }\n        }\n        return this;\n    };\n    Matrix.prototype.fill = function (newVal) {\n        return this.map(function (v) { return newVal; });\n    };\n    Matrix.prototype.scale = function (scl) {\n        return this.map(function (v) { return v * scl; });\n    };\n    Matrix.prototype.add = function (m) {\n        if (!this.hasSameDimensions(m))\n            this.error('size', 'addition');\n        return this.map(function (v, row, col) { return v + m.get(row, col); });\n    };\n    Matrix.prototype.subtract = function (m) {\n        if (!this.hasSameDimensions(m))\n            this.error('size', 'subtraction');\n        return this.map(function (v, row, col) { return v - m.get(row, col); });\n    };\n    Matrix.prototype.multiply = function (m) {\n        if (!this.hasSameDimensions(m))\n            this.error('size', 'multiplication');\n        return this.map(function (v, row, col) { return v * m.get(row, col); });\n    };\n    Matrix.prototype.divide = function (m) {\n        if (!this.hasSameDimensions(m))\n            this.error('size', 'division');\n        return this.map(function (v, row, col) { return v / m.get(row, col); });\n    };\n    Matrix.prototype.dot = function (m) {\n        if (!(this.getNumberOfColumns() == m.getNumberOfRows()))\n            this.error('size', 'dot product');\n        var newData = Matrix.get2DArray(this.getNumberOfRows(), m.getNumberOfColumns());\n        for (var v = 0; v < m.getNumberOfColumns(); v++) {\n            for (var r = 0; r < this.getNumberOfRows(); r++) {\n                for (var i = 0; i < m.getNumberOfRows(); i++) {\n                    newData[r][v] += m.get(i, v) * this.get(r, i);\n                }\n            }\n        }\n        this.data = newData;\n        return this;\n    };\n    Matrix.prototype.transpose = function () {\n        var newData = Matrix.get2DArray(this.getNumberOfColumns(), this.getNumberOfRows());\n        this.forEach(function (v, row, col) {\n            newData[col][row] = v;\n        });\n        this.data = newData;\n        return this;\n    };\n    Matrix.prototype.min = function () {\n        var minValues = [];\n        for (var c = 0; c < this.getNumberOfColumns(); c++) {\n            var column = this.getColumnAsRowVector(c).getArray()[0];\n            minValues.push(Math.min.apply(Math, column));\n        }\n        return Matrix.rowVector.apply(Matrix, minValues);\n    };\n    Matrix.prototype.max = function () {\n        var maxValues = [];\n        for (var c = 0; c < this.getNumberOfColumns(); c++) {\n            var column = this.getColumnAsRowVector(c).getArray()[0];\n            maxValues.push(Math.max.apply(Math, column));\n        }\n        return Matrix.rowVector.apply(Matrix, maxValues);\n    };\n    Matrix.prototype.hasSameDimensions = function (m) {\n        if (m.getNumberOfColumns() == this.getNumberOfColumns() && m.getNumberOfRows() == this.getNumberOfRows()) {\n            return true;\n        }\n        else {\n            return false;\n        }\n    };\n    Matrix.prototype.error = function (code, operation) {\n        switch (code) {\n            case 'size':\n                throw \"Matrices not not have the right sizes for operation \" + operation;\n            default:\n                throw \"Error!\";\n        }\n    };\n    Matrix.prototype.show = function () {\n        console.log(this.getAsString());\n        return this;\n    };\n    Matrix.prototype.getAsString = function (markup, joinChar, lineSpaceChar, end, fixed) {\n        var _this = this;\n        if (markup === void 0) { markup = true; }\n        if (joinChar === void 0) { joinChar = '\\t'; }\n        if (lineSpaceChar === void 0) { lineSpaceChar = ' '; }\n        if (end === void 0) { end = '\\n'; }\n        if (fixed === void 0) { fixed = 3; }\n        if (!markup) {\n            return this.data.map(function (r) { return r.map(function (n) { return n.toFixed(fixed); }).join('\\t'); }).join('\\n') + end;\n        }\n        else {\n            return this.data.map(function (r, i) {\n                var middlePart = r.map(function (n) { return n.toFixed(fixed); }).join(joinChar);\n                if (i == 0 && _this.data.length == 1) {\n                    return \"[\" + lineSpaceChar + middlePart + lineSpaceChar + \"]\";\n                }\n                else if (i == 0) {\n                    return \"\\u23A1\" + lineSpaceChar + middlePart + lineSpaceChar + \"\\u23A4\";\n                }\n                else if (i == _this.data.length - 1) {\n                    return \"\\u23A3\" + lineSpaceChar + middlePart + lineSpaceChar + \"\\u23A6\";\n                }\n                else {\n                    return \"\\u239C\" + lineSpaceChar + middlePart + lineSpaceChar + \"\\u239F\";\n                }\n            }).join('\\n') + end;\n        }\n    };\n    return Matrix;\n}());\nexports.Matrix = Matrix;\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTIuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvbWF0cml4LnRzP2RjODQiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgTWF0cml4ID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBNYXRyaXgocDEsIHAyKSB7XG4gICAgICAgIGlmICh0eXBlb2YgcDEgPT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgIHRoaXMuZGF0YSA9IHAxO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5kYXRhID0gTWF0cml4LmdldDJEQXJyYXkocDEsIHAyKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBNYXRyaXguZ2V0MkRBcnJheSA9IGZ1bmN0aW9uIChtLCBuLCBmaWxsKSB7XG4gICAgICAgIGlmIChmaWxsID09PSB2b2lkIDApIHsgZmlsbCA9IDA7IH1cbiAgICAgICAgcmV0dXJuIG5ldyBBcnJheShtKS5maWxsKDApLm1hcChmdW5jdGlvbiAocikgeyByZXR1cm4gbmV3IEFycmF5KG4pLmZpbGwoZmlsbCk7IH0pO1xuICAgIH07XG4gICAgTWF0cml4LnJvd1ZlY3RvciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGNvbXBvbmVudHMgPSBbXTtcbiAgICAgICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IGFyZ3VtZW50cy5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICAgIGNvbXBvbmVudHNbX2ldID0gYXJndW1lbnRzW19pXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IE1hdHJpeChbY29tcG9uZW50c10pO1xuICAgIH07XG4gICAgTWF0cml4LmNvbHVtblZlY3RvciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGNvbXBvbmVudHMgPSBbXTtcbiAgICAgICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IGFyZ3VtZW50cy5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICAgIGNvbXBvbmVudHNbX2ldID0gYXJndW1lbnRzW19pXTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgdiA9IGNvbXBvbmVudHMubWFwKGZ1bmN0aW9uIChjKSB7IHJldHVybiBbY107IH0pO1xuICAgICAgICByZXR1cm4gbmV3IE1hdHJpeCh2KTtcbiAgICB9O1xuICAgIE1hdHJpeC5yYW5kID0gZnVuY3Rpb24gKHJvd3MsIGNvbHVtbnMpIHtcbiAgICAgICAgdmFyIG0gPSBuZXcgTWF0cml4KHJvd3MsIGNvbHVtbnMpO1xuICAgICAgICBtLm1hcChmdW5jdGlvbiAodikgeyByZXR1cm4gTWF0aC5yYW5kb20oKTsgfSk7XG4gICAgICAgIHJldHVybiBtO1xuICAgIH07XG4gICAgTWF0cml4Lm9uZXMgPSBmdW5jdGlvbiAocm93cywgY29sdW1ucykge1xuICAgICAgICB2YXIgbSA9IG5ldyBNYXRyaXgocm93cywgY29sdW1ucyk7XG4gICAgICAgIG0uZmlsbCgxKTtcbiAgICAgICAgcmV0dXJuIG07XG4gICAgfTtcbiAgICBNYXRyaXguZXllID0gZnVuY3Rpb24gKHNpemUpIHtcbiAgICAgICAgdmFyIG0gPSBuZXcgTWF0cml4KHNpemUsIHNpemUpO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHNpemU7IGkrKylcbiAgICAgICAgICAgIG0uc2V0KGksIGksIDEpO1xuICAgICAgICByZXR1cm4gbTtcbiAgICB9O1xuICAgIE1hdHJpeC5qb2luID0gZnVuY3Rpb24gKG0xLCBtMiwgcG9zKSB7XG4gICAgICAgIGlmIChwb3MgPT09IHZvaWQgMCkgeyBwb3MgPSAnYm90dG9tJzsgfVxuICAgICAgICB2YXIgbmV3RGF0YTtcbiAgICAgICAgc3dpdGNoIChwb3MpIHtcbiAgICAgICAgICAgIGNhc2UgJ3RvcCc6XG4gICAgICAgICAgICAgICAgbmV3RGF0YSA9IG0yLmRhdGEuY29uY2F0KG0xLmRhdGEpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnYm90dG9tJzpcbiAgICAgICAgICAgICAgICBuZXdEYXRhID0gbTEuZGF0YS5jb25jYXQobTIuZGF0YSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdsZWZ0JzpcbiAgICAgICAgICAgICAgICBuZXdEYXRhID0gbTEuZGF0YS5tYXAoZnVuY3Rpb24gKHIsIGkpIHsgcmV0dXJuIG0yLmRhdGFbaV0uY29uY2F0KHIpOyB9KTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ3JpZ2h0JzpcbiAgICAgICAgICAgICAgICBuZXdEYXRhID0gbTEuZGF0YS5tYXAoZnVuY3Rpb24gKHIsIGkpIHsgcmV0dXJuIHIuY29uY2F0KG0yLmRhdGFbaV0pOyB9KTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBNYXRyaXgobmV3RGF0YSk7XG4gICAgfTtcbiAgICBNYXRyaXgucHJvdG90eXBlLnNpemUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBbdGhpcy5nZXROdW1iZXJPZlJvd3MoKSwgdGhpcy5nZXROdW1iZXJPZkNvbHVtbnMoKV07XG4gICAgfTtcbiAgICBNYXRyaXgucHJvdG90eXBlLmdldE51bWJlck9mUm93cyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZGF0YS5sZW5ndGg7XG4gICAgfTtcbiAgICBNYXRyaXgucHJvdG90eXBlLmdldE51bWJlck9mQ29sdW1ucyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZGF0YVswXS5sZW5ndGg7XG4gICAgfTtcbiAgICBNYXRyaXgucHJvdG90eXBlLmdldERpbWVuc2lvbnMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBbdGhpcy5nZXROdW1iZXJPZlJvd3MoKSwgdGhpcy5nZXROdW1iZXJPZkNvbHVtbnMoKV07XG4gICAgfTtcbiAgICBNYXRyaXgucHJvdG90eXBlLnNldCA9IGZ1bmN0aW9uIChyb3csIGNvbHVtbiwgdmFsKSB7XG4gICAgICAgIHRoaXMuZGF0YVtyb3ddW2NvbHVtbl0gPSB2YWw7XG4gICAgfTtcbiAgICBNYXRyaXgucHJvdG90eXBlLmdldCA9IGZ1bmN0aW9uIChyb3csIGNvbHVtbikge1xuICAgICAgICByZXR1cm4gdGhpcy5kYXRhW3Jvd11bY29sdW1uXTtcbiAgICB9O1xuICAgIE1hdHJpeC5wcm90b3R5cGUuZ2V0Um93QXNSb3dWZWN0b3IgPSBmdW5jdGlvbiAocm93KSB7XG4gICAgICAgIC8vIENvcHkgd2l0aG91dCByZWZlcmVuY2VcbiAgICAgICAgdmFyIHYgPSBuZXcgTWF0cml4KFt0aGlzLmRhdGFbcm93XS5zbGljZSgpXSk7XG4gICAgICAgIHJldHVybiB2O1xuICAgIH07XG4gICAgTWF0cml4LnByb3RvdHlwZS5nZXRDb2x1bW5Bc1Jvd1ZlY3RvciA9IGZ1bmN0aW9uIChjb2x1bW4pIHtcbiAgICAgICAgLy8gQ29weSB3aXRob3V0IHJlZmVyZW5jZVxuICAgICAgICB2YXIgdiA9IFtdO1xuICAgICAgICBmb3IgKHZhciBfaSA9IDAsIF9hID0gdGhpcy5kYXRhOyBfaSA8IF9hLmxlbmd0aDsgX2krKykge1xuICAgICAgICAgICAgdmFyIHJvdyA9IF9hW19pXTtcbiAgICAgICAgICAgIHYucHVzaChyb3dbY29sdW1uXSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBNYXRyaXgoW3ZdKTtcbiAgICB9O1xuICAgIE1hdHJpeC5wcm90b3R5cGUuZ2V0QXNTY2FsYXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0aGlzLmdldERpbWVuc2lvbnMoKS5ldmVyeShmdW5jdGlvbiAoZCkgeyByZXR1cm4gZCA9PSAxOyB9KSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZ2V0KDAsIDApO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5lcnJvcignc2l6ZScsICdnZXRBc0Zsb2F0IChtYXRyaXggbXVzdCBiZSAxeDEpJyk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIE1hdHJpeC5wcm90b3R5cGUuZ2V0QXJyYXkgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIC8vIERlZXAgY29weSB3aXRob3V0IHJlZmVyZW5jZVxuICAgICAgICByZXR1cm4gdGhpcy5kYXRhLm1hcChmdW5jdGlvbiAocikgeyByZXR1cm4gci5zbGljZSgpOyB9KTtcbiAgICB9O1xuICAgIE1hdHJpeC5wcm90b3R5cGUuY29weSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBNYXRyaXgodGhpcy5nZXRBcnJheSgpKTtcbiAgICB9O1xuICAgIC8vIGVuZFJvdyBhbmQgZW5kQ29sdW1uIGV4Y2x1c2l2ZSBpZiBwb3NpdGl2ZVxuICAgIC8vIHN0YXJ0Um93IGFuZCBzdGFydENvbHVtbiBleGNsdXNpdmUgaWYgbmVnYXRpdmVcbiAgICBNYXRyaXgucHJvdG90eXBlLnNsaWNlID0gZnVuY3Rpb24gKHN0YXJ0Um93LCBlbmRSb3csIHN0YXJ0Q29sdW1uLCBlbmRDb2x1bW4pIHtcbiAgICAgICAgLy9IYW5kbGUgbmVnYXRpdmVzXG4gICAgICAgIGlmIChlbmRSb3cgPCAwKSB7XG4gICAgICAgICAgICBlbmRSb3cgPSB0aGlzLmdldE51bWJlck9mUm93cygpICsgKGVuZFJvdyArIDEpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzdGFydFJvdyA8IDApIHtcbiAgICAgICAgICAgIHN0YXJ0Um93ID0gdGhpcy5nZXROdW1iZXJPZlJvd3MoKSArIChzdGFydFJvdyArIDEpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChlbmRDb2x1bW4gPCAwKSB7XG4gICAgICAgICAgICBlbmRDb2x1bW4gPSB0aGlzLmdldE51bWJlck9mQ29sdW1ucygpICsgKGVuZENvbHVtbiArIDEpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzdGFydENvbHVtbiA8IDApIHtcbiAgICAgICAgICAgIHN0YXJ0Q29sdW1uID0gdGhpcy5nZXROdW1iZXJPZkNvbHVtbnMoKSArIChzdGFydENvbHVtbiArIDEpO1xuICAgICAgICB9XG4gICAgICAgIHZhciByZXMgPSBuZXcgTWF0cml4KGVuZFJvdyAtIHN0YXJ0Um93LCBlbmRDb2x1bW4gLSBzdGFydENvbHVtbik7XG4gICAgICAgIGZvciAodmFyIHJvdyA9IHN0YXJ0Um93OyByb3cgPCBlbmRSb3c7IHJvdysrKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBjb2x1bW4gPSBzdGFydENvbHVtbjsgY29sdW1uIDwgZW5kQ29sdW1uOyBjb2x1bW4rKykge1xuICAgICAgICAgICAgICAgIHJlcy5zZXQocm93IC0gc3RhcnRSb3csIGNvbHVtbiAtIHN0YXJ0Q29sdW1uLCB0aGlzLmdldChyb3csIGNvbHVtbikpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXM7XG4gICAgfTtcbiAgICBNYXRyaXgucHJvdG90eXBlLm1hcCA9IGZ1bmN0aW9uIChmdW5jKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5nZXROdW1iZXJPZlJvd3MoKTsgaSsrKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IHRoaXMuZ2V0TnVtYmVyT2ZDb2x1bW5zKCk7IGorKykge1xuICAgICAgICAgICAgICAgIHRoaXMuZGF0YVtpXVtqXSA9IGZ1bmModGhpcy5kYXRhW2ldW2pdLCBpLCBqKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuICAgIE1hdHJpeC5wcm90b3R5cGUuZm9yRWFjaCA9IGZ1bmN0aW9uIChmdW5jKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5nZXROdW1iZXJPZlJvd3MoKTsgaSsrKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IHRoaXMuZ2V0TnVtYmVyT2ZDb2x1bW5zKCk7IGorKykge1xuICAgICAgICAgICAgICAgIGZ1bmModGhpcy5kYXRhW2ldW2pdLCBpLCBqKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuICAgIE1hdHJpeC5wcm90b3R5cGUuZmlsbCA9IGZ1bmN0aW9uIChuZXdWYWwpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubWFwKGZ1bmN0aW9uICh2KSB7IHJldHVybiBuZXdWYWw7IH0pO1xuICAgIH07XG4gICAgTWF0cml4LnByb3RvdHlwZS5zY2FsZSA9IGZ1bmN0aW9uIChzY2wpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubWFwKGZ1bmN0aW9uICh2KSB7IHJldHVybiB2ICogc2NsOyB9KTtcbiAgICB9O1xuICAgIE1hdHJpeC5wcm90b3R5cGUuYWRkID0gZnVuY3Rpb24gKG0pIHtcbiAgICAgICAgaWYgKCF0aGlzLmhhc1NhbWVEaW1lbnNpb25zKG0pKVxuICAgICAgICAgICAgdGhpcy5lcnJvcignc2l6ZScsICdhZGRpdGlvbicpO1xuICAgICAgICByZXR1cm4gdGhpcy5tYXAoZnVuY3Rpb24gKHYsIHJvdywgY29sKSB7IHJldHVybiB2ICsgbS5nZXQocm93LCBjb2wpOyB9KTtcbiAgICB9O1xuICAgIE1hdHJpeC5wcm90b3R5cGUuc3VidHJhY3QgPSBmdW5jdGlvbiAobSkge1xuICAgICAgICBpZiAoIXRoaXMuaGFzU2FtZURpbWVuc2lvbnMobSkpXG4gICAgICAgICAgICB0aGlzLmVycm9yKCdzaXplJywgJ3N1YnRyYWN0aW9uJyk7XG4gICAgICAgIHJldHVybiB0aGlzLm1hcChmdW5jdGlvbiAodiwgcm93LCBjb2wpIHsgcmV0dXJuIHYgLSBtLmdldChyb3csIGNvbCk7IH0pO1xuICAgIH07XG4gICAgTWF0cml4LnByb3RvdHlwZS5tdWx0aXBseSA9IGZ1bmN0aW9uIChtKSB7XG4gICAgICAgIGlmICghdGhpcy5oYXNTYW1lRGltZW5zaW9ucyhtKSlcbiAgICAgICAgICAgIHRoaXMuZXJyb3IoJ3NpemUnLCAnbXVsdGlwbGljYXRpb24nKTtcbiAgICAgICAgcmV0dXJuIHRoaXMubWFwKGZ1bmN0aW9uICh2LCByb3csIGNvbCkgeyByZXR1cm4gdiAqIG0uZ2V0KHJvdywgY29sKTsgfSk7XG4gICAgfTtcbiAgICBNYXRyaXgucHJvdG90eXBlLmRpdmlkZSA9IGZ1bmN0aW9uIChtKSB7XG4gICAgICAgIGlmICghdGhpcy5oYXNTYW1lRGltZW5zaW9ucyhtKSlcbiAgICAgICAgICAgIHRoaXMuZXJyb3IoJ3NpemUnLCAnZGl2aXNpb24nKTtcbiAgICAgICAgcmV0dXJuIHRoaXMubWFwKGZ1bmN0aW9uICh2LCByb3csIGNvbCkgeyByZXR1cm4gdiAvIG0uZ2V0KHJvdywgY29sKTsgfSk7XG4gICAgfTtcbiAgICBNYXRyaXgucHJvdG90eXBlLmRvdCA9IGZ1bmN0aW9uIChtKSB7XG4gICAgICAgIGlmICghKHRoaXMuZ2V0TnVtYmVyT2ZDb2x1bW5zKCkgPT0gbS5nZXROdW1iZXJPZlJvd3MoKSkpXG4gICAgICAgICAgICB0aGlzLmVycm9yKCdzaXplJywgJ2RvdCBwcm9kdWN0Jyk7XG4gICAgICAgIHZhciBuZXdEYXRhID0gTWF0cml4LmdldDJEQXJyYXkodGhpcy5nZXROdW1iZXJPZlJvd3MoKSwgbS5nZXROdW1iZXJPZkNvbHVtbnMoKSk7XG4gICAgICAgIGZvciAodmFyIHYgPSAwOyB2IDwgbS5nZXROdW1iZXJPZkNvbHVtbnMoKTsgdisrKSB7XG4gICAgICAgICAgICBmb3IgKHZhciByID0gMDsgciA8IHRoaXMuZ2V0TnVtYmVyT2ZSb3dzKCk7IHIrKykge1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbS5nZXROdW1iZXJPZlJvd3MoKTsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIG5ld0RhdGFbcl1bdl0gKz0gbS5nZXQoaSwgdikgKiB0aGlzLmdldChyLCBpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5kYXRhID0gbmV3RGF0YTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcbiAgICBNYXRyaXgucHJvdG90eXBlLnRyYW5zcG9zZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIG5ld0RhdGEgPSBNYXRyaXguZ2V0MkRBcnJheSh0aGlzLmdldE51bWJlck9mQ29sdW1ucygpLCB0aGlzLmdldE51bWJlck9mUm93cygpKTtcbiAgICAgICAgdGhpcy5mb3JFYWNoKGZ1bmN0aW9uICh2LCByb3csIGNvbCkge1xuICAgICAgICAgICAgbmV3RGF0YVtjb2xdW3Jvd10gPSB2O1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5kYXRhID0gbmV3RGF0YTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcbiAgICBNYXRyaXgucHJvdG90eXBlLm1pbiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIG1pblZhbHVlcyA9IFtdO1xuICAgICAgICBmb3IgKHZhciBjID0gMDsgYyA8IHRoaXMuZ2V0TnVtYmVyT2ZDb2x1bW5zKCk7IGMrKykge1xuICAgICAgICAgICAgdmFyIGNvbHVtbiA9IHRoaXMuZ2V0Q29sdW1uQXNSb3dWZWN0b3IoYykuZ2V0QXJyYXkoKVswXTtcbiAgICAgICAgICAgIG1pblZhbHVlcy5wdXNoKE1hdGgubWluLmFwcGx5KE1hdGgsIGNvbHVtbikpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBNYXRyaXgucm93VmVjdG9yLmFwcGx5KE1hdHJpeCwgbWluVmFsdWVzKTtcbiAgICB9O1xuICAgIE1hdHJpeC5wcm90b3R5cGUubWF4ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgbWF4VmFsdWVzID0gW107XG4gICAgICAgIGZvciAodmFyIGMgPSAwOyBjIDwgdGhpcy5nZXROdW1iZXJPZkNvbHVtbnMoKTsgYysrKSB7XG4gICAgICAgICAgICB2YXIgY29sdW1uID0gdGhpcy5nZXRDb2x1bW5Bc1Jvd1ZlY3RvcihjKS5nZXRBcnJheSgpWzBdO1xuICAgICAgICAgICAgbWF4VmFsdWVzLnB1c2goTWF0aC5tYXguYXBwbHkoTWF0aCwgY29sdW1uKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIE1hdHJpeC5yb3dWZWN0b3IuYXBwbHkoTWF0cml4LCBtYXhWYWx1ZXMpO1xuICAgIH07XG4gICAgTWF0cml4LnByb3RvdHlwZS5oYXNTYW1lRGltZW5zaW9ucyA9IGZ1bmN0aW9uIChtKSB7XG4gICAgICAgIGlmIChtLmdldE51bWJlck9mQ29sdW1ucygpID09IHRoaXMuZ2V0TnVtYmVyT2ZDb2x1bW5zKCkgJiYgbS5nZXROdW1iZXJPZlJvd3MoKSA9PSB0aGlzLmdldE51bWJlck9mUm93cygpKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgTWF0cml4LnByb3RvdHlwZS5lcnJvciA9IGZ1bmN0aW9uIChjb2RlLCBvcGVyYXRpb24pIHtcbiAgICAgICAgc3dpdGNoIChjb2RlKSB7XG4gICAgICAgICAgICBjYXNlICdzaXplJzpcbiAgICAgICAgICAgICAgICB0aHJvdyBcIk1hdHJpY2VzIG5vdCBub3QgaGF2ZSB0aGUgcmlnaHQgc2l6ZXMgZm9yIG9wZXJhdGlvbiBcIiArIG9wZXJhdGlvbjtcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgdGhyb3cgXCJFcnJvciFcIjtcbiAgICAgICAgfVxuICAgIH07XG4gICAgTWF0cml4LnByb3RvdHlwZS5zaG93ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBjb25zb2xlLmxvZyh0aGlzLmdldEFzU3RyaW5nKCkpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuICAgIE1hdHJpeC5wcm90b3R5cGUuZ2V0QXNTdHJpbmcgPSBmdW5jdGlvbiAobWFya3VwLCBqb2luQ2hhciwgbGluZVNwYWNlQ2hhciwgZW5kLCBmaXhlZCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICBpZiAobWFya3VwID09PSB2b2lkIDApIHsgbWFya3VwID0gdHJ1ZTsgfVxuICAgICAgICBpZiAoam9pbkNoYXIgPT09IHZvaWQgMCkgeyBqb2luQ2hhciA9ICdcXHQnOyB9XG4gICAgICAgIGlmIChsaW5lU3BhY2VDaGFyID09PSB2b2lkIDApIHsgbGluZVNwYWNlQ2hhciA9ICcgJzsgfVxuICAgICAgICBpZiAoZW5kID09PSB2b2lkIDApIHsgZW5kID0gJ1xcbic7IH1cbiAgICAgICAgaWYgKGZpeGVkID09PSB2b2lkIDApIHsgZml4ZWQgPSAzOyB9XG4gICAgICAgIGlmICghbWFya3VwKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5kYXRhLm1hcChmdW5jdGlvbiAocikgeyByZXR1cm4gci5tYXAoZnVuY3Rpb24gKG4pIHsgcmV0dXJuIG4udG9GaXhlZChmaXhlZCk7IH0pLmpvaW4oJ1xcdCcpOyB9KS5qb2luKCdcXG4nKSArIGVuZDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmRhdGEubWFwKGZ1bmN0aW9uIChyLCBpKSB7XG4gICAgICAgICAgICAgICAgdmFyIG1pZGRsZVBhcnQgPSByLm1hcChmdW5jdGlvbiAobikgeyByZXR1cm4gbi50b0ZpeGVkKGZpeGVkKTsgfSkuam9pbihqb2luQ2hhcik7XG4gICAgICAgICAgICAgICAgaWYgKGkgPT0gMCAmJiBfdGhpcy5kYXRhLmxlbmd0aCA9PSAxKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBcIltcIiArIGxpbmVTcGFjZUNoYXIgKyBtaWRkbGVQYXJ0ICsgbGluZVNwYWNlQ2hhciArIFwiXVwiO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChpID09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFwiXFx1MjNBMVwiICsgbGluZVNwYWNlQ2hhciArIG1pZGRsZVBhcnQgKyBsaW5lU3BhY2VDaGFyICsgXCJcXHUyM0E0XCI7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGkgPT0gX3RoaXMuZGF0YS5sZW5ndGggLSAxKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBcIlxcdTIzQTNcIiArIGxpbmVTcGFjZUNoYXIgKyBtaWRkbGVQYXJ0ICsgbGluZVNwYWNlQ2hhciArIFwiXFx1MjNBNlwiO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFwiXFx1MjM5Q1wiICsgbGluZVNwYWNlQ2hhciArIG1pZGRsZVBhcnQgKyBsaW5lU3BhY2VDaGFyICsgXCJcXHUyMzlGXCI7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSkuam9pbignXFxuJykgKyBlbmQ7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHJldHVybiBNYXRyaXg7XG59KCkpO1xuZXhwb3J0cy5NYXRyaXggPSBNYXRyaXg7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL3NyYy9tYXRyaXgudHNcbi8vIG1vZHVsZSBpZCA9IDEyXG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTsiLCJzb3VyY2VSb290IjoiIn0=");

/***/ }),
/* 13 */
/* unknown exports provided */
/* all exports used */
/*!***********************************!*\
  !*** ./src/NeuralNetworks/ann.ts ***!
  \***********************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar FeedForward;\n(function (FeedForward) {\n    var Layer = (function () {\n        function Layer(options) {\n            this.options = options;\n            // neurons[0] → Bias Unit\n            this.neurons = [];\n            // +1 for one bias unit\n            for (var n = 0; n < options.numberOfNeurons + 1; n++) {\n                this.neurons.push(new Neuron({\n                    index: n,\n                    isBiasUnit: n == options.numberOfNeurons,\n                    netOptions: options.netOptions,\n                    numberOfNeuronsInNextLayer: options.numberOfNeuronsInNextLayer\n                }));\n            }\n        }\n        Layer.prototype.forEachNeuron = function (func, excludeBias) {\n            if (excludeBias === void 0) { excludeBias = false; }\n            for (var i = 0; i < this.neurons.length - (excludeBias ? 1 : 0); i++) {\n                var neuron = this.neurons[i];\n                // Bias units are the last ones\n                func(neuron, neuron.getIndex());\n            }\n        };\n        return Layer;\n    }());\n    var Neuron = (function () {\n        // Bias units are the last ones in array\n        function Neuron(options) {\n            this.options = options;\n            this.weights = [];\n            this.prevDelta = 0;\n            if (this.isBias())\n                this.output = 1;\n            // Generate weights\n            for (var n = 0; n < options.numberOfNeuronsInNextLayer; n++) {\n                this.weights.push(new Weight());\n            }\n            // set shorthand for activation function\n            this.activationFunction = this.options.netOptions.activationFunction;\n        }\n        /**\n         * Forward pass of values through the neuron using the prevLayer\n         * @param prevLayer i\n         */\n        Neuron.prototype.propagateForward = function (prevLayer) {\n            var _this = this;\n            if (this.isBias()) {\n                throw 'A bias unit should not propagate a value forward.';\n            }\n            var sigma = 0;\n            prevLayer.forEachNeuron(function (n) {\n                sigma += n.output * n.getWeightTo(_this).value;\n            });\n            this.input = sigma;\n            this.output = this.activationFunction.output(this.input);\n        };\n        /**\n         * Calculates the delta of an output neuron using the derivative term of the specified error function of the network and the target value\n         * @param target target value for this output neuron\n         */\n        Neuron.prototype.calculateOutputLayerDelta = function (target) {\n            if (this.isBias())\n                throw 'There should not be an output layer delta calculation for a bias unit for it is never used.';\n            this.prevDelta = this.delta || 0;\n            this.delta = this.options.netOptions.errorFunction.der(this.output, target) * this.activationFunction.der(this.input);\n        };\n        /**\n         * Calculates the delta values for neurons in a hidden layer j using the next layer k\n         * @param nextLayer k\n         */\n        Neuron.prototype.calculateHiddenLayerDelta = function (nextLayer) {\n            var _this = this;\n            if (this.isBias())\n                throw 'There should not be an hidden layer delta calculation for a bias unit for it is not connected to the previous layer.';\n            var sigma = 0;\n            nextLayer.forEachNeuron(function (n, i) {\n                sigma += n.delta * _this.weights[i].value;\n            }, true);\n            this.prevDelta = this.delta || 0;\n            this.delta = this.activationFunction.der(this.input) * sigma;\n        };\n        /**\n         * Updates the weights which connect the previous layer to the current one using this layer neurons delta values and the output of the previous layer neurons\n         * @param prevLayer the previous layer i\n         */\n        Neuron.prototype.updateWeights = function (prevLayer) {\n            var _this = this;\n            prevLayer.forEachNeuron(function (n, i) {\n                var oldWeight = n.weights[_this.getIndex()];\n                var derivativeTerm = n.output * _this.delta;\n                var momentumTerm = _this.options.netOptions.momentum * _this.prevDelta;\n                oldWeight.value -= _this.options.netOptions.learningRate * derivativeTerm + momentumTerm;\n            });\n        };\n        ;\n        /**\n         * Get the weight to a neuron in the next layer k from current layer k\n         * Weights to layer k are stored in neurons of layer j\n         * @param n Neuron in next layer k\n         */\n        Neuron.prototype.getWeightTo = function (n) {\n            return this.weights[n.getIndex()];\n        };\n        /**\n         * @returns true if the neuron is a bias unit which means it has a constant output of 1\n         * Info: Bias units are the last ones in the neurons array in each layer object\n         */\n        Neuron.prototype.isBias = function () {\n            return this.options.isBiasUnit;\n        };\n        /**\n         * @returns the index of the current neuron in its layer ranging from 1 to number of specified neurons in layer + 1 because an extra bias neuron is added at the end of neurons array in a layer object.\n         */\n        Neuron.prototype.getIndex = function () {\n            return this.options.index;\n        };\n        return Neuron;\n    }());\n    var Weight = (function () {\n        function Weight(value) {\n            if (value === void 0) { value = Math.random(); }\n            this.value = value;\n        }\n        return Weight;\n    }());\n    var Network = (function () {\n        function Network(options) {\n            this.options = options;\n            this.layers = [];\n            // Create net's layers\n            for (var l = 0; l < options.layers.length; l++) {\n                this.layers.push(new Layer({\n                    netOptions: options,\n                    numberOfNeurons: options.layers[l],\n                    numberOfNeuronsInNextLayer: options.layers[l + 1] || 0\n                }));\n            }\n        }\n        /**\n         * Creates new network with specified weights\n         * @param weightData previously saved weights (using Network.exportWeights)\n         * @param options network options\n         */\n        Network.restore = function (weightData, options) {\n            var ann = new Network(options);\n            for (var l = 0; l < weightData.length; l++) {\n                for (var n = 0; n < weightData[l].length; n++) {\n                    for (var w = 0; w < weightData[l][n].length; w++) {\n                        ann.layers[l].neurons[n].weights[w].value = weightData[l][n][w];\n                    }\n                }\n            }\n            return ann;\n        };\n        Object.defineProperty(Network.prototype, \"inputLayer\", {\n            /**\n             * @returns the input layer\n             */\n            get: function () {\n                return this.layers[0];\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(Network.prototype, \"outputLayer\", {\n            /**\n             * @returns the output layer\n             */\n            get: function () {\n                return this.layers[this.layers.length - 1];\n            },\n            enumerable: true,\n            configurable: true\n        });\n        /**\n         * Forward Pass of the network where values are propagated through the network\n         * @param inputs input values matching the specified size of the network's input layer\n         */\n        Network.prototype.propagateForward = function (inputs) {\n            if (inputs.length != this.inputLayer.neurons.length - 1) {\n                throw \"Inputs do not match network size!\";\n            }\n            // Set input layer neurons output to input values; exclude bias of course\n            this.inputLayer.forEachNeuron(function (n, i) { return n.output = inputs[i]; }, true);\n            var _loop_1 = function (l) {\n                var layer = this_1.layers[l];\n                var prevLayer = this_1.layers[l - 1];\n                layer.forEachNeuron(function (n) { return n.propagateForward(prevLayer); }, true);\n            };\n            var this_1 = this;\n            // propagate values forward through layer starting from first hidden layer\n            for (var l = 1; l < this.layers.length; l++) {\n                _loop_1(l);\n            }\n            return this;\n        };\n        /**\n         * @returns the current output of the network\n         */\n        Network.prototype.getCurrentOutput = function () {\n            return this.outputLayer.neurons.map(function (n) { return n.output; }).slice(0, -1);\n        };\n        /**\n         * Calculate all the neurons delta values\n         * @param targetValues target values for the network with respect to last forward pass\n         */\n        Network.prototype.calculateDeltas = function (targetValues) {\n            // calculate Output layer calculateDeltas\n            this.outputLayer.forEachNeuron(function (n, i) { return n.calculateOutputLayerDelta(targetValues[i]); }, true);\n            var _loop_2 = function (l) {\n                var layer = this_2.layers[l];\n                var nextLayer = this_2.layers[l + 1];\n                layer.forEachNeuron(function (n) { return n.calculateHiddenLayerDelta(nextLayer); }, true);\n            };\n            var this_2 = this;\n            // propagate error backwards through hidden layers\n            for (var l = this.layers.length - 2; l > 0; l--) {\n                _loop_2(l);\n            }\n            return this;\n        };\n        /**\n         * Update the connection weights using previous calculated delta values\n         */\n        Network.prototype.updateWeights = function () {\n            var _loop_3 = function (l) {\n                var layer = this_3.layers[l];\n                var prevLayer = this_3.layers[l - 1];\n                layer.forEachNeuron(function (n) { return n.updateWeights(prevLayer); }, true);\n            };\n            var this_3 = this;\n            // go through all layers except input layer and update all the weights with the calculated deltaValues.\n            for (var l = 1; l < this.layers.length; l++) {\n                _loop_3(l);\n            }\n            return this;\n        };\n        /**\n         * Fits given inputs to given target values by training the network\n         * @param inputs inputs to the network\n         * @param targetValues expected outputs for given input\n         */\n        Network.prototype.fit = function (inputs, targetValues) {\n            this.propagateForward(inputs).calculateDeltas(targetValues).updateWeights();\n            return this;\n        };\n        /**\n         * Predict output values for given inputs\n         * @param inputs input values\n         */\n        Network.prototype.predict = function (inputs) {\n            return this.propagateForward(inputs).getCurrentOutput();\n        };\n        /**\n         * Calculate the error for current outputs (not forward pass)\n         * @param targetValues target values\n         */\n        Network.prototype.getCurrentError = function (targetValues) {\n            var _this = this;\n            return this.getCurrentOutput().reduce(function (s, o, i) {\n                return s + _this.options.errorFunction.error(o, targetValues[i]);\n            }, 0);\n        };\n        /**\n         * Calculates the error for given inputs\n         * @param inputs inputs to network\n         * @param targetValues expected output for given inputs\n         */\n        Network.prototype.error = function (inputs, targetValues) {\n            this.propagateForward(inputs);\n            return this.getCurrentError(targetValues);\n        };\n        /**\n         * Export the current weights of the network\n         */\n        Network.prototype.exportWeights = function () {\n            var data = [];\n            for (var l = 0; l < this.layers.length - 1; l++) {\n                var layer = this.layers[l];\n                var layerData = layer.neurons.map(function (n) { return n.weights.map(function (w) { return w.value; }); });\n                data.push(layerData);\n            }\n            return data;\n        };\n        return Network;\n    }());\n    FeedForward.Network = Network;\n})(FeedForward = exports.FeedForward || (exports.FeedForward = {}));\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvTmV1cmFsTmV0d29ya3MvYW5uLnRzPzNmMzYiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgRmVlZEZvcndhcmQ7XG4oZnVuY3Rpb24gKEZlZWRGb3J3YXJkKSB7XG4gICAgdmFyIExheWVyID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZnVuY3Rpb24gTGF5ZXIob3B0aW9ucykge1xuICAgICAgICAgICAgdGhpcy5vcHRpb25zID0gb3B0aW9ucztcbiAgICAgICAgICAgIC8vIG5ldXJvbnNbMF0g4oaSIEJpYXMgVW5pdFxuICAgICAgICAgICAgdGhpcy5uZXVyb25zID0gW107XG4gICAgICAgICAgICAvLyArMSBmb3Igb25lIGJpYXMgdW5pdFxuICAgICAgICAgICAgZm9yICh2YXIgbiA9IDA7IG4gPCBvcHRpb25zLm51bWJlck9mTmV1cm9ucyArIDE7IG4rKykge1xuICAgICAgICAgICAgICAgIHRoaXMubmV1cm9ucy5wdXNoKG5ldyBOZXVyb24oe1xuICAgICAgICAgICAgICAgICAgICBpbmRleDogbixcbiAgICAgICAgICAgICAgICAgICAgaXNCaWFzVW5pdDogbiA9PSBvcHRpb25zLm51bWJlck9mTmV1cm9ucyxcbiAgICAgICAgICAgICAgICAgICAgbmV0T3B0aW9uczogb3B0aW9ucy5uZXRPcHRpb25zLFxuICAgICAgICAgICAgICAgICAgICBudW1iZXJPZk5ldXJvbnNJbk5leHRMYXllcjogb3B0aW9ucy5udW1iZXJPZk5ldXJvbnNJbk5leHRMYXllclxuICAgICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBMYXllci5wcm90b3R5cGUuZm9yRWFjaE5ldXJvbiA9IGZ1bmN0aW9uIChmdW5jLCBleGNsdWRlQmlhcykge1xuICAgICAgICAgICAgaWYgKGV4Y2x1ZGVCaWFzID09PSB2b2lkIDApIHsgZXhjbHVkZUJpYXMgPSBmYWxzZTsgfVxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLm5ldXJvbnMubGVuZ3RoIC0gKGV4Y2x1ZGVCaWFzID8gMSA6IDApOyBpKyspIHtcbiAgICAgICAgICAgICAgICB2YXIgbmV1cm9uID0gdGhpcy5uZXVyb25zW2ldO1xuICAgICAgICAgICAgICAgIC8vIEJpYXMgdW5pdHMgYXJlIHRoZSBsYXN0IG9uZXNcbiAgICAgICAgICAgICAgICBmdW5jKG5ldXJvbiwgbmV1cm9uLmdldEluZGV4KCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gTGF5ZXI7XG4gICAgfSgpKTtcbiAgICB2YXIgTmV1cm9uID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgLy8gQmlhcyB1bml0cyBhcmUgdGhlIGxhc3Qgb25lcyBpbiBhcnJheVxuICAgICAgICBmdW5jdGlvbiBOZXVyb24ob3B0aW9ucykge1xuICAgICAgICAgICAgdGhpcy5vcHRpb25zID0gb3B0aW9ucztcbiAgICAgICAgICAgIHRoaXMud2VpZ2h0cyA9IFtdO1xuICAgICAgICAgICAgdGhpcy5wcmV2RGVsdGEgPSAwO1xuICAgICAgICAgICAgaWYgKHRoaXMuaXNCaWFzKCkpXG4gICAgICAgICAgICAgICAgdGhpcy5vdXRwdXQgPSAxO1xuICAgICAgICAgICAgLy8gR2VuZXJhdGUgd2VpZ2h0c1xuICAgICAgICAgICAgZm9yICh2YXIgbiA9IDA7IG4gPCBvcHRpb25zLm51bWJlck9mTmV1cm9uc0luTmV4dExheWVyOyBuKyspIHtcbiAgICAgICAgICAgICAgICB0aGlzLndlaWdodHMucHVzaChuZXcgV2VpZ2h0KCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gc2V0IHNob3J0aGFuZCBmb3IgYWN0aXZhdGlvbiBmdW5jdGlvblxuICAgICAgICAgICAgdGhpcy5hY3RpdmF0aW9uRnVuY3Rpb24gPSB0aGlzLm9wdGlvbnMubmV0T3B0aW9ucy5hY3RpdmF0aW9uRnVuY3Rpb247XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEZvcndhcmQgcGFzcyBvZiB2YWx1ZXMgdGhyb3VnaCB0aGUgbmV1cm9uIHVzaW5nIHRoZSBwcmV2TGF5ZXJcbiAgICAgICAgICogQHBhcmFtIHByZXZMYXllciBpXG4gICAgICAgICAqL1xuICAgICAgICBOZXVyb24ucHJvdG90eXBlLnByb3BhZ2F0ZUZvcndhcmQgPSBmdW5jdGlvbiAocHJldkxheWVyKSB7XG4gICAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICAgICAgaWYgKHRoaXMuaXNCaWFzKCkpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyAnQSBiaWFzIHVuaXQgc2hvdWxkIG5vdCBwcm9wYWdhdGUgYSB2YWx1ZSBmb3J3YXJkLic7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgc2lnbWEgPSAwO1xuICAgICAgICAgICAgcHJldkxheWVyLmZvckVhY2hOZXVyb24oZnVuY3Rpb24gKG4pIHtcbiAgICAgICAgICAgICAgICBzaWdtYSArPSBuLm91dHB1dCAqIG4uZ2V0V2VpZ2h0VG8oX3RoaXMpLnZhbHVlO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB0aGlzLmlucHV0ID0gc2lnbWE7XG4gICAgICAgICAgICB0aGlzLm91dHB1dCA9IHRoaXMuYWN0aXZhdGlvbkZ1bmN0aW9uLm91dHB1dCh0aGlzLmlucHV0KTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIENhbGN1bGF0ZXMgdGhlIGRlbHRhIG9mIGFuIG91dHB1dCBuZXVyb24gdXNpbmcgdGhlIGRlcml2YXRpdmUgdGVybSBvZiB0aGUgc3BlY2lmaWVkIGVycm9yIGZ1bmN0aW9uIG9mIHRoZSBuZXR3b3JrIGFuZCB0aGUgdGFyZ2V0IHZhbHVlXG4gICAgICAgICAqIEBwYXJhbSB0YXJnZXQgdGFyZ2V0IHZhbHVlIGZvciB0aGlzIG91dHB1dCBuZXVyb25cbiAgICAgICAgICovXG4gICAgICAgIE5ldXJvbi5wcm90b3R5cGUuY2FsY3VsYXRlT3V0cHV0TGF5ZXJEZWx0YSA9IGZ1bmN0aW9uICh0YXJnZXQpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmlzQmlhcygpKVxuICAgICAgICAgICAgICAgIHRocm93ICdUaGVyZSBzaG91bGQgbm90IGJlIGFuIG91dHB1dCBsYXllciBkZWx0YSBjYWxjdWxhdGlvbiBmb3IgYSBiaWFzIHVuaXQgZm9yIGl0IGlzIG5ldmVyIHVzZWQuJztcbiAgICAgICAgICAgIHRoaXMucHJldkRlbHRhID0gdGhpcy5kZWx0YSB8fCAwO1xuICAgICAgICAgICAgdGhpcy5kZWx0YSA9IHRoaXMub3B0aW9ucy5uZXRPcHRpb25zLmVycm9yRnVuY3Rpb24uZGVyKHRoaXMub3V0cHV0LCB0YXJnZXQpICogdGhpcy5hY3RpdmF0aW9uRnVuY3Rpb24uZGVyKHRoaXMuaW5wdXQpO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogQ2FsY3VsYXRlcyB0aGUgZGVsdGEgdmFsdWVzIGZvciBuZXVyb25zIGluIGEgaGlkZGVuIGxheWVyIGogdXNpbmcgdGhlIG5leHQgbGF5ZXIga1xuICAgICAgICAgKiBAcGFyYW0gbmV4dExheWVyIGtcbiAgICAgICAgICovXG4gICAgICAgIE5ldXJvbi5wcm90b3R5cGUuY2FsY3VsYXRlSGlkZGVuTGF5ZXJEZWx0YSA9IGZ1bmN0aW9uIChuZXh0TGF5ZXIpIHtcbiAgICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgICAgICBpZiAodGhpcy5pc0JpYXMoKSlcbiAgICAgICAgICAgICAgICB0aHJvdyAnVGhlcmUgc2hvdWxkIG5vdCBiZSBhbiBoaWRkZW4gbGF5ZXIgZGVsdGEgY2FsY3VsYXRpb24gZm9yIGEgYmlhcyB1bml0IGZvciBpdCBpcyBub3QgY29ubmVjdGVkIHRvIHRoZSBwcmV2aW91cyBsYXllci4nO1xuICAgICAgICAgICAgdmFyIHNpZ21hID0gMDtcbiAgICAgICAgICAgIG5leHRMYXllci5mb3JFYWNoTmV1cm9uKGZ1bmN0aW9uIChuLCBpKSB7XG4gICAgICAgICAgICAgICAgc2lnbWEgKz0gbi5kZWx0YSAqIF90aGlzLndlaWdodHNbaV0udmFsdWU7XG4gICAgICAgICAgICB9LCB0cnVlKTtcbiAgICAgICAgICAgIHRoaXMucHJldkRlbHRhID0gdGhpcy5kZWx0YSB8fCAwO1xuICAgICAgICAgICAgdGhpcy5kZWx0YSA9IHRoaXMuYWN0aXZhdGlvbkZ1bmN0aW9uLmRlcih0aGlzLmlucHV0KSAqIHNpZ21hO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogVXBkYXRlcyB0aGUgd2VpZ2h0cyB3aGljaCBjb25uZWN0IHRoZSBwcmV2aW91cyBsYXllciB0byB0aGUgY3VycmVudCBvbmUgdXNpbmcgdGhpcyBsYXllciBuZXVyb25zIGRlbHRhIHZhbHVlcyBhbmQgdGhlIG91dHB1dCBvZiB0aGUgcHJldmlvdXMgbGF5ZXIgbmV1cm9uc1xuICAgICAgICAgKiBAcGFyYW0gcHJldkxheWVyIHRoZSBwcmV2aW91cyBsYXllciBpXG4gICAgICAgICAqL1xuICAgICAgICBOZXVyb24ucHJvdG90eXBlLnVwZGF0ZVdlaWdodHMgPSBmdW5jdGlvbiAocHJldkxheWVyKSB7XG4gICAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICAgICAgcHJldkxheWVyLmZvckVhY2hOZXVyb24oZnVuY3Rpb24gKG4sIGkpIHtcbiAgICAgICAgICAgICAgICB2YXIgb2xkV2VpZ2h0ID0gbi53ZWlnaHRzW190aGlzLmdldEluZGV4KCldO1xuICAgICAgICAgICAgICAgIHZhciBkZXJpdmF0aXZlVGVybSA9IG4ub3V0cHV0ICogX3RoaXMuZGVsdGE7XG4gICAgICAgICAgICAgICAgdmFyIG1vbWVudHVtVGVybSA9IF90aGlzLm9wdGlvbnMubmV0T3B0aW9ucy5tb21lbnR1bSAqIF90aGlzLnByZXZEZWx0YTtcbiAgICAgICAgICAgICAgICBvbGRXZWlnaHQudmFsdWUgLT0gX3RoaXMub3B0aW9ucy5uZXRPcHRpb25zLmxlYXJuaW5nUmF0ZSAqIGRlcml2YXRpdmVUZXJtICsgbW9tZW50dW1UZXJtO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH07XG4gICAgICAgIDtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEdldCB0aGUgd2VpZ2h0IHRvIGEgbmV1cm9uIGluIHRoZSBuZXh0IGxheWVyIGsgZnJvbSBjdXJyZW50IGxheWVyIGtcbiAgICAgICAgICogV2VpZ2h0cyB0byBsYXllciBrIGFyZSBzdG9yZWQgaW4gbmV1cm9ucyBvZiBsYXllciBqXG4gICAgICAgICAqIEBwYXJhbSBuIE5ldXJvbiBpbiBuZXh0IGxheWVyIGtcbiAgICAgICAgICovXG4gICAgICAgIE5ldXJvbi5wcm90b3R5cGUuZ2V0V2VpZ2h0VG8gPSBmdW5jdGlvbiAobikge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMud2VpZ2h0c1tuLmdldEluZGV4KCldO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogQHJldHVybnMgdHJ1ZSBpZiB0aGUgbmV1cm9uIGlzIGEgYmlhcyB1bml0IHdoaWNoIG1lYW5zIGl0IGhhcyBhIGNvbnN0YW50IG91dHB1dCBvZiAxXG4gICAgICAgICAqIEluZm86IEJpYXMgdW5pdHMgYXJlIHRoZSBsYXN0IG9uZXMgaW4gdGhlIG5ldXJvbnMgYXJyYXkgaW4gZWFjaCBsYXllciBvYmplY3RcbiAgICAgICAgICovXG4gICAgICAgIE5ldXJvbi5wcm90b3R5cGUuaXNCaWFzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMub3B0aW9ucy5pc0JpYXNVbml0O1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogQHJldHVybnMgdGhlIGluZGV4IG9mIHRoZSBjdXJyZW50IG5ldXJvbiBpbiBpdHMgbGF5ZXIgcmFuZ2luZyBmcm9tIDEgdG8gbnVtYmVyIG9mIHNwZWNpZmllZCBuZXVyb25zIGluIGxheWVyICsgMSBiZWNhdXNlIGFuIGV4dHJhIGJpYXMgbmV1cm9uIGlzIGFkZGVkIGF0IHRoZSBlbmQgb2YgbmV1cm9ucyBhcnJheSBpbiBhIGxheWVyIG9iamVjdC5cbiAgICAgICAgICovXG4gICAgICAgIE5ldXJvbi5wcm90b3R5cGUuZ2V0SW5kZXggPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5vcHRpb25zLmluZGV4O1xuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gTmV1cm9uO1xuICAgIH0oKSk7XG4gICAgdmFyIFdlaWdodCA9IChmdW5jdGlvbiAoKSB7XG4gICAgICAgIGZ1bmN0aW9uIFdlaWdodCh2YWx1ZSkge1xuICAgICAgICAgICAgaWYgKHZhbHVlID09PSB2b2lkIDApIHsgdmFsdWUgPSBNYXRoLnJhbmRvbSgpOyB9XG4gICAgICAgICAgICB0aGlzLnZhbHVlID0gdmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFdlaWdodDtcbiAgICB9KCkpO1xuICAgIHZhciBOZXR3b3JrID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZnVuY3Rpb24gTmV0d29yayhvcHRpb25zKSB7XG4gICAgICAgICAgICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zO1xuICAgICAgICAgICAgdGhpcy5sYXllcnMgPSBbXTtcbiAgICAgICAgICAgIC8vIENyZWF0ZSBuZXQncyBsYXllcnNcbiAgICAgICAgICAgIGZvciAodmFyIGwgPSAwOyBsIDwgb3B0aW9ucy5sYXllcnMubGVuZ3RoOyBsKyspIHtcbiAgICAgICAgICAgICAgICB0aGlzLmxheWVycy5wdXNoKG5ldyBMYXllcih7XG4gICAgICAgICAgICAgICAgICAgIG5ldE9wdGlvbnM6IG9wdGlvbnMsXG4gICAgICAgICAgICAgICAgICAgIG51bWJlck9mTmV1cm9uczogb3B0aW9ucy5sYXllcnNbbF0sXG4gICAgICAgICAgICAgICAgICAgIG51bWJlck9mTmV1cm9uc0luTmV4dExheWVyOiBvcHRpb25zLmxheWVyc1tsICsgMV0gfHwgMFxuICAgICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogQ3JlYXRlcyBuZXcgbmV0d29yayB3aXRoIHNwZWNpZmllZCB3ZWlnaHRzXG4gICAgICAgICAqIEBwYXJhbSB3ZWlnaHREYXRhIHByZXZpb3VzbHkgc2F2ZWQgd2VpZ2h0cyAodXNpbmcgTmV0d29yay5leHBvcnRXZWlnaHRzKVxuICAgICAgICAgKiBAcGFyYW0gb3B0aW9ucyBuZXR3b3JrIG9wdGlvbnNcbiAgICAgICAgICovXG4gICAgICAgIE5ldHdvcmsucmVzdG9yZSA9IGZ1bmN0aW9uICh3ZWlnaHREYXRhLCBvcHRpb25zKSB7XG4gICAgICAgICAgICB2YXIgYW5uID0gbmV3IE5ldHdvcmsob3B0aW9ucyk7XG4gICAgICAgICAgICBmb3IgKHZhciBsID0gMDsgbCA8IHdlaWdodERhdGEubGVuZ3RoOyBsKyspIHtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBuID0gMDsgbiA8IHdlaWdodERhdGFbbF0ubGVuZ3RoOyBuKyspIHtcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgdyA9IDA7IHcgPCB3ZWlnaHREYXRhW2xdW25dLmxlbmd0aDsgdysrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBhbm4ubGF5ZXJzW2xdLm5ldXJvbnNbbl0ud2VpZ2h0c1t3XS52YWx1ZSA9IHdlaWdodERhdGFbbF1bbl1bd107XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gYW5uO1xuICAgICAgICB9O1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTmV0d29yay5wcm90b3R5cGUsIFwiaW5wdXRMYXllclwiLCB7XG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIEByZXR1cm5zIHRoZSBpbnB1dCBsYXllclxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5sYXllcnNbMF07XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KE5ldHdvcmsucHJvdG90eXBlLCBcIm91dHB1dExheWVyXCIsIHtcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogQHJldHVybnMgdGhlIG91dHB1dCBsYXllclxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5sYXllcnNbdGhpcy5sYXllcnMubGVuZ3RoIC0gMV07XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEZvcndhcmQgUGFzcyBvZiB0aGUgbmV0d29yayB3aGVyZSB2YWx1ZXMgYXJlIHByb3BhZ2F0ZWQgdGhyb3VnaCB0aGUgbmV0d29ya1xuICAgICAgICAgKiBAcGFyYW0gaW5wdXRzIGlucHV0IHZhbHVlcyBtYXRjaGluZyB0aGUgc3BlY2lmaWVkIHNpemUgb2YgdGhlIG5ldHdvcmsncyBpbnB1dCBsYXllclxuICAgICAgICAgKi9cbiAgICAgICAgTmV0d29yay5wcm90b3R5cGUucHJvcGFnYXRlRm9yd2FyZCA9IGZ1bmN0aW9uIChpbnB1dHMpIHtcbiAgICAgICAgICAgIGlmIChpbnB1dHMubGVuZ3RoICE9IHRoaXMuaW5wdXRMYXllci5uZXVyb25zLmxlbmd0aCAtIDEpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBcIklucHV0cyBkbyBub3QgbWF0Y2ggbmV0d29yayBzaXplIVwiO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gU2V0IGlucHV0IGxheWVyIG5ldXJvbnMgb3V0cHV0IHRvIGlucHV0IHZhbHVlczsgZXhjbHVkZSBiaWFzIG9mIGNvdXJzZVxuICAgICAgICAgICAgdGhpcy5pbnB1dExheWVyLmZvckVhY2hOZXVyb24oZnVuY3Rpb24gKG4sIGkpIHsgcmV0dXJuIG4ub3V0cHV0ID0gaW5wdXRzW2ldOyB9LCB0cnVlKTtcbiAgICAgICAgICAgIHZhciBfbG9vcF8xID0gZnVuY3Rpb24gKGwpIHtcbiAgICAgICAgICAgICAgICB2YXIgbGF5ZXIgPSB0aGlzXzEubGF5ZXJzW2xdO1xuICAgICAgICAgICAgICAgIHZhciBwcmV2TGF5ZXIgPSB0aGlzXzEubGF5ZXJzW2wgLSAxXTtcbiAgICAgICAgICAgICAgICBsYXllci5mb3JFYWNoTmV1cm9uKGZ1bmN0aW9uIChuKSB7IHJldHVybiBuLnByb3BhZ2F0ZUZvcndhcmQocHJldkxheWVyKTsgfSwgdHJ1ZSk7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgdmFyIHRoaXNfMSA9IHRoaXM7XG4gICAgICAgICAgICAvLyBwcm9wYWdhdGUgdmFsdWVzIGZvcndhcmQgdGhyb3VnaCBsYXllciBzdGFydGluZyBmcm9tIGZpcnN0IGhpZGRlbiBsYXllclxuICAgICAgICAgICAgZm9yICh2YXIgbCA9IDE7IGwgPCB0aGlzLmxheWVycy5sZW5ndGg7IGwrKykge1xuICAgICAgICAgICAgICAgIF9sb29wXzEobCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEByZXR1cm5zIHRoZSBjdXJyZW50IG91dHB1dCBvZiB0aGUgbmV0d29ya1xuICAgICAgICAgKi9cbiAgICAgICAgTmV0d29yay5wcm90b3R5cGUuZ2V0Q3VycmVudE91dHB1dCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm91dHB1dExheWVyLm5ldXJvbnMubWFwKGZ1bmN0aW9uIChuKSB7IHJldHVybiBuLm91dHB1dDsgfSkuc2xpY2UoMCwgLTEpO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogQ2FsY3VsYXRlIGFsbCB0aGUgbmV1cm9ucyBkZWx0YSB2YWx1ZXNcbiAgICAgICAgICogQHBhcmFtIHRhcmdldFZhbHVlcyB0YXJnZXQgdmFsdWVzIGZvciB0aGUgbmV0d29yayB3aXRoIHJlc3BlY3QgdG8gbGFzdCBmb3J3YXJkIHBhc3NcbiAgICAgICAgICovXG4gICAgICAgIE5ldHdvcmsucHJvdG90eXBlLmNhbGN1bGF0ZURlbHRhcyA9IGZ1bmN0aW9uICh0YXJnZXRWYWx1ZXMpIHtcbiAgICAgICAgICAgIC8vIGNhbGN1bGF0ZSBPdXRwdXQgbGF5ZXIgY2FsY3VsYXRlRGVsdGFzXG4gICAgICAgICAgICB0aGlzLm91dHB1dExheWVyLmZvckVhY2hOZXVyb24oZnVuY3Rpb24gKG4sIGkpIHsgcmV0dXJuIG4uY2FsY3VsYXRlT3V0cHV0TGF5ZXJEZWx0YSh0YXJnZXRWYWx1ZXNbaV0pOyB9LCB0cnVlKTtcbiAgICAgICAgICAgIHZhciBfbG9vcF8yID0gZnVuY3Rpb24gKGwpIHtcbiAgICAgICAgICAgICAgICB2YXIgbGF5ZXIgPSB0aGlzXzIubGF5ZXJzW2xdO1xuICAgICAgICAgICAgICAgIHZhciBuZXh0TGF5ZXIgPSB0aGlzXzIubGF5ZXJzW2wgKyAxXTtcbiAgICAgICAgICAgICAgICBsYXllci5mb3JFYWNoTmV1cm9uKGZ1bmN0aW9uIChuKSB7IHJldHVybiBuLmNhbGN1bGF0ZUhpZGRlbkxheWVyRGVsdGEobmV4dExheWVyKTsgfSwgdHJ1ZSk7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgdmFyIHRoaXNfMiA9IHRoaXM7XG4gICAgICAgICAgICAvLyBwcm9wYWdhdGUgZXJyb3IgYmFja3dhcmRzIHRocm91Z2ggaGlkZGVuIGxheWVyc1xuICAgICAgICAgICAgZm9yICh2YXIgbCA9IHRoaXMubGF5ZXJzLmxlbmd0aCAtIDI7IGwgPiAwOyBsLS0pIHtcbiAgICAgICAgICAgICAgICBfbG9vcF8yKGwpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBVcGRhdGUgdGhlIGNvbm5lY3Rpb24gd2VpZ2h0cyB1c2luZyBwcmV2aW91cyBjYWxjdWxhdGVkIGRlbHRhIHZhbHVlc1xuICAgICAgICAgKi9cbiAgICAgICAgTmV0d29yay5wcm90b3R5cGUudXBkYXRlV2VpZ2h0cyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBfbG9vcF8zID0gZnVuY3Rpb24gKGwpIHtcbiAgICAgICAgICAgICAgICB2YXIgbGF5ZXIgPSB0aGlzXzMubGF5ZXJzW2xdO1xuICAgICAgICAgICAgICAgIHZhciBwcmV2TGF5ZXIgPSB0aGlzXzMubGF5ZXJzW2wgLSAxXTtcbiAgICAgICAgICAgICAgICBsYXllci5mb3JFYWNoTmV1cm9uKGZ1bmN0aW9uIChuKSB7IHJldHVybiBuLnVwZGF0ZVdlaWdodHMocHJldkxheWVyKTsgfSwgdHJ1ZSk7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgdmFyIHRoaXNfMyA9IHRoaXM7XG4gICAgICAgICAgICAvLyBnbyB0aHJvdWdoIGFsbCBsYXllcnMgZXhjZXB0IGlucHV0IGxheWVyIGFuZCB1cGRhdGUgYWxsIHRoZSB3ZWlnaHRzIHdpdGggdGhlIGNhbGN1bGF0ZWQgZGVsdGFWYWx1ZXMuXG4gICAgICAgICAgICBmb3IgKHZhciBsID0gMTsgbCA8IHRoaXMubGF5ZXJzLmxlbmd0aDsgbCsrKSB7XG4gICAgICAgICAgICAgICAgX2xvb3BfMyhsKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogRml0cyBnaXZlbiBpbnB1dHMgdG8gZ2l2ZW4gdGFyZ2V0IHZhbHVlcyBieSB0cmFpbmluZyB0aGUgbmV0d29ya1xuICAgICAgICAgKiBAcGFyYW0gaW5wdXRzIGlucHV0cyB0byB0aGUgbmV0d29ya1xuICAgICAgICAgKiBAcGFyYW0gdGFyZ2V0VmFsdWVzIGV4cGVjdGVkIG91dHB1dHMgZm9yIGdpdmVuIGlucHV0XG4gICAgICAgICAqL1xuICAgICAgICBOZXR3b3JrLnByb3RvdHlwZS5maXQgPSBmdW5jdGlvbiAoaW5wdXRzLCB0YXJnZXRWYWx1ZXMpIHtcbiAgICAgICAgICAgIHRoaXMucHJvcGFnYXRlRm9yd2FyZChpbnB1dHMpLmNhbGN1bGF0ZURlbHRhcyh0YXJnZXRWYWx1ZXMpLnVwZGF0ZVdlaWdodHMoKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogUHJlZGljdCBvdXRwdXQgdmFsdWVzIGZvciBnaXZlbiBpbnB1dHNcbiAgICAgICAgICogQHBhcmFtIGlucHV0cyBpbnB1dCB2YWx1ZXNcbiAgICAgICAgICovXG4gICAgICAgIE5ldHdvcmsucHJvdG90eXBlLnByZWRpY3QgPSBmdW5jdGlvbiAoaW5wdXRzKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5wcm9wYWdhdGVGb3J3YXJkKGlucHV0cykuZ2V0Q3VycmVudE91dHB1dCgpO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogQ2FsY3VsYXRlIHRoZSBlcnJvciBmb3IgY3VycmVudCBvdXRwdXRzIChub3QgZm9yd2FyZCBwYXNzKVxuICAgICAgICAgKiBAcGFyYW0gdGFyZ2V0VmFsdWVzIHRhcmdldCB2YWx1ZXNcbiAgICAgICAgICovXG4gICAgICAgIE5ldHdvcmsucHJvdG90eXBlLmdldEN1cnJlbnRFcnJvciA9IGZ1bmN0aW9uICh0YXJnZXRWYWx1ZXMpIHtcbiAgICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5nZXRDdXJyZW50T3V0cHV0KCkucmVkdWNlKGZ1bmN0aW9uIChzLCBvLCBpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHMgKyBfdGhpcy5vcHRpb25zLmVycm9yRnVuY3Rpb24uZXJyb3IobywgdGFyZ2V0VmFsdWVzW2ldKTtcbiAgICAgICAgICAgIH0sIDApO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogQ2FsY3VsYXRlcyB0aGUgZXJyb3IgZm9yIGdpdmVuIGlucHV0c1xuICAgICAgICAgKiBAcGFyYW0gaW5wdXRzIGlucHV0cyB0byBuZXR3b3JrXG4gICAgICAgICAqIEBwYXJhbSB0YXJnZXRWYWx1ZXMgZXhwZWN0ZWQgb3V0cHV0IGZvciBnaXZlbiBpbnB1dHNcbiAgICAgICAgICovXG4gICAgICAgIE5ldHdvcmsucHJvdG90eXBlLmVycm9yID0gZnVuY3Rpb24gKGlucHV0cywgdGFyZ2V0VmFsdWVzKSB7XG4gICAgICAgICAgICB0aGlzLnByb3BhZ2F0ZUZvcndhcmQoaW5wdXRzKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmdldEN1cnJlbnRFcnJvcih0YXJnZXRWYWx1ZXMpO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogRXhwb3J0IHRoZSBjdXJyZW50IHdlaWdodHMgb2YgdGhlIG5ldHdvcmtcbiAgICAgICAgICovXG4gICAgICAgIE5ldHdvcmsucHJvdG90eXBlLmV4cG9ydFdlaWdodHMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgZGF0YSA9IFtdO1xuICAgICAgICAgICAgZm9yICh2YXIgbCA9IDA7IGwgPCB0aGlzLmxheWVycy5sZW5ndGggLSAxOyBsKyspIHtcbiAgICAgICAgICAgICAgICB2YXIgbGF5ZXIgPSB0aGlzLmxheWVyc1tsXTtcbiAgICAgICAgICAgICAgICB2YXIgbGF5ZXJEYXRhID0gbGF5ZXIubmV1cm9ucy5tYXAoZnVuY3Rpb24gKG4pIHsgcmV0dXJuIG4ud2VpZ2h0cy5tYXAoZnVuY3Rpb24gKHcpIHsgcmV0dXJuIHcudmFsdWU7IH0pOyB9KTtcbiAgICAgICAgICAgICAgICBkYXRhLnB1c2gobGF5ZXJEYXRhKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBkYXRhO1xuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gTmV0d29yaztcbiAgICB9KCkpO1xuICAgIEZlZWRGb3J3YXJkLk5ldHdvcmsgPSBOZXR3b3JrO1xufSkoRmVlZEZvcndhcmQgPSBleHBvcnRzLkZlZWRGb3J3YXJkIHx8IChleHBvcnRzLkZlZWRGb3J3YXJkID0ge30pKTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vc3JjL05ldXJhbE5ldHdvcmtzL2Fubi50c1xuLy8gbW9kdWxlIGlkID0gMTNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTsiLCJzb3VyY2VSb290IjoiIn0=");

/***/ })
/******/ ])));