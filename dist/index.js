(function(e, a) { for(var i in a) e[i] = a[i]; }(exports, /******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId])
/******/ 			return installedModules[moduleId].exports;
/******/
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// identity function for calling harmony imports with the correct context
/******/ 	__webpack_require__.i = function(value) { return value; };
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, {
/******/ 				configurable: false,
/******/ 				enumerable: true,
/******/ 				get: getter
/******/ 			});
/******/ 		}
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 6);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/* unknown exports provided */
/* all exports used */
/*!***************************************************!*\
  !*** ./src/NeuralNetworks/activationFunctions.ts ***!
  \***************************************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar Activations = (function () {\n    function Activations() {\n    }\n    return Activations;\n}());\nActivations.TANH = {\n    output: function (x) { return Math.tanh(x); },\n    der: function (x) {\n        var output = Activations.TANH.output(x);\n        return 1 - output * output;\n    }\n};\nActivations.SIGMOID = {\n    output: function (x) { return 1 / (1 + Math.exp(-x)); },\n    der: function (x) {\n        var output = Activations.SIGMOID.output(x);\n        return output * (1 - output);\n    }\n};\nActivations.RELU = {\n    output: function (x) { return Math.max(0, x); },\n    der: function (x) { return x <= 0 ? 0 : 1; }\n};\nActivations.LINEAR = {\n    output: function (x) { return x; },\n    der: function (x) { return 1; }\n};\nexports.Activations = Activations;\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMC5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL3NyYy9OZXVyYWxOZXR3b3Jrcy9hY3RpdmF0aW9uRnVuY3Rpb25zLnRzP2NkZmQiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgQWN0aXZhdGlvbnMgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIEFjdGl2YXRpb25zKCkge1xuICAgIH1cbiAgICByZXR1cm4gQWN0aXZhdGlvbnM7XG59KCkpO1xuQWN0aXZhdGlvbnMuVEFOSCA9IHtcbiAgICBvdXRwdXQ6IGZ1bmN0aW9uICh4KSB7IHJldHVybiBNYXRoLnRhbmgoeCk7IH0sXG4gICAgZGVyOiBmdW5jdGlvbiAoeCkge1xuICAgICAgICB2YXIgb3V0cHV0ID0gQWN0aXZhdGlvbnMuVEFOSC5vdXRwdXQoeCk7XG4gICAgICAgIHJldHVybiAxIC0gb3V0cHV0ICogb3V0cHV0O1xuICAgIH1cbn07XG5BY3RpdmF0aW9ucy5TSUdNT0lEID0ge1xuICAgIG91dHB1dDogZnVuY3Rpb24gKHgpIHsgcmV0dXJuIDEgLyAoMSArIE1hdGguZXhwKC14KSk7IH0sXG4gICAgZGVyOiBmdW5jdGlvbiAoeCkge1xuICAgICAgICB2YXIgb3V0cHV0ID0gQWN0aXZhdGlvbnMuU0lHTU9JRC5vdXRwdXQoeCk7XG4gICAgICAgIHJldHVybiBvdXRwdXQgKiAoMSAtIG91dHB1dCk7XG4gICAgfVxufTtcbkFjdGl2YXRpb25zLlJFTFUgPSB7XG4gICAgb3V0cHV0OiBmdW5jdGlvbiAoeCkgeyByZXR1cm4gTWF0aC5tYXgoMCwgeCk7IH0sXG4gICAgZGVyOiBmdW5jdGlvbiAoeCkgeyByZXR1cm4geCA8PSAwID8gMCA6IDE7IH1cbn07XG5BY3RpdmF0aW9ucy5MSU5FQVIgPSB7XG4gICAgb3V0cHV0OiBmdW5jdGlvbiAoeCkgeyByZXR1cm4geDsgfSxcbiAgICBkZXI6IGZ1bmN0aW9uICh4KSB7IHJldHVybiAxOyB9XG59O1xuZXhwb3J0cy5BY3RpdmF0aW9ucyA9IEFjdGl2YXRpb25zO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9zcmMvTmV1cmFsTmV0d29ya3MvYWN0aXZhdGlvbkZ1bmN0aW9ucy50c1xuLy8gbW9kdWxlIGlkID0gMFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTsiLCJzb3VyY2VSb290IjoiIn0=");

/***/ }),
/* 1 */
/* unknown exports provided */
/* all exports used */
/*!***********************************!*\
  !*** ./src/NeuralNetworks/ann.ts ***!
  \***********************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar FeedForward;\n(function (FeedForward) {\n    var Layer = (function () {\n        function Layer(options) {\n            this.options = options;\n            // neurons[0] â†’ Bias Unit\n            this.neurons = [];\n            // +1 for one bias unit\n            for (var n = 0; n < options.numberOfNeurons + 1; n++) {\n                this.neurons.push(new Neuron({\n                    index: n,\n                    isBiasUnit: n == options.numberOfNeurons,\n                    netOptions: options.netOptions,\n                    numberOfNeuronsInNextLayer: options.numberOfNeuronsInNextLayer\n                }));\n            }\n        }\n        Layer.prototype.forEachNeuron = function (func, excludeBias) {\n            if (excludeBias === void 0) { excludeBias = false; }\n            for (var i = 0; i < this.neurons.length - (excludeBias ? 1 : 0); i++) {\n                var neuron = this.neurons[i];\n                // Bias units are the last ones\n                func(neuron, neuron.getIndex());\n            }\n        };\n        return Layer;\n    }());\n    var Neuron = (function () {\n        // Bias units are the last ones in array\n        function Neuron(options) {\n            this.options = options;\n            this.weights = [];\n            this.prevDelta = 0;\n            if (this.isBias())\n                this.output = 1;\n            // Generate weights\n            for (var n = 0; n < options.numberOfNeuronsInNextLayer; n++) {\n                this.weights.push(new Weight());\n            }\n            // set shorthand for activation function\n            this.activationFunction = this.options.netOptions.activationFunction;\n        }\n        /**\n         * Forward pass of values through the neuron using the prevLayer\n         * @param prevLayer i\n         */\n        Neuron.prototype.propagateForward = function (prevLayer) {\n            var _this = this;\n            if (this.isBias()) {\n                throw 'A bias unit should not propagate a value forward.';\n            }\n            var sigma = 0;\n            prevLayer.forEachNeuron(function (n) {\n                sigma += n.output * n.getWeightTo(_this).value;\n            });\n            this.input = sigma;\n            this.output = this.activationFunction.output(this.input);\n        };\n        /**\n         * Calculates the delta of an output neuron using the derivative term of the specified error function of the network and the target value\n         * @param target target value for this output neuron\n         */\n        Neuron.prototype.calculateOutputLayerDelta = function (target) {\n            if (this.isBias())\n                throw 'There should not be an output layer delta calculation for a bias unit for it is never used.';\n            this.prevDelta = this.delta || 0;\n            this.delta = this.options.netOptions.errorFunction.der(this.output, target) * this.activationFunction.der(this.input);\n        };\n        /**\n         * Calculates the delta values for neurons in a hidden layer j using the next layer k\n         * @param nextLayer k\n         */\n        Neuron.prototype.calculateHiddenLayerDelta = function (nextLayer) {\n            var _this = this;\n            if (this.isBias())\n                throw 'There should not be an hidden layer delta calculation for a bias unit for it is not connected to the previous layer.';\n            var sigma = 0;\n            nextLayer.forEachNeuron(function (n, i) {\n                sigma += n.delta * _this.weights[i].value;\n            }, true);\n            this.prevDelta = this.delta || 0;\n            this.delta = this.activationFunction.der(this.input) * sigma;\n        };\n        /**\n         * Updates the weights which connect the previous layer to the current one using this layer neurons delta values and the output of the previous layer neurons\n         * @param prevLayer the previous layer i\n         */\n        Neuron.prototype.updateWeights = function (prevLayer) {\n            var _this = this;\n            prevLayer.forEachNeuron(function (n, i) {\n                var oldWeight = n.weights[_this.getIndex()];\n                var derivativeTerm = n.output * _this.delta;\n                var momentumTerm = _this.options.netOptions.momentum * _this.prevDelta;\n                oldWeight.value -= _this.options.netOptions.learningRate * derivativeTerm + momentumTerm;\n            });\n        };\n        ;\n        /**\n         * Get the weight to a neuron in the next layer k from current layer k\n         * Weights to layer k are stored in neurons of layer j\n         * @param n Neuron in next layer k\n         */\n        Neuron.prototype.getWeightTo = function (n) {\n            return this.weights[n.getIndex()];\n        };\n        /**\n         * @returns true if the neuron is a bias unit which means it has a constant output of 1\n         * Info: Bias units are the last ones in the neurons array in each layer object\n         */\n        Neuron.prototype.isBias = function () {\n            return this.options.isBiasUnit;\n        };\n        /**\n         * @returns the index of the current neuron in its layer ranging from 1 to number of specified neurons in layer + 1 because an extra bias neuron is added at the end of neurons array in a layer object.\n         */\n        Neuron.prototype.getIndex = function () {\n            return this.options.index;\n        };\n        return Neuron;\n    }());\n    var Weight = (function () {\n        function Weight(value) {\n            if (value === void 0) { value = Math.random(); }\n            this.value = value;\n        }\n        return Weight;\n    }());\n    var Network = (function () {\n        function Network(options) {\n            this.options = options;\n            this.layers = [];\n            // Create net's layers\n            for (var l = 0; l < options.layers.length; l++) {\n                this.layers.push(new Layer({\n                    netOptions: options,\n                    numberOfNeurons: options.layers[l],\n                    numberOfNeuronsInNextLayer: options.layers[l + 1] || 0\n                }));\n            }\n        }\n        /**\n         * Creates new network with specified weights\n         * @param weightData previously saved weights (using Network.exportWeights)\n         * @param options network options\n         */\n        Network.restore = function (weightData, options) {\n            var ann = new Network(options);\n            for (var l = 0; l < weightData.length; l++) {\n                for (var n = 0; n < weightData[l].length; n++) {\n                    for (var w = 0; w < weightData[l][n].length; w++) {\n                        ann.layers[l].neurons[n].weights[w].value = weightData[l][n][w];\n                    }\n                }\n            }\n            return ann;\n        };\n        Object.defineProperty(Network.prototype, \"inputLayer\", {\n            /**\n             * @returns the input layer\n             */\n            get: function () {\n                return this.layers[0];\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(Network.prototype, \"outputLayer\", {\n            /**\n             * @returns the output layer\n             */\n            get: function () {\n                return this.layers[this.layers.length - 1];\n            },\n            enumerable: true,\n            configurable: true\n        });\n        /**\n         * Forward Pass of the network where values are propagated through the network\n         * @param inputs input values matching the specified size of the network's input layer\n         */\n        Network.prototype.propagateForward = function (inputs) {\n            if (inputs.length != this.inputLayer.neurons.length - 1) {\n                throw \"Inputs do not match network size!\";\n            }\n            // Set input layer neurons output to input values; exclude bias of course\n            this.inputLayer.forEachNeuron(function (n, i) { return n.output = inputs[i]; }, true);\n            var _loop_1 = function (l) {\n                var layer = this_1.layers[l];\n                var prevLayer = this_1.layers[l - 1];\n                layer.forEachNeuron(function (n) { return n.propagateForward(prevLayer); }, true);\n            };\n            var this_1 = this;\n            // propagate values forward through layer starting from first hidden layer\n            for (var l = 1; l < this.layers.length; l++) {\n                _loop_1(l);\n            }\n            return this;\n        };\n        /**\n         * @returns the current output of the network\n         */\n        Network.prototype.getCurrentOutput = function () {\n            return this.outputLayer.neurons.map(function (n) { return n.output; }).slice(0, -1);\n        };\n        /**\n         * Calculate all the neurons delta values\n         * @param targetValues target values for the network with respect to last forward pass\n         */\n        Network.prototype.calculateDeltas = function (targetValues) {\n            // calculate Output layer calculateDeltas\n            this.outputLayer.forEachNeuron(function (n, i) { return n.calculateOutputLayerDelta(targetValues[i]); }, true);\n            var _loop_2 = function (l) {\n                var layer = this_2.layers[l];\n                var nextLayer = this_2.layers[l + 1];\n                layer.forEachNeuron(function (n) { return n.calculateHiddenLayerDelta(nextLayer); }, true);\n            };\n            var this_2 = this;\n            // propagate error backwards through hidden layers\n            for (var l = this.layers.length - 2; l > 0; l--) {\n                _loop_2(l);\n            }\n            return this;\n        };\n        /**\n         * Update the connection weights using previous calculated delta values\n         */\n        Network.prototype.updateWeights = function () {\n            var _loop_3 = function (l) {\n                var layer = this_3.layers[l];\n                var prevLayer = this_3.layers[l - 1];\n                layer.forEachNeuron(function (n) { return n.updateWeights(prevLayer); }, true);\n            };\n            var this_3 = this;\n            // go through all layers except input layer and update all the weights with the calculated deltaValues.\n            for (var l = 1; l < this.layers.length; l++) {\n                _loop_3(l);\n            }\n            return this;\n        };\n        /**\n         * Fits given inputs to given target values by training the network\n         * @param inputs inputs to the network\n         * @param targetValues expected outputs for given input\n         */\n        Network.prototype.fit = function (inputs, targetValues) {\n            this.propagateForward(inputs).calculateDeltas(targetValues).updateWeights();\n            return this;\n        };\n        /**\n         * Predict output values for given inputs\n         * @param inputs input values\n         */\n        Network.prototype.predict = function (inputs) {\n            return this.propagateForward(inputs).getCurrentOutput();\n        };\n        /**\n         * Calculate the error for current outputs\n         * @param targetValues target values\n         */\n        Network.prototype.getCurrentError = function (targetValues) {\n            var _this = this;\n            return this.getCurrentOutput().reduce(function (s, o, i) {\n                return s + _this.options.errorFunction.error(o, targetValues[i]);\n            }, 0);\n        };\n        /**\n         * Calculates the error for given inputs\n         * @param inputs inputs to network\n         * @param targetValues expected output for given inputs\n         */\n        Network.prototype.error = function (inputs, targetValues) {\n            this.propagateForward(inputs);\n            return this.getCurrentError(targetValues);\n        };\n        /**\n         * Export the current weights of the network\n         */\n        Network.prototype.exportWeights = function () {\n            var data = [];\n            for (var l = 0; l < this.layers.length - 1; l++) {\n                var layer = this.layers[l];\n                var layerData = layer.neurons.map(function (n) { return n.weights.map(function (w) { return w.value; }); });\n                data.push(layerData);\n            }\n            return data;\n        };\n        return Network;\n    }());\n    FeedForward.Network = Network;\n})(FeedForward = exports.FeedForward || (exports.FeedForward = {}));\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMS5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL3NyYy9OZXVyYWxOZXR3b3Jrcy9hbm4udHM/M2YzNiJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBGZWVkRm9yd2FyZDtcbihmdW5jdGlvbiAoRmVlZEZvcndhcmQpIHtcbiAgICB2YXIgTGF5ZXIgPSAoZnVuY3Rpb24gKCkge1xuICAgICAgICBmdW5jdGlvbiBMYXllcihvcHRpb25zKSB7XG4gICAgICAgICAgICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zO1xuICAgICAgICAgICAgLy8gbmV1cm9uc1swXSDihpIgQmlhcyBVbml0XG4gICAgICAgICAgICB0aGlzLm5ldXJvbnMgPSBbXTtcbiAgICAgICAgICAgIC8vICsxIGZvciBvbmUgYmlhcyB1bml0XG4gICAgICAgICAgICBmb3IgKHZhciBuID0gMDsgbiA8IG9wdGlvbnMubnVtYmVyT2ZOZXVyb25zICsgMTsgbisrKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5uZXVyb25zLnB1c2gobmV3IE5ldXJvbih7XG4gICAgICAgICAgICAgICAgICAgIGluZGV4OiBuLFxuICAgICAgICAgICAgICAgICAgICBpc0JpYXNVbml0OiBuID09IG9wdGlvbnMubnVtYmVyT2ZOZXVyb25zLFxuICAgICAgICAgICAgICAgICAgICBuZXRPcHRpb25zOiBvcHRpb25zLm5ldE9wdGlvbnMsXG4gICAgICAgICAgICAgICAgICAgIG51bWJlck9mTmV1cm9uc0luTmV4dExheWVyOiBvcHRpb25zLm51bWJlck9mTmV1cm9uc0luTmV4dExheWVyXG4gICAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIExheWVyLnByb3RvdHlwZS5mb3JFYWNoTmV1cm9uID0gZnVuY3Rpb24gKGZ1bmMsIGV4Y2x1ZGVCaWFzKSB7XG4gICAgICAgICAgICBpZiAoZXhjbHVkZUJpYXMgPT09IHZvaWQgMCkgeyBleGNsdWRlQmlhcyA9IGZhbHNlOyB9XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMubmV1cm9ucy5sZW5ndGggLSAoZXhjbHVkZUJpYXMgPyAxIDogMCk7IGkrKykge1xuICAgICAgICAgICAgICAgIHZhciBuZXVyb24gPSB0aGlzLm5ldXJvbnNbaV07XG4gICAgICAgICAgICAgICAgLy8gQmlhcyB1bml0cyBhcmUgdGhlIGxhc3Qgb25lc1xuICAgICAgICAgICAgICAgIGZ1bmMobmV1cm9uLCBuZXVyb24uZ2V0SW5kZXgoKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBMYXllcjtcbiAgICB9KCkpO1xuICAgIHZhciBOZXVyb24gPSAoZnVuY3Rpb24gKCkge1xuICAgICAgICAvLyBCaWFzIHVuaXRzIGFyZSB0aGUgbGFzdCBvbmVzIGluIGFycmF5XG4gICAgICAgIGZ1bmN0aW9uIE5ldXJvbihvcHRpb25zKSB7XG4gICAgICAgICAgICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zO1xuICAgICAgICAgICAgdGhpcy53ZWlnaHRzID0gW107XG4gICAgICAgICAgICB0aGlzLnByZXZEZWx0YSA9IDA7XG4gICAgICAgICAgICBpZiAodGhpcy5pc0JpYXMoKSlcbiAgICAgICAgICAgICAgICB0aGlzLm91dHB1dCA9IDE7XG4gICAgICAgICAgICAvLyBHZW5lcmF0ZSB3ZWlnaHRzXG4gICAgICAgICAgICBmb3IgKHZhciBuID0gMDsgbiA8IG9wdGlvbnMubnVtYmVyT2ZOZXVyb25zSW5OZXh0TGF5ZXI7IG4rKykge1xuICAgICAgICAgICAgICAgIHRoaXMud2VpZ2h0cy5wdXNoKG5ldyBXZWlnaHQoKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBzZXQgc2hvcnRoYW5kIGZvciBhY3RpdmF0aW9uIGZ1bmN0aW9uXG4gICAgICAgICAgICB0aGlzLmFjdGl2YXRpb25GdW5jdGlvbiA9IHRoaXMub3B0aW9ucy5uZXRPcHRpb25zLmFjdGl2YXRpb25GdW5jdGlvbjtcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogRm9yd2FyZCBwYXNzIG9mIHZhbHVlcyB0aHJvdWdoIHRoZSBuZXVyb24gdXNpbmcgdGhlIHByZXZMYXllclxuICAgICAgICAgKiBAcGFyYW0gcHJldkxheWVyIGlcbiAgICAgICAgICovXG4gICAgICAgIE5ldXJvbi5wcm90b3R5cGUucHJvcGFnYXRlRm9yd2FyZCA9IGZ1bmN0aW9uIChwcmV2TGF5ZXIpIHtcbiAgICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgICAgICBpZiAodGhpcy5pc0JpYXMoKSkge1xuICAgICAgICAgICAgICAgIHRocm93ICdBIGJpYXMgdW5pdCBzaG91bGQgbm90IHByb3BhZ2F0ZSBhIHZhbHVlIGZvcndhcmQuJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBzaWdtYSA9IDA7XG4gICAgICAgICAgICBwcmV2TGF5ZXIuZm9yRWFjaE5ldXJvbihmdW5jdGlvbiAobikge1xuICAgICAgICAgICAgICAgIHNpZ21hICs9IG4ub3V0cHV0ICogbi5nZXRXZWlnaHRUbyhfdGhpcykudmFsdWU7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHRoaXMuaW5wdXQgPSBzaWdtYTtcbiAgICAgICAgICAgIHRoaXMub3V0cHV0ID0gdGhpcy5hY3RpdmF0aW9uRnVuY3Rpb24ub3V0cHV0KHRoaXMuaW5wdXQpO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogQ2FsY3VsYXRlcyB0aGUgZGVsdGEgb2YgYW4gb3V0cHV0IG5ldXJvbiB1c2luZyB0aGUgZGVyaXZhdGl2ZSB0ZXJtIG9mIHRoZSBzcGVjaWZpZWQgZXJyb3IgZnVuY3Rpb24gb2YgdGhlIG5ldHdvcmsgYW5kIHRoZSB0YXJnZXQgdmFsdWVcbiAgICAgICAgICogQHBhcmFtIHRhcmdldCB0YXJnZXQgdmFsdWUgZm9yIHRoaXMgb3V0cHV0IG5ldXJvblxuICAgICAgICAgKi9cbiAgICAgICAgTmV1cm9uLnByb3RvdHlwZS5jYWxjdWxhdGVPdXRwdXRMYXllckRlbHRhID0gZnVuY3Rpb24gKHRhcmdldCkge1xuICAgICAgICAgICAgaWYgKHRoaXMuaXNCaWFzKCkpXG4gICAgICAgICAgICAgICAgdGhyb3cgJ1RoZXJlIHNob3VsZCBub3QgYmUgYW4gb3V0cHV0IGxheWVyIGRlbHRhIGNhbGN1bGF0aW9uIGZvciBhIGJpYXMgdW5pdCBmb3IgaXQgaXMgbmV2ZXIgdXNlZC4nO1xuICAgICAgICAgICAgdGhpcy5wcmV2RGVsdGEgPSB0aGlzLmRlbHRhIHx8IDA7XG4gICAgICAgICAgICB0aGlzLmRlbHRhID0gdGhpcy5vcHRpb25zLm5ldE9wdGlvbnMuZXJyb3JGdW5jdGlvbi5kZXIodGhpcy5vdXRwdXQsIHRhcmdldCkgKiB0aGlzLmFjdGl2YXRpb25GdW5jdGlvbi5kZXIodGhpcy5pbnB1dCk7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDYWxjdWxhdGVzIHRoZSBkZWx0YSB2YWx1ZXMgZm9yIG5ldXJvbnMgaW4gYSBoaWRkZW4gbGF5ZXIgaiB1c2luZyB0aGUgbmV4dCBsYXllciBrXG4gICAgICAgICAqIEBwYXJhbSBuZXh0TGF5ZXIga1xuICAgICAgICAgKi9cbiAgICAgICAgTmV1cm9uLnByb3RvdHlwZS5jYWxjdWxhdGVIaWRkZW5MYXllckRlbHRhID0gZnVuY3Rpb24gKG5leHRMYXllcikge1xuICAgICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgICAgIGlmICh0aGlzLmlzQmlhcygpKVxuICAgICAgICAgICAgICAgIHRocm93ICdUaGVyZSBzaG91bGQgbm90IGJlIGFuIGhpZGRlbiBsYXllciBkZWx0YSBjYWxjdWxhdGlvbiBmb3IgYSBiaWFzIHVuaXQgZm9yIGl0IGlzIG5vdCBjb25uZWN0ZWQgdG8gdGhlIHByZXZpb3VzIGxheWVyLic7XG4gICAgICAgICAgICB2YXIgc2lnbWEgPSAwO1xuICAgICAgICAgICAgbmV4dExheWVyLmZvckVhY2hOZXVyb24oZnVuY3Rpb24gKG4sIGkpIHtcbiAgICAgICAgICAgICAgICBzaWdtYSArPSBuLmRlbHRhICogX3RoaXMud2VpZ2h0c1tpXS52YWx1ZTtcbiAgICAgICAgICAgIH0sIHRydWUpO1xuICAgICAgICAgICAgdGhpcy5wcmV2RGVsdGEgPSB0aGlzLmRlbHRhIHx8IDA7XG4gICAgICAgICAgICB0aGlzLmRlbHRhID0gdGhpcy5hY3RpdmF0aW9uRnVuY3Rpb24uZGVyKHRoaXMuaW5wdXQpICogc2lnbWE7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBVcGRhdGVzIHRoZSB3ZWlnaHRzIHdoaWNoIGNvbm5lY3QgdGhlIHByZXZpb3VzIGxheWVyIHRvIHRoZSBjdXJyZW50IG9uZSB1c2luZyB0aGlzIGxheWVyIG5ldXJvbnMgZGVsdGEgdmFsdWVzIGFuZCB0aGUgb3V0cHV0IG9mIHRoZSBwcmV2aW91cyBsYXllciBuZXVyb25zXG4gICAgICAgICAqIEBwYXJhbSBwcmV2TGF5ZXIgdGhlIHByZXZpb3VzIGxheWVyIGlcbiAgICAgICAgICovXG4gICAgICAgIE5ldXJvbi5wcm90b3R5cGUudXBkYXRlV2VpZ2h0cyA9IGZ1bmN0aW9uIChwcmV2TGF5ZXIpIHtcbiAgICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgICAgICBwcmV2TGF5ZXIuZm9yRWFjaE5ldXJvbihmdW5jdGlvbiAobiwgaSkge1xuICAgICAgICAgICAgICAgIHZhciBvbGRXZWlnaHQgPSBuLndlaWdodHNbX3RoaXMuZ2V0SW5kZXgoKV07XG4gICAgICAgICAgICAgICAgdmFyIGRlcml2YXRpdmVUZXJtID0gbi5vdXRwdXQgKiBfdGhpcy5kZWx0YTtcbiAgICAgICAgICAgICAgICB2YXIgbW9tZW50dW1UZXJtID0gX3RoaXMub3B0aW9ucy5uZXRPcHRpb25zLm1vbWVudHVtICogX3RoaXMucHJldkRlbHRhO1xuICAgICAgICAgICAgICAgIG9sZFdlaWdodC52YWx1ZSAtPSBfdGhpcy5vcHRpb25zLm5ldE9wdGlvbnMubGVhcm5pbmdSYXRlICogZGVyaXZhdGl2ZVRlcm0gKyBtb21lbnR1bVRlcm07XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfTtcbiAgICAgICAgO1xuICAgICAgICAvKipcbiAgICAgICAgICogR2V0IHRoZSB3ZWlnaHQgdG8gYSBuZXVyb24gaW4gdGhlIG5leHQgbGF5ZXIgayBmcm9tIGN1cnJlbnQgbGF5ZXIga1xuICAgICAgICAgKiBXZWlnaHRzIHRvIGxheWVyIGsgYXJlIHN0b3JlZCBpbiBuZXVyb25zIG9mIGxheWVyIGpcbiAgICAgICAgICogQHBhcmFtIG4gTmV1cm9uIGluIG5leHQgbGF5ZXIga1xuICAgICAgICAgKi9cbiAgICAgICAgTmV1cm9uLnByb3RvdHlwZS5nZXRXZWlnaHRUbyA9IGZ1bmN0aW9uIChuKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy53ZWlnaHRzW24uZ2V0SW5kZXgoKV07XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcmV0dXJucyB0cnVlIGlmIHRoZSBuZXVyb24gaXMgYSBiaWFzIHVuaXQgd2hpY2ggbWVhbnMgaXQgaGFzIGEgY29uc3RhbnQgb3V0cHV0IG9mIDFcbiAgICAgICAgICogSW5mbzogQmlhcyB1bml0cyBhcmUgdGhlIGxhc3Qgb25lcyBpbiB0aGUgbmV1cm9ucyBhcnJheSBpbiBlYWNoIGxheWVyIG9iamVjdFxuICAgICAgICAgKi9cbiAgICAgICAgTmV1cm9uLnByb3RvdHlwZS5pc0JpYXMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5vcHRpb25zLmlzQmlhc1VuaXQ7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcmV0dXJucyB0aGUgaW5kZXggb2YgdGhlIGN1cnJlbnQgbmV1cm9uIGluIGl0cyBsYXllciByYW5naW5nIGZyb20gMSB0byBudW1iZXIgb2Ygc3BlY2lmaWVkIG5ldXJvbnMgaW4gbGF5ZXIgKyAxIGJlY2F1c2UgYW4gZXh0cmEgYmlhcyBuZXVyb24gaXMgYWRkZWQgYXQgdGhlIGVuZCBvZiBuZXVyb25zIGFycmF5IGluIGEgbGF5ZXIgb2JqZWN0LlxuICAgICAgICAgKi9cbiAgICAgICAgTmV1cm9uLnByb3RvdHlwZS5nZXRJbmRleCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm9wdGlvbnMuaW5kZXg7XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBOZXVyb247XG4gICAgfSgpKTtcbiAgICB2YXIgV2VpZ2h0ID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZnVuY3Rpb24gV2VpZ2h0KHZhbHVlKSB7XG4gICAgICAgICAgICBpZiAodmFsdWUgPT09IHZvaWQgMCkgeyB2YWx1ZSA9IE1hdGgucmFuZG9tKCk7IH1cbiAgICAgICAgICAgIHRoaXMudmFsdWUgPSB2YWx1ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gV2VpZ2h0O1xuICAgIH0oKSk7XG4gICAgdmFyIE5ldHdvcmsgPSAoZnVuY3Rpb24gKCkge1xuICAgICAgICBmdW5jdGlvbiBOZXR3b3JrKG9wdGlvbnMpIHtcbiAgICAgICAgICAgIHRoaXMub3B0aW9ucyA9IG9wdGlvbnM7XG4gICAgICAgICAgICB0aGlzLmxheWVycyA9IFtdO1xuICAgICAgICAgICAgLy8gQ3JlYXRlIG5ldCdzIGxheWVyc1xuICAgICAgICAgICAgZm9yICh2YXIgbCA9IDA7IGwgPCBvcHRpb25zLmxheWVycy5sZW5ndGg7IGwrKykge1xuICAgICAgICAgICAgICAgIHRoaXMubGF5ZXJzLnB1c2gobmV3IExheWVyKHtcbiAgICAgICAgICAgICAgICAgICAgbmV0T3B0aW9uczogb3B0aW9ucyxcbiAgICAgICAgICAgICAgICAgICAgbnVtYmVyT2ZOZXVyb25zOiBvcHRpb25zLmxheWVyc1tsXSxcbiAgICAgICAgICAgICAgICAgICAgbnVtYmVyT2ZOZXVyb25zSW5OZXh0TGF5ZXI6IG9wdGlvbnMubGF5ZXJzW2wgKyAxXSB8fCAwXG4gICAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDcmVhdGVzIG5ldyBuZXR3b3JrIHdpdGggc3BlY2lmaWVkIHdlaWdodHNcbiAgICAgICAgICogQHBhcmFtIHdlaWdodERhdGEgcHJldmlvdXNseSBzYXZlZCB3ZWlnaHRzICh1c2luZyBOZXR3b3JrLmV4cG9ydFdlaWdodHMpXG4gICAgICAgICAqIEBwYXJhbSBvcHRpb25zIG5ldHdvcmsgb3B0aW9uc1xuICAgICAgICAgKi9cbiAgICAgICAgTmV0d29yay5yZXN0b3JlID0gZnVuY3Rpb24gKHdlaWdodERhdGEsIG9wdGlvbnMpIHtcbiAgICAgICAgICAgIHZhciBhbm4gPSBuZXcgTmV0d29yayhvcHRpb25zKTtcbiAgICAgICAgICAgIGZvciAodmFyIGwgPSAwOyBsIDwgd2VpZ2h0RGF0YS5sZW5ndGg7IGwrKykge1xuICAgICAgICAgICAgICAgIGZvciAodmFyIG4gPSAwOyBuIDwgd2VpZ2h0RGF0YVtsXS5sZW5ndGg7IG4rKykge1xuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciB3ID0gMDsgdyA8IHdlaWdodERhdGFbbF1bbl0ubGVuZ3RoOyB3KyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFubi5sYXllcnNbbF0ubmV1cm9uc1tuXS53ZWlnaHRzW3ddLnZhbHVlID0gd2VpZ2h0RGF0YVtsXVtuXVt3XTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBhbm47XG4gICAgICAgIH07XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShOZXR3b3JrLnByb3RvdHlwZSwgXCJpbnB1dExheWVyXCIsIHtcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogQHJldHVybnMgdGhlIGlucHV0IGxheWVyXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmxheWVyc1swXTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTmV0d29yay5wcm90b3R5cGUsIFwib3V0cHV0TGF5ZXJcIiwge1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBAcmV0dXJucyB0aGUgb3V0cHV0IGxheWVyXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmxheWVyc1t0aGlzLmxheWVycy5sZW5ndGggLSAxXTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICAgIH0pO1xuICAgICAgICAvKipcbiAgICAgICAgICogRm9yd2FyZCBQYXNzIG9mIHRoZSBuZXR3b3JrIHdoZXJlIHZhbHVlcyBhcmUgcHJvcGFnYXRlZCB0aHJvdWdoIHRoZSBuZXR3b3JrXG4gICAgICAgICAqIEBwYXJhbSBpbnB1dHMgaW5wdXQgdmFsdWVzIG1hdGNoaW5nIHRoZSBzcGVjaWZpZWQgc2l6ZSBvZiB0aGUgbmV0d29yaydzIGlucHV0IGxheWVyXG4gICAgICAgICAqL1xuICAgICAgICBOZXR3b3JrLnByb3RvdHlwZS5wcm9wYWdhdGVGb3J3YXJkID0gZnVuY3Rpb24gKGlucHV0cykge1xuICAgICAgICAgICAgaWYgKGlucHV0cy5sZW5ndGggIT0gdGhpcy5pbnB1dExheWVyLm5ldXJvbnMubGVuZ3RoIC0gMSkge1xuICAgICAgICAgICAgICAgIHRocm93IFwiSW5wdXRzIGRvIG5vdCBtYXRjaCBuZXR3b3JrIHNpemUhXCI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBTZXQgaW5wdXQgbGF5ZXIgbmV1cm9ucyBvdXRwdXQgdG8gaW5wdXQgdmFsdWVzOyBleGNsdWRlIGJpYXMgb2YgY291cnNlXG4gICAgICAgICAgICB0aGlzLmlucHV0TGF5ZXIuZm9yRWFjaE5ldXJvbihmdW5jdGlvbiAobiwgaSkgeyByZXR1cm4gbi5vdXRwdXQgPSBpbnB1dHNbaV07IH0sIHRydWUpO1xuICAgICAgICAgICAgdmFyIF9sb29wXzEgPSBmdW5jdGlvbiAobCkge1xuICAgICAgICAgICAgICAgIHZhciBsYXllciA9IHRoaXNfMS5sYXllcnNbbF07XG4gICAgICAgICAgICAgICAgdmFyIHByZXZMYXllciA9IHRoaXNfMS5sYXllcnNbbCAtIDFdO1xuICAgICAgICAgICAgICAgIGxheWVyLmZvckVhY2hOZXVyb24oZnVuY3Rpb24gKG4pIHsgcmV0dXJuIG4ucHJvcGFnYXRlRm9yd2FyZChwcmV2TGF5ZXIpOyB9LCB0cnVlKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICB2YXIgdGhpc18xID0gdGhpcztcbiAgICAgICAgICAgIC8vIHByb3BhZ2F0ZSB2YWx1ZXMgZm9yd2FyZCB0aHJvdWdoIGxheWVyIHN0YXJ0aW5nIGZyb20gZmlyc3QgaGlkZGVuIGxheWVyXG4gICAgICAgICAgICBmb3IgKHZhciBsID0gMTsgbCA8IHRoaXMubGF5ZXJzLmxlbmd0aDsgbCsrKSB7XG4gICAgICAgICAgICAgICAgX2xvb3BfMShsKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogQHJldHVybnMgdGhlIGN1cnJlbnQgb3V0cHV0IG9mIHRoZSBuZXR3b3JrXG4gICAgICAgICAqL1xuICAgICAgICBOZXR3b3JrLnByb3RvdHlwZS5nZXRDdXJyZW50T3V0cHV0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMub3V0cHV0TGF5ZXIubmV1cm9ucy5tYXAoZnVuY3Rpb24gKG4pIHsgcmV0dXJuIG4ub3V0cHV0OyB9KS5zbGljZSgwLCAtMSk7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDYWxjdWxhdGUgYWxsIHRoZSBuZXVyb25zIGRlbHRhIHZhbHVlc1xuICAgICAgICAgKiBAcGFyYW0gdGFyZ2V0VmFsdWVzIHRhcmdldCB2YWx1ZXMgZm9yIHRoZSBuZXR3b3JrIHdpdGggcmVzcGVjdCB0byBsYXN0IGZvcndhcmQgcGFzc1xuICAgICAgICAgKi9cbiAgICAgICAgTmV0d29yay5wcm90b3R5cGUuY2FsY3VsYXRlRGVsdGFzID0gZnVuY3Rpb24gKHRhcmdldFZhbHVlcykge1xuICAgICAgICAgICAgLy8gY2FsY3VsYXRlIE91dHB1dCBsYXllciBjYWxjdWxhdGVEZWx0YXNcbiAgICAgICAgICAgIHRoaXMub3V0cHV0TGF5ZXIuZm9yRWFjaE5ldXJvbihmdW5jdGlvbiAobiwgaSkgeyByZXR1cm4gbi5jYWxjdWxhdGVPdXRwdXRMYXllckRlbHRhKHRhcmdldFZhbHVlc1tpXSk7IH0sIHRydWUpO1xuICAgICAgICAgICAgdmFyIF9sb29wXzIgPSBmdW5jdGlvbiAobCkge1xuICAgICAgICAgICAgICAgIHZhciBsYXllciA9IHRoaXNfMi5sYXllcnNbbF07XG4gICAgICAgICAgICAgICAgdmFyIG5leHRMYXllciA9IHRoaXNfMi5sYXllcnNbbCArIDFdO1xuICAgICAgICAgICAgICAgIGxheWVyLmZvckVhY2hOZXVyb24oZnVuY3Rpb24gKG4pIHsgcmV0dXJuIG4uY2FsY3VsYXRlSGlkZGVuTGF5ZXJEZWx0YShuZXh0TGF5ZXIpOyB9LCB0cnVlKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICB2YXIgdGhpc18yID0gdGhpcztcbiAgICAgICAgICAgIC8vIHByb3BhZ2F0ZSBlcnJvciBiYWNrd2FyZHMgdGhyb3VnaCBoaWRkZW4gbGF5ZXJzXG4gICAgICAgICAgICBmb3IgKHZhciBsID0gdGhpcy5sYXllcnMubGVuZ3RoIC0gMjsgbCA+IDA7IGwtLSkge1xuICAgICAgICAgICAgICAgIF9sb29wXzIobCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFVwZGF0ZSB0aGUgY29ubmVjdGlvbiB3ZWlnaHRzIHVzaW5nIHByZXZpb3VzIGNhbGN1bGF0ZWQgZGVsdGEgdmFsdWVzXG4gICAgICAgICAqL1xuICAgICAgICBOZXR3b3JrLnByb3RvdHlwZS51cGRhdGVXZWlnaHRzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIF9sb29wXzMgPSBmdW5jdGlvbiAobCkge1xuICAgICAgICAgICAgICAgIHZhciBsYXllciA9IHRoaXNfMy5sYXllcnNbbF07XG4gICAgICAgICAgICAgICAgdmFyIHByZXZMYXllciA9IHRoaXNfMy5sYXllcnNbbCAtIDFdO1xuICAgICAgICAgICAgICAgIGxheWVyLmZvckVhY2hOZXVyb24oZnVuY3Rpb24gKG4pIHsgcmV0dXJuIG4udXBkYXRlV2VpZ2h0cyhwcmV2TGF5ZXIpOyB9LCB0cnVlKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICB2YXIgdGhpc18zID0gdGhpcztcbiAgICAgICAgICAgIC8vIGdvIHRocm91Z2ggYWxsIGxheWVycyBleGNlcHQgaW5wdXQgbGF5ZXIgYW5kIHVwZGF0ZSBhbGwgdGhlIHdlaWdodHMgd2l0aCB0aGUgY2FsY3VsYXRlZCBkZWx0YVZhbHVlcy5cbiAgICAgICAgICAgIGZvciAodmFyIGwgPSAxOyBsIDwgdGhpcy5sYXllcnMubGVuZ3RoOyBsKyspIHtcbiAgICAgICAgICAgICAgICBfbG9vcF8zKGwpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBGaXRzIGdpdmVuIGlucHV0cyB0byBnaXZlbiB0YXJnZXQgdmFsdWVzIGJ5IHRyYWluaW5nIHRoZSBuZXR3b3JrXG4gICAgICAgICAqIEBwYXJhbSBpbnB1dHMgaW5wdXRzIHRvIHRoZSBuZXR3b3JrXG4gICAgICAgICAqIEBwYXJhbSB0YXJnZXRWYWx1ZXMgZXhwZWN0ZWQgb3V0cHV0cyBmb3IgZ2l2ZW4gaW5wdXRcbiAgICAgICAgICovXG4gICAgICAgIE5ldHdvcmsucHJvdG90eXBlLmZpdCA9IGZ1bmN0aW9uIChpbnB1dHMsIHRhcmdldFZhbHVlcykge1xuICAgICAgICAgICAgdGhpcy5wcm9wYWdhdGVGb3J3YXJkKGlucHV0cykuY2FsY3VsYXRlRGVsdGFzKHRhcmdldFZhbHVlcykudXBkYXRlV2VpZ2h0cygpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBQcmVkaWN0IG91dHB1dCB2YWx1ZXMgZm9yIGdpdmVuIGlucHV0c1xuICAgICAgICAgKiBAcGFyYW0gaW5wdXRzIGlucHV0IHZhbHVlc1xuICAgICAgICAgKi9cbiAgICAgICAgTmV0d29yay5wcm90b3R5cGUucHJlZGljdCA9IGZ1bmN0aW9uIChpbnB1dHMpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnByb3BhZ2F0ZUZvcndhcmQoaW5wdXRzKS5nZXRDdXJyZW50T3V0cHV0KCk7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDYWxjdWxhdGUgdGhlIGVycm9yIGZvciBjdXJyZW50IG91dHB1dHNcbiAgICAgICAgICogQHBhcmFtIHRhcmdldFZhbHVlcyB0YXJnZXQgdmFsdWVzXG4gICAgICAgICAqL1xuICAgICAgICBOZXR3b3JrLnByb3RvdHlwZS5nZXRDdXJyZW50RXJyb3IgPSBmdW5jdGlvbiAodGFyZ2V0VmFsdWVzKSB7XG4gICAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZ2V0Q3VycmVudE91dHB1dCgpLnJlZHVjZShmdW5jdGlvbiAocywgbywgaSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBzICsgX3RoaXMub3B0aW9ucy5lcnJvckZ1bmN0aW9uLmVycm9yKG8sIHRhcmdldFZhbHVlc1tpXSk7XG4gICAgICAgICAgICB9LCAwKTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIENhbGN1bGF0ZXMgdGhlIGVycm9yIGZvciBnaXZlbiBpbnB1dHNcbiAgICAgICAgICogQHBhcmFtIGlucHV0cyBpbnB1dHMgdG8gbmV0d29ya1xuICAgICAgICAgKiBAcGFyYW0gdGFyZ2V0VmFsdWVzIGV4cGVjdGVkIG91dHB1dCBmb3IgZ2l2ZW4gaW5wdXRzXG4gICAgICAgICAqL1xuICAgICAgICBOZXR3b3JrLnByb3RvdHlwZS5lcnJvciA9IGZ1bmN0aW9uIChpbnB1dHMsIHRhcmdldFZhbHVlcykge1xuICAgICAgICAgICAgdGhpcy5wcm9wYWdhdGVGb3J3YXJkKGlucHV0cyk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5nZXRDdXJyZW50RXJyb3IodGFyZ2V0VmFsdWVzKTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEV4cG9ydCB0aGUgY3VycmVudCB3ZWlnaHRzIG9mIHRoZSBuZXR3b3JrXG4gICAgICAgICAqL1xuICAgICAgICBOZXR3b3JrLnByb3RvdHlwZS5leHBvcnRXZWlnaHRzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIGRhdGEgPSBbXTtcbiAgICAgICAgICAgIGZvciAodmFyIGwgPSAwOyBsIDwgdGhpcy5sYXllcnMubGVuZ3RoIC0gMTsgbCsrKSB7XG4gICAgICAgICAgICAgICAgdmFyIGxheWVyID0gdGhpcy5sYXllcnNbbF07XG4gICAgICAgICAgICAgICAgdmFyIGxheWVyRGF0YSA9IGxheWVyLm5ldXJvbnMubWFwKGZ1bmN0aW9uIChuKSB7IHJldHVybiBuLndlaWdodHMubWFwKGZ1bmN0aW9uICh3KSB7IHJldHVybiB3LnZhbHVlOyB9KTsgfSk7XG4gICAgICAgICAgICAgICAgZGF0YS5wdXNoKGxheWVyRGF0YSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZGF0YTtcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIE5ldHdvcms7XG4gICAgfSgpKTtcbiAgICBGZWVkRm9yd2FyZC5OZXR3b3JrID0gTmV0d29yaztcbn0pKEZlZWRGb3J3YXJkID0gZXhwb3J0cy5GZWVkRm9yd2FyZCB8fCAoZXhwb3J0cy5GZWVkRm9yd2FyZCA9IHt9KSk7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL3NyYy9OZXVyYWxOZXR3b3Jrcy9hbm4udHNcbi8vIG1vZHVsZSBpZCA9IDFcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTsiLCJzb3VyY2VSb290IjoiIn0=");

/***/ }),
/* 2 */
/* unknown exports provided */
/* all exports used */
/*!**********************************************!*\
  !*** ./src/NeuralNetworks/errorFunctions.ts ***!
  \**********************************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar Errors = (function () {\n    function Errors() {\n    }\n    return Errors;\n}());\nErrors.SQUARE = {\n    error: function (output, target) { return 0.5 * Math.pow(output - target, 2); },\n    der: function (output, target) { return output - target; }\n};\nErrors.CROSS_ENTROPY = {\n    error: function (output, target) {\n        return -(target * Math.log(output) + (1 - target) * Math.log(1 - output));\n    },\n    der: function (output, target) {\n        return (output - target) / ((1 - output) * output);\n    }\n};\nexports.Errors = Errors;\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMi5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL3NyYy9OZXVyYWxOZXR3b3Jrcy9lcnJvckZ1bmN0aW9ucy50cz9kYzkzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIEVycm9ycyA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gRXJyb3JzKCkge1xuICAgIH1cbiAgICByZXR1cm4gRXJyb3JzO1xufSgpKTtcbkVycm9ycy5TUVVBUkUgPSB7XG4gICAgZXJyb3I6IGZ1bmN0aW9uIChvdXRwdXQsIHRhcmdldCkgeyByZXR1cm4gMC41ICogTWF0aC5wb3cob3V0cHV0IC0gdGFyZ2V0LCAyKTsgfSxcbiAgICBkZXI6IGZ1bmN0aW9uIChvdXRwdXQsIHRhcmdldCkgeyByZXR1cm4gb3V0cHV0IC0gdGFyZ2V0OyB9XG59O1xuRXJyb3JzLkNST1NTX0VOVFJPUFkgPSB7XG4gICAgZXJyb3I6IGZ1bmN0aW9uIChvdXRwdXQsIHRhcmdldCkge1xuICAgICAgICByZXR1cm4gLSh0YXJnZXQgKiBNYXRoLmxvZyhvdXRwdXQpICsgKDEgLSB0YXJnZXQpICogTWF0aC5sb2coMSAtIG91dHB1dCkpO1xuICAgIH0sXG4gICAgZGVyOiBmdW5jdGlvbiAob3V0cHV0LCB0YXJnZXQpIHtcbiAgICAgICAgcmV0dXJuIChvdXRwdXQgLSB0YXJnZXQpIC8gKCgxIC0gb3V0cHV0KSAqIG91dHB1dCk7XG4gICAgfVxufTtcbmV4cG9ydHMuRXJyb3JzID0gRXJyb3JzO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9zcmMvTmV1cmFsTmV0d29ya3MvZXJyb3JGdW5jdGlvbnMudHNcbi8vIG1vZHVsZSBpZCA9IDJcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOyIsInNvdXJjZVJvb3QiOiIifQ==");

/***/ }),
/* 3 */,
/* 4 */
/* unknown exports provided */
/* all exports used */
/*!********************!*\
  !*** ./src/knn.ts ***!
  \********************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar KNNClassifier = (function () {\n    function KNNClassifier(k) {\n        if (k === void 0) { k = 3; }\n        this.k = k;\n        this.data = [];\n        return this;\n    }\n    KNNClassifier.prototype.addData = function (classes, data) {\n        var _this = this;\n        classes.forEach(function (c, i) {\n            _this.data.push({\n                c: c,\n                attr: data[i]\n            });\n        });\n        return this;\n    };\n    KNNClassifier.prototype.predict = function (input, c2v) {\n        var _this = this;\n        var distances = [];\n        // Calculate distances\n        this.data.forEach(function (entry, i) {\n            return distances.push({\n                index: i,\n                distance: _this.distance(input, entry.attr)\n            });\n        });\n        // Sort distances\n        distances = distances.sort(function (a, b) {\n            if (a.distance > b.distance)\n                return 1;\n            if (a.distance < b.distance)\n                return -1;\n            return 0;\n        });\n        // get k smallest distances\n        var kNearest = distances.slice(0, this.k);\n        // get classes to those k distances from data array\n        var kNearestClasses = kNearest.map(function (e) { return _this.data[e.index].c; });\n        // get the most often occurring class\n        var c = this.argMax(kNearestClasses);\n        // return value or class if c2v is passed\n        return c2v ? c2v.toClass(c) : c;\n    };\n    KNNClassifier.prototype.argMax = function (args) {\n        var record = {};\n        args.forEach(function (a) { return record[a] = record[a] + 1 || 1; });\n        var max = record[args[0]];\n        var arg = args[0];\n        for (var _i = 0, args_1 = args; _i < args_1.length; _i++) {\n            var key = args_1[_i];\n            if (record[key] > max) {\n                max = record[key];\n                arg = key;\n            }\n        }\n        return arg;\n    };\n    KNNClassifier.prototype.distance = function (a, b) {\n        var sigma = 0;\n        for (var i = 0; i < a.length; i++) {\n            sigma += Math.pow(a[i] - b[i], 2);\n        }\n        return Math.sqrt(sigma);\n    };\n    return KNNClassifier;\n}());\nexports.KNNClassifier = KNNClassifier;\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNC5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL3NyYy9rbm4udHM/MDNiNyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBLTk5DbGFzc2lmaWVyID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBLTk5DbGFzc2lmaWVyKGspIHtcbiAgICAgICAgaWYgKGsgPT09IHZvaWQgMCkgeyBrID0gMzsgfVxuICAgICAgICB0aGlzLmsgPSBrO1xuICAgICAgICB0aGlzLmRhdGEgPSBbXTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIEtOTkNsYXNzaWZpZXIucHJvdG90eXBlLmFkZERhdGEgPSBmdW5jdGlvbiAoY2xhc3NlcywgZGF0YSkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICBjbGFzc2VzLmZvckVhY2goZnVuY3Rpb24gKGMsIGkpIHtcbiAgICAgICAgICAgIF90aGlzLmRhdGEucHVzaCh7XG4gICAgICAgICAgICAgICAgYzogYyxcbiAgICAgICAgICAgICAgICBhdHRyOiBkYXRhW2ldXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG4gICAgS05OQ2xhc3NpZmllci5wcm90b3R5cGUucHJlZGljdCA9IGZ1bmN0aW9uIChpbnB1dCwgYzJ2KSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHZhciBkaXN0YW5jZXMgPSBbXTtcbiAgICAgICAgLy8gQ2FsY3VsYXRlIGRpc3RhbmNlc1xuICAgICAgICB0aGlzLmRhdGEuZm9yRWFjaChmdW5jdGlvbiAoZW50cnksIGkpIHtcbiAgICAgICAgICAgIHJldHVybiBkaXN0YW5jZXMucHVzaCh7XG4gICAgICAgICAgICAgICAgaW5kZXg6IGksXG4gICAgICAgICAgICAgICAgZGlzdGFuY2U6IF90aGlzLmRpc3RhbmNlKGlucHV0LCBlbnRyeS5hdHRyKVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgICAgICAvLyBTb3J0IGRpc3RhbmNlc1xuICAgICAgICBkaXN0YW5jZXMgPSBkaXN0YW5jZXMuc29ydChmdW5jdGlvbiAoYSwgYikge1xuICAgICAgICAgICAgaWYgKGEuZGlzdGFuY2UgPiBiLmRpc3RhbmNlKVxuICAgICAgICAgICAgICAgIHJldHVybiAxO1xuICAgICAgICAgICAgaWYgKGEuZGlzdGFuY2UgPCBiLmRpc3RhbmNlKVxuICAgICAgICAgICAgICAgIHJldHVybiAtMTtcbiAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICB9KTtcbiAgICAgICAgLy8gZ2V0IGsgc21hbGxlc3QgZGlzdGFuY2VzXG4gICAgICAgIHZhciBrTmVhcmVzdCA9IGRpc3RhbmNlcy5zbGljZSgwLCB0aGlzLmspO1xuICAgICAgICAvLyBnZXQgY2xhc3NlcyB0byB0aG9zZSBrIGRpc3RhbmNlcyBmcm9tIGRhdGEgYXJyYXlcbiAgICAgICAgdmFyIGtOZWFyZXN0Q2xhc3NlcyA9IGtOZWFyZXN0Lm1hcChmdW5jdGlvbiAoZSkgeyByZXR1cm4gX3RoaXMuZGF0YVtlLmluZGV4XS5jOyB9KTtcbiAgICAgICAgLy8gZ2V0IHRoZSBtb3N0IG9mdGVuIG9jY3VycmluZyBjbGFzc1xuICAgICAgICB2YXIgYyA9IHRoaXMuYXJnTWF4KGtOZWFyZXN0Q2xhc3Nlcyk7XG4gICAgICAgIC8vIHJldHVybiB2YWx1ZSBvciBjbGFzcyBpZiBjMnYgaXMgcGFzc2VkXG4gICAgICAgIHJldHVybiBjMnYgPyBjMnYudG9DbGFzcyhjKSA6IGM7XG4gICAgfTtcbiAgICBLTk5DbGFzc2lmaWVyLnByb3RvdHlwZS5hcmdNYXggPSBmdW5jdGlvbiAoYXJncykge1xuICAgICAgICB2YXIgcmVjb3JkID0ge307XG4gICAgICAgIGFyZ3MuZm9yRWFjaChmdW5jdGlvbiAoYSkgeyByZXR1cm4gcmVjb3JkW2FdID0gcmVjb3JkW2FdICsgMSB8fCAxOyB9KTtcbiAgICAgICAgdmFyIG1heCA9IHJlY29yZFthcmdzWzBdXTtcbiAgICAgICAgdmFyIGFyZyA9IGFyZ3NbMF07XG4gICAgICAgIGZvciAodmFyIF9pID0gMCwgYXJnc18xID0gYXJnczsgX2kgPCBhcmdzXzEubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgICB2YXIga2V5ID0gYXJnc18xW19pXTtcbiAgICAgICAgICAgIGlmIChyZWNvcmRba2V5XSA+IG1heCkge1xuICAgICAgICAgICAgICAgIG1heCA9IHJlY29yZFtrZXldO1xuICAgICAgICAgICAgICAgIGFyZyA9IGtleTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYXJnO1xuICAgIH07XG4gICAgS05OQ2xhc3NpZmllci5wcm90b3R5cGUuZGlzdGFuY2UgPSBmdW5jdGlvbiAoYSwgYikge1xuICAgICAgICB2YXIgc2lnbWEgPSAwO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGEubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHNpZ21hICs9IE1hdGgucG93KGFbaV0gLSBiW2ldLCAyKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gTWF0aC5zcXJ0KHNpZ21hKTtcbiAgICB9O1xuICAgIHJldHVybiBLTk5DbGFzc2lmaWVyO1xufSgpKTtcbmV4cG9ydHMuS05OQ2xhc3NpZmllciA9IEtOTkNsYXNzaWZpZXI7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL3NyYy9rbm4udHNcbi8vIG1vZHVsZSBpZCA9IDRcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTsiLCJzb3VyY2VSb290IjoiIn0=");

/***/ }),
/* 5 */
/* unknown exports provided */
/* all exports used */
/*!***********************!*\
  !*** ./src/matrix.ts ***!
  \***********************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar Matrix = (function () {\n    function Matrix(p1, p2) {\n        if (typeof p1 == 'object') {\n            this.data = p1;\n        }\n        else {\n            this.data = Matrix.get2DArray(p1, p2);\n        }\n    }\n    Matrix.get2DArray = function (m, n, fill) {\n        if (fill === void 0) { fill = 0; }\n        return new Array(m).fill(0).map(function (r) { return new Array(n).fill(fill); });\n    };\n    Matrix.rowVector = function () {\n        var components = [];\n        for (var _i = 0; _i < arguments.length; _i++) {\n            components[_i] = arguments[_i];\n        }\n        return new Matrix([components]);\n    };\n    Matrix.columnVector = function () {\n        var components = [];\n        for (var _i = 0; _i < arguments.length; _i++) {\n            components[_i] = arguments[_i];\n        }\n        var v = components.map(function (c) { return [c]; });\n        return new Matrix(v);\n    };\n    Matrix.rand = function (rows, columns) {\n        var m = new Matrix(rows, columns);\n        m.map(function (v) { return Math.random(); });\n        return m;\n    };\n    Matrix.ones = function (rows, columns) {\n        var m = new Matrix(rows, columns);\n        m.fill(1);\n        return m;\n    };\n    Matrix.eye = function (size) {\n        var m = new Matrix(size, size);\n        for (var i = 0; i < size; i++)\n            m.set(i, i, 1);\n        return m;\n    };\n    Matrix.join = function (m1, m2, pos) {\n        if (pos === void 0) { pos = 'bottom'; }\n        var newData;\n        switch (pos) {\n            case 'top':\n                newData = m2.data.concat(m1.data);\n                break;\n            case 'bottom':\n                newData = m1.data.concat(m2.data);\n                break;\n            case 'left':\n                newData = m1.data.map(function (r, i) { return m2.data[i].concat(r); });\n                break;\n            case 'right':\n                newData = m1.data.map(function (r, i) { return r.concat(m2.data[i]); });\n                break;\n            default:\n                break;\n        }\n        return new Matrix(newData);\n    };\n    Matrix.prototype.getNumberOfRows = function () {\n        return this.data.length;\n    };\n    Matrix.prototype.getNumberOfColumns = function () {\n        return this.data[0].length;\n    };\n    Matrix.prototype.getDimensions = function () {\n        return [this.getNumberOfRows(), this.getNumberOfColumns()];\n    };\n    Matrix.prototype.set = function (row, column, val) {\n        this.data[row][column] = val;\n    };\n    Matrix.prototype.get = function (row, column) {\n        return this.data[row][column];\n    };\n    Matrix.prototype.getRowAsRowVector = function (row) {\n        // Copy without reference\n        var v = new Matrix([this.data[row].slice()]);\n        return v;\n    };\n    Matrix.prototype.getColumnAsRowVector = function (column) {\n        // Copy without reference\n        var v = [];\n        for (var _i = 0, _a = this.data; _i < _a.length; _i++) {\n            var row = _a[_i];\n            v.push(row[column]);\n        }\n        return new Matrix([v]);\n    };\n    Matrix.prototype.getAsScalar = function () {\n        if (this.getDimensions().every(function (d) { return d == 1; })) {\n            return this.get(0, 0);\n        }\n        else {\n            this.error('size', 'getAsFloat (matrix must be 1x1)');\n        }\n    };\n    Matrix.prototype.getArray = function () {\n        // Deep copy without reference\n        return this.data.map(function (r) { return r.slice(); });\n    };\n    Matrix.prototype.copy = function () {\n        return new Matrix(this.getArray());\n    };\n    // endRow and endColumn exclusive if positive\n    // startRow and startColumn exclusive if negative\n    Matrix.prototype.slice = function (startRow, endRow, startColumn, endColumn) {\n        //Handle negatives\n        if (endRow < 0) {\n            endRow = this.getNumberOfRows() + (endRow + 1);\n        }\n        if (startRow < 0) {\n            startRow = this.getNumberOfRows() + (startRow + 1);\n        }\n        if (endColumn < 0) {\n            endColumn = this.getNumberOfColumns() + (endColumn + 1);\n        }\n        if (startColumn < 0) {\n            startColumn = this.getNumberOfColumns() + (startColumn + 1);\n        }\n        var res = new Matrix(endRow - startRow, endColumn - startColumn);\n        for (var row = startRow; row < endRow; row++) {\n            for (var column = startColumn; column < endColumn; column++) {\n                res.set(row - startRow, column - startColumn, this.get(row, column));\n            }\n        }\n        return res;\n    };\n    Matrix.prototype.map = function (func) {\n        for (var i = 0; i < this.getNumberOfRows(); i++) {\n            for (var j = 0; j < this.getNumberOfColumns(); j++) {\n                this.data[i][j] = func(this.data[i][j], i, j);\n            }\n        }\n        return this;\n    };\n    Matrix.prototype.forEach = function (func) {\n        for (var i = 0; i < this.getNumberOfRows(); i++) {\n            for (var j = 0; j < this.getNumberOfColumns(); j++) {\n                func(this.data[i][j], i, j);\n            }\n        }\n        return this;\n    };\n    Matrix.prototype.fill = function (newVal) {\n        this.map(function (v) { return newVal; });\n    };\n    Matrix.prototype.scale = function (scl) {\n        return this.map(function (v) { return v * scl; });\n    };\n    Matrix.prototype.add = function (m) {\n        if (!this.hasSameDimensions(m))\n            this.error('size', 'addition');\n        return this.map(function (v, row, col) { return v + m.get(row, col); });\n    };\n    Matrix.prototype.subtract = function (m) {\n        if (!this.hasSameDimensions(m))\n            this.error('size', 'subtraction');\n        return this.map(function (v, row, col) { return v - m.get(row, col); });\n    };\n    Matrix.prototype.multiply = function (m) {\n        if (!this.hasSameDimensions(m))\n            this.error('size', 'multiplication');\n        return this.map(function (v, row, col) { return v * m.get(row, col); });\n    };\n    Matrix.prototype.divide = function (m) {\n        if (!this.hasSameDimensions(m))\n            this.error('size', 'division');\n        return this.map(function (v, row, col) { return v / m.get(row, col); });\n    };\n    Matrix.prototype.dot = function (m) {\n        if (!(this.getNumberOfColumns() == m.getNumberOfRows()))\n            this.error('size', 'dot product');\n        var newData = Matrix.get2DArray(this.getNumberOfRows(), m.getNumberOfColumns());\n        for (var v = 0; v < m.getNumberOfColumns(); v++) {\n            for (var r = 0; r < this.getNumberOfRows(); r++) {\n                for (var i = 0; i < m.getNumberOfRows(); i++) {\n                    newData[r][v] += m.get(i, v) * this.get(r, i);\n                }\n            }\n        }\n        this.data = newData;\n        return this;\n    };\n    Matrix.prototype.transpose = function () {\n        var newData = Matrix.get2DArray(this.getNumberOfColumns(), this.getNumberOfRows());\n        this.forEach(function (v, row, col) {\n            newData[col][row] = v;\n        });\n        this.data = newData;\n        return this;\n    };\n    Matrix.prototype.min = function () {\n        var minValues = [];\n        for (var c = 0; c < this.getNumberOfColumns(); c++) {\n            var column = this.getColumnAsRowVector(c).getArray()[0];\n            minValues.push(Math.min.apply(Math, column));\n        }\n        return Matrix.rowVector.apply(Matrix, minValues);\n    };\n    Matrix.prototype.max = function () {\n        var maxValues = [];\n        for (var c = 0; c < this.getNumberOfColumns(); c++) {\n            var column = this.getColumnAsRowVector(c).getArray()[0];\n            maxValues.push(Math.max.apply(Math, column));\n        }\n        return Matrix.rowVector.apply(Matrix, maxValues);\n    };\n    Matrix.prototype.hasSameDimensions = function (m) {\n        if (m.getNumberOfColumns() == this.getNumberOfColumns() && m.getNumberOfRows() == this.getNumberOfRows()) {\n            return true;\n        }\n        else {\n            return false;\n        }\n    };\n    Matrix.prototype.error = function (code, operation) {\n        switch (code) {\n            case 'size':\n                throw \"Matrices not not have the right sizes for operation \" + operation;\n            default:\n                throw \"Error!\";\n        }\n    };\n    Matrix.prototype.show = function () {\n        console.log(this.getAsString());\n        return this;\n    };\n    Matrix.prototype.getAsString = function (markup, joinChar, lineSpaceChar, end, fixed) {\n        var _this = this;\n        if (markup === void 0) { markup = true; }\n        if (joinChar === void 0) { joinChar = '\\t'; }\n        if (lineSpaceChar === void 0) { lineSpaceChar = ' '; }\n        if (end === void 0) { end = '\\n'; }\n        if (fixed === void 0) { fixed = 3; }\n        if (!markup) {\n            return this.data.map(function (r) { return r.map(function (n) { return n.toFixed(fixed); }).join('\\t'); }).join('\\n') + end;\n        }\n        else {\n            return this.data.map(function (r, i) {\n                var middlePart = r.map(function (n) { return n.toFixed(fixed); }).join(joinChar);\n                if (i == 0 && _this.data.length == 1) {\n                    return \"[\" + lineSpaceChar + middlePart + lineSpaceChar + \"]\";\n                }\n                else if (i == 0) {\n                    return \"\\u23A1\" + lineSpaceChar + middlePart + lineSpaceChar + \"\\u23A4\";\n                }\n                else if (i == _this.data.length - 1) {\n                    return \"\\u23A3\" + lineSpaceChar + middlePart + lineSpaceChar + \"\\u23A6\";\n                }\n                else {\n                    return \"\\u239C\" + lineSpaceChar + middlePart + lineSpaceChar + \"\\u239F\";\n                }\n            }).join('\\n') + end;\n        }\n    };\n    return Matrix;\n}());\nexports.Matrix = Matrix;\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNS5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL3NyYy9tYXRyaXgudHM/ZGM4NCJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBNYXRyaXggPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIE1hdHJpeChwMSwgcDIpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBwMSA9PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgdGhpcy5kYXRhID0gcDE7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmRhdGEgPSBNYXRyaXguZ2V0MkRBcnJheShwMSwgcDIpO1xuICAgICAgICB9XG4gICAgfVxuICAgIE1hdHJpeC5nZXQyREFycmF5ID0gZnVuY3Rpb24gKG0sIG4sIGZpbGwpIHtcbiAgICAgICAgaWYgKGZpbGwgPT09IHZvaWQgMCkgeyBmaWxsID0gMDsgfVxuICAgICAgICByZXR1cm4gbmV3IEFycmF5KG0pLmZpbGwoMCkubWFwKGZ1bmN0aW9uIChyKSB7IHJldHVybiBuZXcgQXJyYXkobikuZmlsbChmaWxsKTsgfSk7XG4gICAgfTtcbiAgICBNYXRyaXgucm93VmVjdG9yID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgY29tcG9uZW50cyA9IFtdO1xuICAgICAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgYXJndW1lbnRzLmxlbmd0aDsgX2krKykge1xuICAgICAgICAgICAgY29tcG9uZW50c1tfaV0gPSBhcmd1bWVudHNbX2ldO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgTWF0cml4KFtjb21wb25lbnRzXSk7XG4gICAgfTtcbiAgICBNYXRyaXguY29sdW1uVmVjdG9yID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgY29tcG9uZW50cyA9IFtdO1xuICAgICAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgYXJndW1lbnRzLmxlbmd0aDsgX2krKykge1xuICAgICAgICAgICAgY29tcG9uZW50c1tfaV0gPSBhcmd1bWVudHNbX2ldO1xuICAgICAgICB9XG4gICAgICAgIHZhciB2ID0gY29tcG9uZW50cy5tYXAoZnVuY3Rpb24gKGMpIHsgcmV0dXJuIFtjXTsgfSk7XG4gICAgICAgIHJldHVybiBuZXcgTWF0cml4KHYpO1xuICAgIH07XG4gICAgTWF0cml4LnJhbmQgPSBmdW5jdGlvbiAocm93cywgY29sdW1ucykge1xuICAgICAgICB2YXIgbSA9IG5ldyBNYXRyaXgocm93cywgY29sdW1ucyk7XG4gICAgICAgIG0ubWFwKGZ1bmN0aW9uICh2KSB7IHJldHVybiBNYXRoLnJhbmRvbSgpOyB9KTtcbiAgICAgICAgcmV0dXJuIG07XG4gICAgfTtcbiAgICBNYXRyaXgub25lcyA9IGZ1bmN0aW9uIChyb3dzLCBjb2x1bW5zKSB7XG4gICAgICAgIHZhciBtID0gbmV3IE1hdHJpeChyb3dzLCBjb2x1bW5zKTtcbiAgICAgICAgbS5maWxsKDEpO1xuICAgICAgICByZXR1cm4gbTtcbiAgICB9O1xuICAgIE1hdHJpeC5leWUgPSBmdW5jdGlvbiAoc2l6ZSkge1xuICAgICAgICB2YXIgbSA9IG5ldyBNYXRyaXgoc2l6ZSwgc2l6ZSk7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc2l6ZTsgaSsrKVxuICAgICAgICAgICAgbS5zZXQoaSwgaSwgMSk7XG4gICAgICAgIHJldHVybiBtO1xuICAgIH07XG4gICAgTWF0cml4LmpvaW4gPSBmdW5jdGlvbiAobTEsIG0yLCBwb3MpIHtcbiAgICAgICAgaWYgKHBvcyA9PT0gdm9pZCAwKSB7IHBvcyA9ICdib3R0b20nOyB9XG4gICAgICAgIHZhciBuZXdEYXRhO1xuICAgICAgICBzd2l0Y2ggKHBvcykge1xuICAgICAgICAgICAgY2FzZSAndG9wJzpcbiAgICAgICAgICAgICAgICBuZXdEYXRhID0gbTIuZGF0YS5jb25jYXQobTEuZGF0YSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdib3R0b20nOlxuICAgICAgICAgICAgICAgIG5ld0RhdGEgPSBtMS5kYXRhLmNvbmNhdChtMi5kYXRhKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ2xlZnQnOlxuICAgICAgICAgICAgICAgIG5ld0RhdGEgPSBtMS5kYXRhLm1hcChmdW5jdGlvbiAociwgaSkgeyByZXR1cm4gbTIuZGF0YVtpXS5jb25jYXQocik7IH0pO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAncmlnaHQnOlxuICAgICAgICAgICAgICAgIG5ld0RhdGEgPSBtMS5kYXRhLm1hcChmdW5jdGlvbiAociwgaSkgeyByZXR1cm4gci5jb25jYXQobTIuZGF0YVtpXSk7IH0pO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IE1hdHJpeChuZXdEYXRhKTtcbiAgICB9O1xuICAgIE1hdHJpeC5wcm90b3R5cGUuZ2V0TnVtYmVyT2ZSb3dzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5kYXRhLmxlbmd0aDtcbiAgICB9O1xuICAgIE1hdHJpeC5wcm90b3R5cGUuZ2V0TnVtYmVyT2ZDb2x1bW5zID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5kYXRhWzBdLmxlbmd0aDtcbiAgICB9O1xuICAgIE1hdHJpeC5wcm90b3R5cGUuZ2V0RGltZW5zaW9ucyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIFt0aGlzLmdldE51bWJlck9mUm93cygpLCB0aGlzLmdldE51bWJlck9mQ29sdW1ucygpXTtcbiAgICB9O1xuICAgIE1hdHJpeC5wcm90b3R5cGUuc2V0ID0gZnVuY3Rpb24gKHJvdywgY29sdW1uLCB2YWwpIHtcbiAgICAgICAgdGhpcy5kYXRhW3Jvd11bY29sdW1uXSA9IHZhbDtcbiAgICB9O1xuICAgIE1hdHJpeC5wcm90b3R5cGUuZ2V0ID0gZnVuY3Rpb24gKHJvdywgY29sdW1uKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmRhdGFbcm93XVtjb2x1bW5dO1xuICAgIH07XG4gICAgTWF0cml4LnByb3RvdHlwZS5nZXRSb3dBc1Jvd1ZlY3RvciA9IGZ1bmN0aW9uIChyb3cpIHtcbiAgICAgICAgLy8gQ29weSB3aXRob3V0IHJlZmVyZW5jZVxuICAgICAgICB2YXIgdiA9IG5ldyBNYXRyaXgoW3RoaXMuZGF0YVtyb3ddLnNsaWNlKCldKTtcbiAgICAgICAgcmV0dXJuIHY7XG4gICAgfTtcbiAgICBNYXRyaXgucHJvdG90eXBlLmdldENvbHVtbkFzUm93VmVjdG9yID0gZnVuY3Rpb24gKGNvbHVtbikge1xuICAgICAgICAvLyBDb3B5IHdpdGhvdXQgcmVmZXJlbmNlXG4gICAgICAgIHZhciB2ID0gW107XG4gICAgICAgIGZvciAodmFyIF9pID0gMCwgX2EgPSB0aGlzLmRhdGE7IF9pIDwgX2EubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgICB2YXIgcm93ID0gX2FbX2ldO1xuICAgICAgICAgICAgdi5wdXNoKHJvd1tjb2x1bW5dKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IE1hdHJpeChbdl0pO1xuICAgIH07XG4gICAgTWF0cml4LnByb3RvdHlwZS5nZXRBc1NjYWxhciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHRoaXMuZ2V0RGltZW5zaW9ucygpLmV2ZXJ5KGZ1bmN0aW9uIChkKSB7IHJldHVybiBkID09IDE7IH0pKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5nZXQoMCwgMCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmVycm9yKCdzaXplJywgJ2dldEFzRmxvYXQgKG1hdHJpeCBtdXN0IGJlIDF4MSknKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgTWF0cml4LnByb3RvdHlwZS5nZXRBcnJheSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgLy8gRGVlcCBjb3B5IHdpdGhvdXQgcmVmZXJlbmNlXG4gICAgICAgIHJldHVybiB0aGlzLmRhdGEubWFwKGZ1bmN0aW9uIChyKSB7IHJldHVybiByLnNsaWNlKCk7IH0pO1xuICAgIH07XG4gICAgTWF0cml4LnByb3RvdHlwZS5jb3B5ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gbmV3IE1hdHJpeCh0aGlzLmdldEFycmF5KCkpO1xuICAgIH07XG4gICAgLy8gZW5kUm93IGFuZCBlbmRDb2x1bW4gZXhjbHVzaXZlIGlmIHBvc2l0aXZlXG4gICAgLy8gc3RhcnRSb3cgYW5kIHN0YXJ0Q29sdW1uIGV4Y2x1c2l2ZSBpZiBuZWdhdGl2ZVxuICAgIE1hdHJpeC5wcm90b3R5cGUuc2xpY2UgPSBmdW5jdGlvbiAoc3RhcnRSb3csIGVuZFJvdywgc3RhcnRDb2x1bW4sIGVuZENvbHVtbikge1xuICAgICAgICAvL0hhbmRsZSBuZWdhdGl2ZXNcbiAgICAgICAgaWYgKGVuZFJvdyA8IDApIHtcbiAgICAgICAgICAgIGVuZFJvdyA9IHRoaXMuZ2V0TnVtYmVyT2ZSb3dzKCkgKyAoZW5kUm93ICsgMSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHN0YXJ0Um93IDwgMCkge1xuICAgICAgICAgICAgc3RhcnRSb3cgPSB0aGlzLmdldE51bWJlck9mUm93cygpICsgKHN0YXJ0Um93ICsgMSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGVuZENvbHVtbiA8IDApIHtcbiAgICAgICAgICAgIGVuZENvbHVtbiA9IHRoaXMuZ2V0TnVtYmVyT2ZDb2x1bW5zKCkgKyAoZW5kQ29sdW1uICsgMSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHN0YXJ0Q29sdW1uIDwgMCkge1xuICAgICAgICAgICAgc3RhcnRDb2x1bW4gPSB0aGlzLmdldE51bWJlck9mQ29sdW1ucygpICsgKHN0YXJ0Q29sdW1uICsgMSk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHJlcyA9IG5ldyBNYXRyaXgoZW5kUm93IC0gc3RhcnRSb3csIGVuZENvbHVtbiAtIHN0YXJ0Q29sdW1uKTtcbiAgICAgICAgZm9yICh2YXIgcm93ID0gc3RhcnRSb3c7IHJvdyA8IGVuZFJvdzsgcm93KyspIHtcbiAgICAgICAgICAgIGZvciAodmFyIGNvbHVtbiA9IHN0YXJ0Q29sdW1uOyBjb2x1bW4gPCBlbmRDb2x1bW47IGNvbHVtbisrKSB7XG4gICAgICAgICAgICAgICAgcmVzLnNldChyb3cgLSBzdGFydFJvdywgY29sdW1uIC0gc3RhcnRDb2x1bW4sIHRoaXMuZ2V0KHJvdywgY29sdW1uKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlcztcbiAgICB9O1xuICAgIE1hdHJpeC5wcm90b3R5cGUubWFwID0gZnVuY3Rpb24gKGZ1bmMpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmdldE51bWJlck9mUm93cygpOyBpKyspIHtcbiAgICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgdGhpcy5nZXROdW1iZXJPZkNvbHVtbnMoKTsgaisrKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5kYXRhW2ldW2pdID0gZnVuYyh0aGlzLmRhdGFbaV1bal0sIGksIGopO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG4gICAgTWF0cml4LnByb3RvdHlwZS5mb3JFYWNoID0gZnVuY3Rpb24gKGZ1bmMpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmdldE51bWJlck9mUm93cygpOyBpKyspIHtcbiAgICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgdGhpcy5nZXROdW1iZXJPZkNvbHVtbnMoKTsgaisrKSB7XG4gICAgICAgICAgICAgICAgZnVuYyh0aGlzLmRhdGFbaV1bal0sIGksIGopO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG4gICAgTWF0cml4LnByb3RvdHlwZS5maWxsID0gZnVuY3Rpb24gKG5ld1ZhbCkge1xuICAgICAgICB0aGlzLm1hcChmdW5jdGlvbiAodikgeyByZXR1cm4gbmV3VmFsOyB9KTtcbiAgICB9O1xuICAgIE1hdHJpeC5wcm90b3R5cGUuc2NhbGUgPSBmdW5jdGlvbiAoc2NsKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm1hcChmdW5jdGlvbiAodikgeyByZXR1cm4gdiAqIHNjbDsgfSk7XG4gICAgfTtcbiAgICBNYXRyaXgucHJvdG90eXBlLmFkZCA9IGZ1bmN0aW9uIChtKSB7XG4gICAgICAgIGlmICghdGhpcy5oYXNTYW1lRGltZW5zaW9ucyhtKSlcbiAgICAgICAgICAgIHRoaXMuZXJyb3IoJ3NpemUnLCAnYWRkaXRpb24nKTtcbiAgICAgICAgcmV0dXJuIHRoaXMubWFwKGZ1bmN0aW9uICh2LCByb3csIGNvbCkgeyByZXR1cm4gdiArIG0uZ2V0KHJvdywgY29sKTsgfSk7XG4gICAgfTtcbiAgICBNYXRyaXgucHJvdG90eXBlLnN1YnRyYWN0ID0gZnVuY3Rpb24gKG0pIHtcbiAgICAgICAgaWYgKCF0aGlzLmhhc1NhbWVEaW1lbnNpb25zKG0pKVxuICAgICAgICAgICAgdGhpcy5lcnJvcignc2l6ZScsICdzdWJ0cmFjdGlvbicpO1xuICAgICAgICByZXR1cm4gdGhpcy5tYXAoZnVuY3Rpb24gKHYsIHJvdywgY29sKSB7IHJldHVybiB2IC0gbS5nZXQocm93LCBjb2wpOyB9KTtcbiAgICB9O1xuICAgIE1hdHJpeC5wcm90b3R5cGUubXVsdGlwbHkgPSBmdW5jdGlvbiAobSkge1xuICAgICAgICBpZiAoIXRoaXMuaGFzU2FtZURpbWVuc2lvbnMobSkpXG4gICAgICAgICAgICB0aGlzLmVycm9yKCdzaXplJywgJ211bHRpcGxpY2F0aW9uJyk7XG4gICAgICAgIHJldHVybiB0aGlzLm1hcChmdW5jdGlvbiAodiwgcm93LCBjb2wpIHsgcmV0dXJuIHYgKiBtLmdldChyb3csIGNvbCk7IH0pO1xuICAgIH07XG4gICAgTWF0cml4LnByb3RvdHlwZS5kaXZpZGUgPSBmdW5jdGlvbiAobSkge1xuICAgICAgICBpZiAoIXRoaXMuaGFzU2FtZURpbWVuc2lvbnMobSkpXG4gICAgICAgICAgICB0aGlzLmVycm9yKCdzaXplJywgJ2RpdmlzaW9uJyk7XG4gICAgICAgIHJldHVybiB0aGlzLm1hcChmdW5jdGlvbiAodiwgcm93LCBjb2wpIHsgcmV0dXJuIHYgLyBtLmdldChyb3csIGNvbCk7IH0pO1xuICAgIH07XG4gICAgTWF0cml4LnByb3RvdHlwZS5kb3QgPSBmdW5jdGlvbiAobSkge1xuICAgICAgICBpZiAoISh0aGlzLmdldE51bWJlck9mQ29sdW1ucygpID09IG0uZ2V0TnVtYmVyT2ZSb3dzKCkpKVxuICAgICAgICAgICAgdGhpcy5lcnJvcignc2l6ZScsICdkb3QgcHJvZHVjdCcpO1xuICAgICAgICB2YXIgbmV3RGF0YSA9IE1hdHJpeC5nZXQyREFycmF5KHRoaXMuZ2V0TnVtYmVyT2ZSb3dzKCksIG0uZ2V0TnVtYmVyT2ZDb2x1bW5zKCkpO1xuICAgICAgICBmb3IgKHZhciB2ID0gMDsgdiA8IG0uZ2V0TnVtYmVyT2ZDb2x1bW5zKCk7IHYrKykge1xuICAgICAgICAgICAgZm9yICh2YXIgciA9IDA7IHIgPCB0aGlzLmdldE51bWJlck9mUm93cygpOyByKyspIHtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG0uZ2V0TnVtYmVyT2ZSb3dzKCk7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICBuZXdEYXRhW3JdW3ZdICs9IG0uZ2V0KGksIHYpICogdGhpcy5nZXQociwgaSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRoaXMuZGF0YSA9IG5ld0RhdGE7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG4gICAgTWF0cml4LnByb3RvdHlwZS50cmFuc3Bvc2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBuZXdEYXRhID0gTWF0cml4LmdldDJEQXJyYXkodGhpcy5nZXROdW1iZXJPZkNvbHVtbnMoKSwgdGhpcy5nZXROdW1iZXJPZlJvd3MoKSk7XG4gICAgICAgIHRoaXMuZm9yRWFjaChmdW5jdGlvbiAodiwgcm93LCBjb2wpIHtcbiAgICAgICAgICAgIG5ld0RhdGFbY29sXVtyb3ddID0gdjtcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuZGF0YSA9IG5ld0RhdGE7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG4gICAgTWF0cml4LnByb3RvdHlwZS5taW4gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBtaW5WYWx1ZXMgPSBbXTtcbiAgICAgICAgZm9yICh2YXIgYyA9IDA7IGMgPCB0aGlzLmdldE51bWJlck9mQ29sdW1ucygpOyBjKyspIHtcbiAgICAgICAgICAgIHZhciBjb2x1bW4gPSB0aGlzLmdldENvbHVtbkFzUm93VmVjdG9yKGMpLmdldEFycmF5KClbMF07XG4gICAgICAgICAgICBtaW5WYWx1ZXMucHVzaChNYXRoLm1pbi5hcHBseShNYXRoLCBjb2x1bW4pKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gTWF0cml4LnJvd1ZlY3Rvci5hcHBseShNYXRyaXgsIG1pblZhbHVlcyk7XG4gICAgfTtcbiAgICBNYXRyaXgucHJvdG90eXBlLm1heCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIG1heFZhbHVlcyA9IFtdO1xuICAgICAgICBmb3IgKHZhciBjID0gMDsgYyA8IHRoaXMuZ2V0TnVtYmVyT2ZDb2x1bW5zKCk7IGMrKykge1xuICAgICAgICAgICAgdmFyIGNvbHVtbiA9IHRoaXMuZ2V0Q29sdW1uQXNSb3dWZWN0b3IoYykuZ2V0QXJyYXkoKVswXTtcbiAgICAgICAgICAgIG1heFZhbHVlcy5wdXNoKE1hdGgubWF4LmFwcGx5KE1hdGgsIGNvbHVtbikpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBNYXRyaXgucm93VmVjdG9yLmFwcGx5KE1hdHJpeCwgbWF4VmFsdWVzKTtcbiAgICB9O1xuICAgIE1hdHJpeC5wcm90b3R5cGUuaGFzU2FtZURpbWVuc2lvbnMgPSBmdW5jdGlvbiAobSkge1xuICAgICAgICBpZiAobS5nZXROdW1iZXJPZkNvbHVtbnMoKSA9PSB0aGlzLmdldE51bWJlck9mQ29sdW1ucygpICYmIG0uZ2V0TnVtYmVyT2ZSb3dzKCkgPT0gdGhpcy5nZXROdW1iZXJPZlJvd3MoKSkge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIE1hdHJpeC5wcm90b3R5cGUuZXJyb3IgPSBmdW5jdGlvbiAoY29kZSwgb3BlcmF0aW9uKSB7XG4gICAgICAgIHN3aXRjaCAoY29kZSkge1xuICAgICAgICAgICAgY2FzZSAnc2l6ZSc6XG4gICAgICAgICAgICAgICAgdGhyb3cgXCJNYXRyaWNlcyBub3Qgbm90IGhhdmUgdGhlIHJpZ2h0IHNpemVzIGZvciBvcGVyYXRpb24gXCIgKyBvcGVyYXRpb247XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIHRocm93IFwiRXJyb3IhXCI7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIE1hdHJpeC5wcm90b3R5cGUuc2hvdyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgY29uc29sZS5sb2codGhpcy5nZXRBc1N0cmluZygpKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcbiAgICBNYXRyaXgucHJvdG90eXBlLmdldEFzU3RyaW5nID0gZnVuY3Rpb24gKG1hcmt1cCwgam9pbkNoYXIsIGxpbmVTcGFjZUNoYXIsIGVuZCwgZml4ZWQpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgaWYgKG1hcmt1cCA9PT0gdm9pZCAwKSB7IG1hcmt1cCA9IHRydWU7IH1cbiAgICAgICAgaWYgKGpvaW5DaGFyID09PSB2b2lkIDApIHsgam9pbkNoYXIgPSAnXFx0JzsgfVxuICAgICAgICBpZiAobGluZVNwYWNlQ2hhciA9PT0gdm9pZCAwKSB7IGxpbmVTcGFjZUNoYXIgPSAnICc7IH1cbiAgICAgICAgaWYgKGVuZCA9PT0gdm9pZCAwKSB7IGVuZCA9ICdcXG4nOyB9XG4gICAgICAgIGlmIChmaXhlZCA9PT0gdm9pZCAwKSB7IGZpeGVkID0gMzsgfVxuICAgICAgICBpZiAoIW1hcmt1cCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZGF0YS5tYXAoZnVuY3Rpb24gKHIpIHsgcmV0dXJuIHIubWFwKGZ1bmN0aW9uIChuKSB7IHJldHVybiBuLnRvRml4ZWQoZml4ZWQpOyB9KS5qb2luKCdcXHQnKTsgfSkuam9pbignXFxuJykgKyBlbmQ7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5kYXRhLm1hcChmdW5jdGlvbiAociwgaSkge1xuICAgICAgICAgICAgICAgIHZhciBtaWRkbGVQYXJ0ID0gci5tYXAoZnVuY3Rpb24gKG4pIHsgcmV0dXJuIG4udG9GaXhlZChmaXhlZCk7IH0pLmpvaW4oam9pbkNoYXIpO1xuICAgICAgICAgICAgICAgIGlmIChpID09IDAgJiYgX3RoaXMuZGF0YS5sZW5ndGggPT0gMSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gXCJbXCIgKyBsaW5lU3BhY2VDaGFyICsgbWlkZGxlUGFydCArIGxpbmVTcGFjZUNoYXIgKyBcIl1cIjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoaSA9PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBcIlxcdTIzQTFcIiArIGxpbmVTcGFjZUNoYXIgKyBtaWRkbGVQYXJ0ICsgbGluZVNwYWNlQ2hhciArIFwiXFx1MjNBNFwiO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChpID09IF90aGlzLmRhdGEubGVuZ3RoIC0gMSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gXCJcXHUyM0EzXCIgKyBsaW5lU3BhY2VDaGFyICsgbWlkZGxlUGFydCArIGxpbmVTcGFjZUNoYXIgKyBcIlxcdTIzQTZcIjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBcIlxcdTIzOUNcIiArIGxpbmVTcGFjZUNoYXIgKyBtaWRkbGVQYXJ0ICsgbGluZVNwYWNlQ2hhciArIFwiXFx1MjM5RlwiO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pLmpvaW4oJ1xcbicpICsgZW5kO1xuICAgICAgICB9XG4gICAgfTtcbiAgICByZXR1cm4gTWF0cml4O1xufSgpKTtcbmV4cG9ydHMuTWF0cml4ID0gTWF0cml4O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9zcmMvbWF0cml4LnRzXG4vLyBtb2R1bGUgaWQgPSA1XG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTsiLCJzb3VyY2VSb290IjoiIn0=");

/***/ }),
/* 6 */
/* unknown exports provided */
/* all exports used */
/*!**********************!*\
  !*** ./src/index.ts ***!
  \**********************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nfunction __export(m) {\n    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];\n}\nObject.defineProperty(exports, \"__esModule\", { value: true });\n__export(__webpack_require__(/*! ./matrix */ 5));\n__export(__webpack_require__(/*! ./NeuralNetworks/ann */ 1));\n__export(__webpack_require__(/*! ./NeuralNetworks/activationFunctions */ 0));\n__export(__webpack_require__(/*! ./NeuralNetworks/errorFunctions */ 2));\n__export(__webpack_require__(/*! ./helper/helper-functions */ 7));\n__export(__webpack_require__(/*! ./helper/classToValue */ 9));\n__export(__webpack_require__(/*! ./helper/normalization */ 11));\n__export(__webpack_require__(/*! ./knn */ 4));\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNi5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL3NyYy9pbmRleC50cz9kMWU3Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuZnVuY3Rpb24gX19leHBvcnQobSkge1xuICAgIGZvciAodmFyIHAgaW4gbSkgaWYgKCFleHBvcnRzLmhhc093blByb3BlcnR5KHApKSBleHBvcnRzW3BdID0gbVtwXTtcbn1cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbl9fZXhwb3J0KHJlcXVpcmUoXCIuL21hdHJpeFwiKSk7XG5fX2V4cG9ydChyZXF1aXJlKFwiLi9OZXVyYWxOZXR3b3Jrcy9hbm5cIikpO1xuX19leHBvcnQocmVxdWlyZShcIi4vTmV1cmFsTmV0d29ya3MvYWN0aXZhdGlvbkZ1bmN0aW9uc1wiKSk7XG5fX2V4cG9ydChyZXF1aXJlKFwiLi9OZXVyYWxOZXR3b3Jrcy9lcnJvckZ1bmN0aW9uc1wiKSk7XG5fX2V4cG9ydChyZXF1aXJlKFwiLi9oZWxwZXIvaGVscGVyLWZ1bmN0aW9uc1wiKSk7XG5fX2V4cG9ydChyZXF1aXJlKFwiLi9oZWxwZXIvY2xhc3NUb1ZhbHVlXCIpKTtcbl9fZXhwb3J0KHJlcXVpcmUoXCIuL2hlbHBlci9ub3JtYWxpemF0aW9uXCIpKTtcbl9fZXhwb3J0KHJlcXVpcmUoXCIuL2tublwiKSk7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL3NyYy9pbmRleC50c1xuLy8gbW9kdWxlIGlkID0gNlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOyIsInNvdXJjZVJvb3QiOiIifQ==");

/***/ }),
/* 7 */
/* unknown exports provided */
/* all exports used */
/*!****************************************!*\
  !*** ./src/helper/helper-functions.ts ***!
  \****************************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nfunction repeat(func, iterations) {\n    for (var i = 0; i < iterations; i++) {\n        func(i);\n    }\n}\nexports.repeat = repeat;\nfunction csvStringToJSON(csv, tryObjectParseIfPossible, columnSeparator, rowSeparator) {\n    if (tryObjectParseIfPossible === void 0) { tryObjectParseIfPossible = true; }\n    if (columnSeparator === void 0) { columnSeparator = ','; }\n    if (rowSeparator === void 0) { rowSeparator = '\\r\\n'; }\n    var data = csv.trim().split(rowSeparator).map(function (r) { return r.split(columnSeparator).map(function (c) { return isNaN(c) ? c : parseFloat(c); }); });\n    if (data[0].every(function (c) { return typeof c == 'string'; }) && tryObjectParseIfPossible) {\n        var labels_1 = data.splice(0, 1)[0];\n        var jsonData = data.map(function (r, i) {\n            var rowObject = {};\n            for (var i_1 = 0; i_1 < labels_1.length; i_1++) {\n                rowObject[labels_1[i_1]] = r[i_1];\n            }\n            return rowObject;\n        });\n        return jsonData;\n    }\n    else {\n        return data;\n    }\n}\nexports.csvStringToJSON = csvStringToJSON;\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL3NyYy9oZWxwZXIvaGVscGVyLWZ1bmN0aW9ucy50cz9iMDE3Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZnVuY3Rpb24gcmVwZWF0KGZ1bmMsIGl0ZXJhdGlvbnMpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGl0ZXJhdGlvbnM7IGkrKykge1xuICAgICAgICBmdW5jKGkpO1xuICAgIH1cbn1cbmV4cG9ydHMucmVwZWF0ID0gcmVwZWF0O1xuZnVuY3Rpb24gY3N2U3RyaW5nVG9KU09OKGNzdiwgdHJ5T2JqZWN0UGFyc2VJZlBvc3NpYmxlLCBjb2x1bW5TZXBhcmF0b3IsIHJvd1NlcGFyYXRvcikge1xuICAgIGlmICh0cnlPYmplY3RQYXJzZUlmUG9zc2libGUgPT09IHZvaWQgMCkgeyB0cnlPYmplY3RQYXJzZUlmUG9zc2libGUgPSB0cnVlOyB9XG4gICAgaWYgKGNvbHVtblNlcGFyYXRvciA9PT0gdm9pZCAwKSB7IGNvbHVtblNlcGFyYXRvciA9ICcsJzsgfVxuICAgIGlmIChyb3dTZXBhcmF0b3IgPT09IHZvaWQgMCkgeyByb3dTZXBhcmF0b3IgPSAnXFxyXFxuJzsgfVxuICAgIHZhciBkYXRhID0gY3N2LnRyaW0oKS5zcGxpdChyb3dTZXBhcmF0b3IpLm1hcChmdW5jdGlvbiAocikgeyByZXR1cm4gci5zcGxpdChjb2x1bW5TZXBhcmF0b3IpLm1hcChmdW5jdGlvbiAoYykgeyByZXR1cm4gaXNOYU4oYykgPyBjIDogcGFyc2VGbG9hdChjKTsgfSk7IH0pO1xuICAgIGlmIChkYXRhWzBdLmV2ZXJ5KGZ1bmN0aW9uIChjKSB7IHJldHVybiB0eXBlb2YgYyA9PSAnc3RyaW5nJzsgfSkgJiYgdHJ5T2JqZWN0UGFyc2VJZlBvc3NpYmxlKSB7XG4gICAgICAgIHZhciBsYWJlbHNfMSA9IGRhdGEuc3BsaWNlKDAsIDEpWzBdO1xuICAgICAgICB2YXIganNvbkRhdGEgPSBkYXRhLm1hcChmdW5jdGlvbiAociwgaSkge1xuICAgICAgICAgICAgdmFyIHJvd09iamVjdCA9IHt9O1xuICAgICAgICAgICAgZm9yICh2YXIgaV8xID0gMDsgaV8xIDwgbGFiZWxzXzEubGVuZ3RoOyBpXzErKykge1xuICAgICAgICAgICAgICAgIHJvd09iamVjdFtsYWJlbHNfMVtpXzFdXSA9IHJbaV8xXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiByb3dPYmplY3Q7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4ganNvbkRhdGE7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICByZXR1cm4gZGF0YTtcbiAgICB9XG59XG5leHBvcnRzLmNzdlN0cmluZ1RvSlNPTiA9IGNzdlN0cmluZ1RvSlNPTjtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vc3JjL2hlbHBlci9oZWxwZXItZnVuY3Rpb25zLnRzXG4vLyBtb2R1bGUgaWQgPSA3XG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTsiLCJzb3VyY2VSb290IjoiIn0=");

/***/ }),
/* 8 */,
/* 9 */
/* unknown exports provided */
/* all exports used */
/*!************************************!*\
  !*** ./src/helper/classToValue.ts ***!
  \************************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar ClassToValue = (function () {\n    function ClassToValue() {\n        this.dictionary = [];\n    }\n    ClassToValue.prototype.toValue = function (className) {\n        if (this.dictionary.includes(className)) {\n            return this.dictionary.indexOf(className);\n        }\n        else {\n            this.dictionary.push(className);\n            return this.dictionary.length - 1;\n        }\n    };\n    ClassToValue.prototype.toClass = function (value) {\n        return this.dictionary[value];\n    };\n    return ClassToValue;\n}());\nexports.ClassToValue = ClassToValue;\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiOS5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL3NyYy9oZWxwZXIvY2xhc3NUb1ZhbHVlLnRzPzhkZTUiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgQ2xhc3NUb1ZhbHVlID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBDbGFzc1RvVmFsdWUoKSB7XG4gICAgICAgIHRoaXMuZGljdGlvbmFyeSA9IFtdO1xuICAgIH1cbiAgICBDbGFzc1RvVmFsdWUucHJvdG90eXBlLnRvVmFsdWUgPSBmdW5jdGlvbiAoY2xhc3NOYW1lKSB7XG4gICAgICAgIGlmICh0aGlzLmRpY3Rpb25hcnkuaW5jbHVkZXMoY2xhc3NOYW1lKSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZGljdGlvbmFyeS5pbmRleE9mKGNsYXNzTmFtZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmRpY3Rpb25hcnkucHVzaChjbGFzc05hbWUpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZGljdGlvbmFyeS5sZW5ndGggLSAxO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBDbGFzc1RvVmFsdWUucHJvdG90eXBlLnRvQ2xhc3MgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZGljdGlvbmFyeVt2YWx1ZV07XG4gICAgfTtcbiAgICByZXR1cm4gQ2xhc3NUb1ZhbHVlO1xufSgpKTtcbmV4cG9ydHMuQ2xhc3NUb1ZhbHVlID0gQ2xhc3NUb1ZhbHVlO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9zcmMvaGVscGVyL2NsYXNzVG9WYWx1ZS50c1xuLy8gbW9kdWxlIGlkID0gOVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTsiLCJzb3VyY2VSb290IjoiIn0=");

/***/ }),
/* 10 */,
/* 11 */
/* unknown exports provided */
/* all exports used */
/*!*************************************!*\
  !*** ./src/helper/normalization.ts ***!
  \*************************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar Normalization;\n(function (Normalization) {\n    var MinMaxNormalizer = (function () {\n        function MinMaxNormalizer(data) {\n            this.data = data;\n            this.minValues = [];\n            this.maxValues = [];\n            var columns = data[0].length;\n            var _loop_1 = function (c) {\n                var column = data.map(function (r) { return r[c]; });\n                this_1.minValues.push(Math.min.apply(Math, column));\n                this_1.maxValues.push(Math.max.apply(Math, column));\n            };\n            var this_1 = this;\n            for (var c = 0; c < columns; c++) {\n                _loop_1(c);\n            }\n        }\n        MinMaxNormalizer.prototype.normalizeExampleData = function () {\n            var _this = this;\n            return this.data.map(function (row, r) { return row.map(function (x, column) {\n                return (x - _this.minValues[column]) / (_this.maxValues[column] - _this.minValues[column]);\n            }); });\n        };\n        MinMaxNormalizer.prototype.normalizeNewDataRow = function (row) {\n            var _this = this;\n            return row.map(function (value, v) {\n                return (v - _this.minValues[v]) / (_this.maxValues[v] - _this.minValues[v]);\n            });\n        };\n        MinMaxNormalizer.prototype.denormalize = function (row) {\n            var _this = this;\n            return row.map(function (value, v) {\n                return v * (_this.maxValues[v] - _this.minValues[v]) + _this.minValues[v];\n            });\n        };\n        return MinMaxNormalizer;\n    }());\n    Normalization.MinMaxNormalizer = MinMaxNormalizer;\n})(Normalization = exports.Normalization || (exports.Normalization = {}));\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTEuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvaGVscGVyL25vcm1hbGl6YXRpb24udHM/Y2YyYyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBOb3JtYWxpemF0aW9uO1xuKGZ1bmN0aW9uIChOb3JtYWxpemF0aW9uKSB7XG4gICAgdmFyIE1pbk1heE5vcm1hbGl6ZXIgPSAoZnVuY3Rpb24gKCkge1xuICAgICAgICBmdW5jdGlvbiBNaW5NYXhOb3JtYWxpemVyKGRhdGEpIHtcbiAgICAgICAgICAgIHRoaXMuZGF0YSA9IGRhdGE7XG4gICAgICAgICAgICB0aGlzLm1pblZhbHVlcyA9IFtdO1xuICAgICAgICAgICAgdGhpcy5tYXhWYWx1ZXMgPSBbXTtcbiAgICAgICAgICAgIHZhciBjb2x1bW5zID0gZGF0YVswXS5sZW5ndGg7XG4gICAgICAgICAgICB2YXIgX2xvb3BfMSA9IGZ1bmN0aW9uIChjKSB7XG4gICAgICAgICAgICAgICAgdmFyIGNvbHVtbiA9IGRhdGEubWFwKGZ1bmN0aW9uIChyKSB7IHJldHVybiByW2NdOyB9KTtcbiAgICAgICAgICAgICAgICB0aGlzXzEubWluVmFsdWVzLnB1c2goTWF0aC5taW4uYXBwbHkoTWF0aCwgY29sdW1uKSk7XG4gICAgICAgICAgICAgICAgdGhpc18xLm1heFZhbHVlcy5wdXNoKE1hdGgubWF4LmFwcGx5KE1hdGgsIGNvbHVtbikpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHZhciB0aGlzXzEgPSB0aGlzO1xuICAgICAgICAgICAgZm9yICh2YXIgYyA9IDA7IGMgPCBjb2x1bW5zOyBjKyspIHtcbiAgICAgICAgICAgICAgICBfbG9vcF8xKGMpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIE1pbk1heE5vcm1hbGl6ZXIucHJvdG90eXBlLm5vcm1hbGl6ZUV4YW1wbGVEYXRhID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmRhdGEubWFwKGZ1bmN0aW9uIChyb3csIHIpIHsgcmV0dXJuIHJvdy5tYXAoZnVuY3Rpb24gKHgsIGNvbHVtbikge1xuICAgICAgICAgICAgICAgIHJldHVybiAoeCAtIF90aGlzLm1pblZhbHVlc1tjb2x1bW5dKSAvIChfdGhpcy5tYXhWYWx1ZXNbY29sdW1uXSAtIF90aGlzLm1pblZhbHVlc1tjb2x1bW5dKTtcbiAgICAgICAgICAgIH0pOyB9KTtcbiAgICAgICAgfTtcbiAgICAgICAgTWluTWF4Tm9ybWFsaXplci5wcm90b3R5cGUubm9ybWFsaXplTmV3RGF0YVJvdyA9IGZ1bmN0aW9uIChyb3cpIHtcbiAgICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgICAgICByZXR1cm4gcm93Lm1hcChmdW5jdGlvbiAodmFsdWUsIHYpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gKHYgLSBfdGhpcy5taW5WYWx1ZXNbdl0pIC8gKF90aGlzLm1heFZhbHVlc1t2XSAtIF90aGlzLm1pblZhbHVlc1t2XSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfTtcbiAgICAgICAgTWluTWF4Tm9ybWFsaXplci5wcm90b3R5cGUuZGVub3JtYWxpemUgPSBmdW5jdGlvbiAocm93KSB7XG4gICAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICAgICAgcmV0dXJuIHJvdy5tYXAoZnVuY3Rpb24gKHZhbHVlLCB2KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHYgKiAoX3RoaXMubWF4VmFsdWVzW3ZdIC0gX3RoaXMubWluVmFsdWVzW3ZdKSArIF90aGlzLm1pblZhbHVlc1t2XTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gTWluTWF4Tm9ybWFsaXplcjtcbiAgICB9KCkpO1xuICAgIE5vcm1hbGl6YXRpb24uTWluTWF4Tm9ybWFsaXplciA9IE1pbk1heE5vcm1hbGl6ZXI7XG59KShOb3JtYWxpemF0aW9uID0gZXhwb3J0cy5Ob3JtYWxpemF0aW9uIHx8IChleHBvcnRzLk5vcm1hbGl6YXRpb24gPSB7fSkpO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9zcmMvaGVscGVyL25vcm1hbGl6YXRpb24udHNcbi8vIG1vZHVsZSBpZCA9IDExXG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOyIsInNvdXJjZVJvb3QiOiIifQ==");

/***/ })
/******/ ])));