(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory();
	else if(typeof define === 'function' && define.amd)
		define([], factory);
	else if(typeof exports === 'object')
		exports["thoughtful"] = factory();
	else
		root["thoughtful"] = factory();
})(this, function() {
return /******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId])
/******/ 			return installedModules[moduleId].exports;
/******/
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// identity function for calling harmony imports with the correct context
/******/ 	__webpack_require__.i = function(value) { return value; };
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, {
/******/ 				configurable: false,
/******/ 				enumerable: true,
/******/ 				get: getter
/******/ 			});
/******/ 		}
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 0);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/* unknown exports provided */
/* all exports used */
/*!**********************!*\
  !*** ./src/index.ts ***!
  \**********************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nfunction __export(m) {\n    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];\n}\nObject.defineProperty(exports, \"__esModule\", { value: true });\n__export(__webpack_require__(/*! ./math/matrix */ 12));\n__export(__webpack_require__(/*! ./math/distances */ 10));\n__export(__webpack_require__(/*! ./math/normalization */ 13));\n__export(__webpack_require__(/*! ./math/maths */ 11));\n__export(__webpack_require__(/*! ./math/vector */ 14));\n__export(__webpack_require__(/*! ./NeuralNetworks/ann */ 2));\n__export(__webpack_require__(/*! ./NeuralNetworks/activationFunctions */ 1));\n__export(__webpack_require__(/*! ./NeuralNetworks/errorFunctions */ 4));\n__export(__webpack_require__(/*! ./NeuralNetworks/ann2 */ 3));\n__export(__webpack_require__(/*! ./helper/utilities */ 7));\n__export(__webpack_require__(/*! ./helper/labelToValue */ 6));\n__export(__webpack_require__(/*! ./helper/generators */ 5));\n__export(__webpack_require__(/*! ./knn */ 9));\n__export(__webpack_require__(/*! ./k-means */ 8));\n__export(__webpack_require__(/*! ./naive-bayes */ 15));\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMC5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL3NyYy9pbmRleC50cz9kMWU3Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuZnVuY3Rpb24gX19leHBvcnQobSkge1xuICAgIGZvciAodmFyIHAgaW4gbSkgaWYgKCFleHBvcnRzLmhhc093blByb3BlcnR5KHApKSBleHBvcnRzW3BdID0gbVtwXTtcbn1cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbl9fZXhwb3J0KHJlcXVpcmUoXCIuL21hdGgvbWF0cml4XCIpKTtcbl9fZXhwb3J0KHJlcXVpcmUoXCIuL21hdGgvZGlzdGFuY2VzXCIpKTtcbl9fZXhwb3J0KHJlcXVpcmUoXCIuL21hdGgvbm9ybWFsaXphdGlvblwiKSk7XG5fX2V4cG9ydChyZXF1aXJlKFwiLi9tYXRoL21hdGhzXCIpKTtcbl9fZXhwb3J0KHJlcXVpcmUoXCIuL21hdGgvdmVjdG9yXCIpKTtcbl9fZXhwb3J0KHJlcXVpcmUoXCIuL05ldXJhbE5ldHdvcmtzL2FublwiKSk7XG5fX2V4cG9ydChyZXF1aXJlKFwiLi9OZXVyYWxOZXR3b3Jrcy9hY3RpdmF0aW9uRnVuY3Rpb25zXCIpKTtcbl9fZXhwb3J0KHJlcXVpcmUoXCIuL05ldXJhbE5ldHdvcmtzL2Vycm9yRnVuY3Rpb25zXCIpKTtcbl9fZXhwb3J0KHJlcXVpcmUoXCIuL05ldXJhbE5ldHdvcmtzL2FubjJcIikpO1xuX19leHBvcnQocmVxdWlyZShcIi4vaGVscGVyL3V0aWxpdGllc1wiKSk7XG5fX2V4cG9ydChyZXF1aXJlKFwiLi9oZWxwZXIvbGFiZWxUb1ZhbHVlXCIpKTtcbl9fZXhwb3J0KHJlcXVpcmUoXCIuL2hlbHBlci9nZW5lcmF0b3JzXCIpKTtcbl9fZXhwb3J0KHJlcXVpcmUoXCIuL2tublwiKSk7XG5fX2V4cG9ydChyZXF1aXJlKFwiLi9rLW1lYW5zXCIpKTtcbl9fZXhwb3J0KHJlcXVpcmUoXCIuL25haXZlLWJheWVzXCIpKTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vc3JjL2luZGV4LnRzXG4vLyBtb2R1bGUgaWQgPSAwXG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTsiLCJzb3VyY2VSb290IjoiIn0=");

/***/ }),
/* 1 */
/* unknown exports provided */
/* all exports used */
/*!***************************************************!*\
  !*** ./src/NeuralNetworks/activationFunctions.ts ***!
  \***************************************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar Activations = (function () {\n    function Activations() {\n    }\n    return Activations;\n}());\nActivations.TANH = {\n    output: function (x) { return Math.tanh(x); },\n    der: function (x) {\n        var output = Activations.TANH.output(x);\n        return 1 - output * output;\n    }\n};\nActivations.SIGMOID = {\n    output: function (x) { return 1 / (1 + Math.exp(-x)); },\n    der: function (x) {\n        var output = Activations.SIGMOID.output(x);\n        return output * (1 - output);\n    }\n};\nActivations.RELU = {\n    output: function (x) { return Math.max(0, x); },\n    der: function (x) { return x <= 0 ? 0 : 1; }\n};\nActivations.LINEAR = {\n    output: function (x) { return x; },\n    der: function (x) { return 1; }\n};\nexports.Activations = Activations;\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMS5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL3NyYy9OZXVyYWxOZXR3b3Jrcy9hY3RpdmF0aW9uRnVuY3Rpb25zLnRzP2NkZmQiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgQWN0aXZhdGlvbnMgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIEFjdGl2YXRpb25zKCkge1xuICAgIH1cbiAgICByZXR1cm4gQWN0aXZhdGlvbnM7XG59KCkpO1xuQWN0aXZhdGlvbnMuVEFOSCA9IHtcbiAgICBvdXRwdXQ6IGZ1bmN0aW9uICh4KSB7IHJldHVybiBNYXRoLnRhbmgoeCk7IH0sXG4gICAgZGVyOiBmdW5jdGlvbiAoeCkge1xuICAgICAgICB2YXIgb3V0cHV0ID0gQWN0aXZhdGlvbnMuVEFOSC5vdXRwdXQoeCk7XG4gICAgICAgIHJldHVybiAxIC0gb3V0cHV0ICogb3V0cHV0O1xuICAgIH1cbn07XG5BY3RpdmF0aW9ucy5TSUdNT0lEID0ge1xuICAgIG91dHB1dDogZnVuY3Rpb24gKHgpIHsgcmV0dXJuIDEgLyAoMSArIE1hdGguZXhwKC14KSk7IH0sXG4gICAgZGVyOiBmdW5jdGlvbiAoeCkge1xuICAgICAgICB2YXIgb3V0cHV0ID0gQWN0aXZhdGlvbnMuU0lHTU9JRC5vdXRwdXQoeCk7XG4gICAgICAgIHJldHVybiBvdXRwdXQgKiAoMSAtIG91dHB1dCk7XG4gICAgfVxufTtcbkFjdGl2YXRpb25zLlJFTFUgPSB7XG4gICAgb3V0cHV0OiBmdW5jdGlvbiAoeCkgeyByZXR1cm4gTWF0aC5tYXgoMCwgeCk7IH0sXG4gICAgZGVyOiBmdW5jdGlvbiAoeCkgeyByZXR1cm4geCA8PSAwID8gMCA6IDE7IH1cbn07XG5BY3RpdmF0aW9ucy5MSU5FQVIgPSB7XG4gICAgb3V0cHV0OiBmdW5jdGlvbiAoeCkgeyByZXR1cm4geDsgfSxcbiAgICBkZXI6IGZ1bmN0aW9uICh4KSB7IHJldHVybiAxOyB9XG59O1xuZXhwb3J0cy5BY3RpdmF0aW9ucyA9IEFjdGl2YXRpb25zO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9zcmMvTmV1cmFsTmV0d29ya3MvYWN0aXZhdGlvbkZ1bmN0aW9ucy50c1xuLy8gbW9kdWxlIGlkID0gMVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTsiLCJzb3VyY2VSb290IjoiIn0=");

/***/ }),
/* 2 */
/* unknown exports provided */
/* all exports used */
/*!***********************************!*\
  !*** ./src/NeuralNetworks/ann.ts ***!
  \***********************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar Layer = (function () {\n    function Layer(options) {\n        this.options = options;\n        // neurons[0] â†’ Bias Unit\n        this.neurons = [];\n        // +1 for one bias unit\n        for (var n = 0; n < options.numberOfNeurons + 1; n++) {\n            this.neurons.push(new Neuron({\n                index: n,\n                isBiasUnit: n == options.numberOfNeurons,\n                netOptions: options.netOptions,\n                numberOfNeuronsInNextLayer: options.numberOfNeuronsInNextLayer\n            }));\n        }\n    }\n    Layer.prototype.forEachNeuron = function (func, excludeBias) {\n        if (excludeBias === void 0) { excludeBias = false; }\n        for (var i = 0; i < this.neurons.length - (excludeBias ? 1 : 0); i++) {\n            var neuron = this.neurons[i];\n            // Bias units are the last ones\n            func(neuron, neuron.getIndex());\n        }\n    };\n    return Layer;\n}());\nvar Neuron = (function () {\n    // Bias units are the last ones in array\n    function Neuron(options) {\n        this.options = options;\n        this.weights = [];\n        this.prevDelta = 0;\n        if (this.isBias())\n            this.output = 1;\n        // Generate weights\n        for (var n = 0; n < options.numberOfNeuronsInNextLayer; n++) {\n            this.weights.push(new Weight());\n        }\n        // set shorthand for activation function\n        this.activationFunction = this.options.netOptions.activationFunction;\n    }\n    /**\n     * Forward pass of values through the neuron using the prevLayer\n     * @param prevLayer i\n     */\n    Neuron.prototype.propagateForward = function (prevLayer) {\n        var _this = this;\n        if (this.isBias()) {\n            throw 'A bias unit should not propagate a value forward.';\n        }\n        var sigma = 0;\n        prevLayer.forEachNeuron(function (n) {\n            sigma += n.output * n.getWeightTo(_this).value;\n        });\n        this.input = sigma;\n        this.output = this.activationFunction.output(this.input);\n    };\n    /**\n     * Calculates the delta of an output neuron using the derivative term of the specified error function of the network and the target value\n     * @param target target value for this output neuron\n     */\n    Neuron.prototype.calculateOutputLayerDelta = function (target) {\n        if (this.isBias())\n            throw 'There should not be an output layer delta calculation for a bias unit for it is never used.';\n        this.prevDelta = this.delta || 0;\n        this.delta = this.options.netOptions.errorFunction.der(this.output, target) * this.activationFunction.der(this.input);\n    };\n    /**\n     * Calculates the delta values for neurons in a hidden layer j using the next layer k\n     * @param nextLayer k\n     */\n    Neuron.prototype.calculateHiddenLayerDelta = function (nextLayer) {\n        var _this = this;\n        if (this.isBias())\n            throw 'There should not be an hidden layer delta calculation for a bias unit for it is not connected to the previous layer.';\n        var sigma = 0;\n        nextLayer.forEachNeuron(function (n, i) {\n            sigma += n.delta * _this.weights[i].value;\n        }, true);\n        this.prevDelta = this.delta || 0;\n        this.delta = this.activationFunction.der(this.input) * sigma;\n    };\n    /**\n     * Updates the weights which connect the previous layer to the current one using this layer neurons delta values and the output of the previous layer neurons\n     * @param prevLayer the previous layer i\n     */\n    Neuron.prototype.updateWeights = function (prevLayer) {\n        var _this = this;\n        prevLayer.forEachNeuron(function (n, i) {\n            var oldWeight = n.weights[_this.getIndex()];\n            var derivativeTerm = n.output * _this.delta;\n            var momentumTerm = _this.options.netOptions.momentum * _this.prevDelta;\n            oldWeight.value -= _this.options.netOptions.learningRate * derivativeTerm + momentumTerm;\n        });\n    };\n    ;\n    /**\n     * Get the weight to a neuron in the next layer k from current layer k\n     * Weights to layer k are stored in neurons of layer j\n     * @param n Neuron in next layer k\n     */\n    Neuron.prototype.getWeightTo = function (n) {\n        return this.weights[n.getIndex()];\n    };\n    /**\n     * @returns true if the neuron is a bias unit which means it has a constant output of 1\n     * Info: Bias units are the last ones in the neurons array in each layer object\n     */\n    Neuron.prototype.isBias = function () {\n        return this.options.isBiasUnit;\n    };\n    /**\n     * @returns the index of the current neuron in its layer ranging from 1 to number of specified neurons in layer + 1 because an extra bias neuron is added at the end of neurons array in a layer object.\n     */\n    Neuron.prototype.getIndex = function () {\n        return this.options.index;\n    };\n    return Neuron;\n}());\nvar Weight = (function () {\n    function Weight(value) {\n        if (value === void 0) { value = Math.random(); }\n        this.value = value;\n    }\n    return Weight;\n}());\nvar FeedForwardNeuralNetwork = (function () {\n    function FeedForwardNeuralNetwork(options) {\n        this.options = options;\n        this.layers = [];\n        // Create net's layers\n        for (var l = 0; l < options.layers.length; l++) {\n            this.layers.push(new Layer({\n                netOptions: options,\n                numberOfNeurons: options.layers[l],\n                numberOfNeuronsInNextLayer: options.layers[l + 1] || 0\n            }));\n        }\n    }\n    /**\n     * Creates new network with specified weights\n     * @param weightData previously saved weights (using Network.exportWeights)\n     * @param options network options\n     */\n    FeedForwardNeuralNetwork.restore = function (weightData, options) {\n        var ann = new FeedForwardNeuralNetwork(options);\n        for (var l = 0; l < weightData.length; l++) {\n            for (var n = 0; n < weightData[l].length; n++) {\n                for (var w = 0; w < weightData[l][n].length; w++) {\n                    ann.layers[l].neurons[n].weights[w].value = weightData[l][n][w];\n                }\n            }\n        }\n        return ann;\n    };\n    Object.defineProperty(FeedForwardNeuralNetwork.prototype, \"inputLayer\", {\n        /**\n         * @returns the input layer\n         */\n        get: function () {\n            return this.layers[0];\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(FeedForwardNeuralNetwork.prototype, \"outputLayer\", {\n        /**\n         * @returns the output layer\n         */\n        get: function () {\n            return this.layers[this.layers.length - 1];\n        },\n        enumerable: true,\n        configurable: true\n    });\n    /**\n     * Forward Pass of the network where values are propagated through the network\n     * @param inputs input values matching the specified size of the network's input layer\n     */\n    FeedForwardNeuralNetwork.prototype.propagateForward = function (inputs) {\n        if (inputs.length != this.inputLayer.neurons.length - 1) {\n            throw \"Inputs do not match network size!\";\n        }\n        // Set input layer neurons output to input values; exclude bias of course\n        this.inputLayer.forEachNeuron(function (n, i) { return n.output = inputs[i]; }, true);\n        var _loop_1 = function (l) {\n            var layer = this_1.layers[l];\n            var prevLayer = this_1.layers[l - 1];\n            layer.forEachNeuron(function (n) { return n.propagateForward(prevLayer); }, true);\n        };\n        var this_1 = this;\n        // propagate values forward through layer starting from first hidden layer\n        for (var l = 1; l < this.layers.length; l++) {\n            _loop_1(l);\n        }\n        return this;\n    };\n    /**\n     * @returns the current output of the network\n     */\n    FeedForwardNeuralNetwork.prototype.getCurrentOutput = function () {\n        return this.outputLayer.neurons.map(function (n) { return n.output; }).slice(0, -1);\n    };\n    /**\n     * Calculate all the neurons delta values\n     * @param targetValues target values for the network with respect to last forward pass\n     */\n    FeedForwardNeuralNetwork.prototype.calculateDeltas = function (targetValues) {\n        // calculate Output layer calculateDeltas\n        this.outputLayer.forEachNeuron(function (n, i) { return n.calculateOutputLayerDelta(targetValues[i]); }, true);\n        var _loop_2 = function (l) {\n            var layer = this_2.layers[l];\n            var nextLayer = this_2.layers[l + 1];\n            layer.forEachNeuron(function (n) { return n.calculateHiddenLayerDelta(nextLayer); }, true);\n        };\n        var this_2 = this;\n        // propagate error backwards through hidden layers\n        for (var l = this.layers.length - 2; l > 0; l--) {\n            _loop_2(l);\n        }\n        return this;\n    };\n    /**\n     * Update the connection weights using previous calculated delta values\n     */\n    FeedForwardNeuralNetwork.prototype.updateWeights = function () {\n        var _loop_3 = function (l) {\n            var layer = this_3.layers[l];\n            var prevLayer = this_3.layers[l - 1];\n            layer.forEachNeuron(function (n) { return n.updateWeights(prevLayer); }, true);\n        };\n        var this_3 = this;\n        // go through all layers except input layer and update all the weights with the calculated deltaValues.\n        for (var l = 1; l < this.layers.length; l++) {\n            _loop_3(l);\n        }\n        return this;\n    };\n    /**\n     * Fits given inputs to given target values by training the network\n     * @param inputs inputs to the network\n     * @param targetValues expected outputs for given input\n     */\n    FeedForwardNeuralNetwork.prototype.fit = function (inputs, targetValues) {\n        this.propagateForward(inputs).calculateDeltas(targetValues).updateWeights();\n        return this;\n    };\n    /**\n     * Predict output values for given inputs\n     * @param inputs input values\n     */\n    FeedForwardNeuralNetwork.prototype.predict = function (inputs) {\n        return this.propagateForward(inputs).getCurrentOutput();\n    };\n    /**\n     * Calculate the error for current outputs (not forward pass)\n     * @param targetValues target values\n     */\n    FeedForwardNeuralNetwork.prototype.getCurrentError = function (targetValues) {\n        var _this = this;\n        return this.getCurrentOutput().reduce(function (s, o, i) {\n            return s + _this.options.errorFunction.error(o, targetValues[i]);\n        }, 0);\n    };\n    /**\n     * Calculates the error for given inputs\n     * @param inputs inputs to network\n     * @param targetValues expected output for given inputs\n     */\n    FeedForwardNeuralNetwork.prototype.error = function (inputs, targetValues) {\n        this.propagateForward(inputs);\n        return this.getCurrentError(targetValues);\n    };\n    /**\n     * Export the current weights of the network\n     */\n    FeedForwardNeuralNetwork.prototype.exportWeights = function () {\n        var data = [];\n        for (var l = 0; l < this.layers.length - 1; l++) {\n            var layer = this.layers[l];\n            var layerData = layer.neurons.map(function (n) { return n.weights.map(function (w) { return w.value; }); });\n            data.push(layerData);\n        }\n        return data;\n    };\n    return FeedForwardNeuralNetwork;\n}());\nexports.FeedForwardNeuralNetwork = FeedForwardNeuralNetwork;\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMi5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL3NyYy9OZXVyYWxOZXR3b3Jrcy9hbm4udHM/M2YzNiJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBMYXllciA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gTGF5ZXIob3B0aW9ucykge1xuICAgICAgICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zO1xuICAgICAgICAvLyBuZXVyb25zWzBdIOKGkiBCaWFzIFVuaXRcbiAgICAgICAgdGhpcy5uZXVyb25zID0gW107XG4gICAgICAgIC8vICsxIGZvciBvbmUgYmlhcyB1bml0XG4gICAgICAgIGZvciAodmFyIG4gPSAwOyBuIDwgb3B0aW9ucy5udW1iZXJPZk5ldXJvbnMgKyAxOyBuKyspIHtcbiAgICAgICAgICAgIHRoaXMubmV1cm9ucy5wdXNoKG5ldyBOZXVyb24oe1xuICAgICAgICAgICAgICAgIGluZGV4OiBuLFxuICAgICAgICAgICAgICAgIGlzQmlhc1VuaXQ6IG4gPT0gb3B0aW9ucy5udW1iZXJPZk5ldXJvbnMsXG4gICAgICAgICAgICAgICAgbmV0T3B0aW9uczogb3B0aW9ucy5uZXRPcHRpb25zLFxuICAgICAgICAgICAgICAgIG51bWJlck9mTmV1cm9uc0luTmV4dExheWVyOiBvcHRpb25zLm51bWJlck9mTmV1cm9uc0luTmV4dExheWVyXG4gICAgICAgICAgICB9KSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgTGF5ZXIucHJvdG90eXBlLmZvckVhY2hOZXVyb24gPSBmdW5jdGlvbiAoZnVuYywgZXhjbHVkZUJpYXMpIHtcbiAgICAgICAgaWYgKGV4Y2x1ZGVCaWFzID09PSB2b2lkIDApIHsgZXhjbHVkZUJpYXMgPSBmYWxzZTsgfVxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMubmV1cm9ucy5sZW5ndGggLSAoZXhjbHVkZUJpYXMgPyAxIDogMCk7IGkrKykge1xuICAgICAgICAgICAgdmFyIG5ldXJvbiA9IHRoaXMubmV1cm9uc1tpXTtcbiAgICAgICAgICAgIC8vIEJpYXMgdW5pdHMgYXJlIHRoZSBsYXN0IG9uZXNcbiAgICAgICAgICAgIGZ1bmMobmV1cm9uLCBuZXVyb24uZ2V0SW5kZXgoKSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHJldHVybiBMYXllcjtcbn0oKSk7XG52YXIgTmV1cm9uID0gKGZ1bmN0aW9uICgpIHtcbiAgICAvLyBCaWFzIHVuaXRzIGFyZSB0aGUgbGFzdCBvbmVzIGluIGFycmF5XG4gICAgZnVuY3Rpb24gTmV1cm9uKG9wdGlvbnMpIHtcbiAgICAgICAgdGhpcy5vcHRpb25zID0gb3B0aW9ucztcbiAgICAgICAgdGhpcy53ZWlnaHRzID0gW107XG4gICAgICAgIHRoaXMucHJldkRlbHRhID0gMDtcbiAgICAgICAgaWYgKHRoaXMuaXNCaWFzKCkpXG4gICAgICAgICAgICB0aGlzLm91dHB1dCA9IDE7XG4gICAgICAgIC8vIEdlbmVyYXRlIHdlaWdodHNcbiAgICAgICAgZm9yICh2YXIgbiA9IDA7IG4gPCBvcHRpb25zLm51bWJlck9mTmV1cm9uc0luTmV4dExheWVyOyBuKyspIHtcbiAgICAgICAgICAgIHRoaXMud2VpZ2h0cy5wdXNoKG5ldyBXZWlnaHQoKSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gc2V0IHNob3J0aGFuZCBmb3IgYWN0aXZhdGlvbiBmdW5jdGlvblxuICAgICAgICB0aGlzLmFjdGl2YXRpb25GdW5jdGlvbiA9IHRoaXMub3B0aW9ucy5uZXRPcHRpb25zLmFjdGl2YXRpb25GdW5jdGlvbjtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRm9yd2FyZCBwYXNzIG9mIHZhbHVlcyB0aHJvdWdoIHRoZSBuZXVyb24gdXNpbmcgdGhlIHByZXZMYXllclxuICAgICAqIEBwYXJhbSBwcmV2TGF5ZXIgaVxuICAgICAqL1xuICAgIE5ldXJvbi5wcm90b3R5cGUucHJvcGFnYXRlRm9yd2FyZCA9IGZ1bmN0aW9uIChwcmV2TGF5ZXIpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgaWYgKHRoaXMuaXNCaWFzKCkpIHtcbiAgICAgICAgICAgIHRocm93ICdBIGJpYXMgdW5pdCBzaG91bGQgbm90IHByb3BhZ2F0ZSBhIHZhbHVlIGZvcndhcmQuJztcbiAgICAgICAgfVxuICAgICAgICB2YXIgc2lnbWEgPSAwO1xuICAgICAgICBwcmV2TGF5ZXIuZm9yRWFjaE5ldXJvbihmdW5jdGlvbiAobikge1xuICAgICAgICAgICAgc2lnbWEgKz0gbi5vdXRwdXQgKiBuLmdldFdlaWdodFRvKF90aGlzKS52YWx1ZTtcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuaW5wdXQgPSBzaWdtYTtcbiAgICAgICAgdGhpcy5vdXRwdXQgPSB0aGlzLmFjdGl2YXRpb25GdW5jdGlvbi5vdXRwdXQodGhpcy5pbnB1dCk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBDYWxjdWxhdGVzIHRoZSBkZWx0YSBvZiBhbiBvdXRwdXQgbmV1cm9uIHVzaW5nIHRoZSBkZXJpdmF0aXZlIHRlcm0gb2YgdGhlIHNwZWNpZmllZCBlcnJvciBmdW5jdGlvbiBvZiB0aGUgbmV0d29yayBhbmQgdGhlIHRhcmdldCB2YWx1ZVxuICAgICAqIEBwYXJhbSB0YXJnZXQgdGFyZ2V0IHZhbHVlIGZvciB0aGlzIG91dHB1dCBuZXVyb25cbiAgICAgKi9cbiAgICBOZXVyb24ucHJvdG90eXBlLmNhbGN1bGF0ZU91dHB1dExheWVyRGVsdGEgPSBmdW5jdGlvbiAodGFyZ2V0KSB7XG4gICAgICAgIGlmICh0aGlzLmlzQmlhcygpKVxuICAgICAgICAgICAgdGhyb3cgJ1RoZXJlIHNob3VsZCBub3QgYmUgYW4gb3V0cHV0IGxheWVyIGRlbHRhIGNhbGN1bGF0aW9uIGZvciBhIGJpYXMgdW5pdCBmb3IgaXQgaXMgbmV2ZXIgdXNlZC4nO1xuICAgICAgICB0aGlzLnByZXZEZWx0YSA9IHRoaXMuZGVsdGEgfHwgMDtcbiAgICAgICAgdGhpcy5kZWx0YSA9IHRoaXMub3B0aW9ucy5uZXRPcHRpb25zLmVycm9yRnVuY3Rpb24uZGVyKHRoaXMub3V0cHV0LCB0YXJnZXQpICogdGhpcy5hY3RpdmF0aW9uRnVuY3Rpb24uZGVyKHRoaXMuaW5wdXQpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQ2FsY3VsYXRlcyB0aGUgZGVsdGEgdmFsdWVzIGZvciBuZXVyb25zIGluIGEgaGlkZGVuIGxheWVyIGogdXNpbmcgdGhlIG5leHQgbGF5ZXIga1xuICAgICAqIEBwYXJhbSBuZXh0TGF5ZXIga1xuICAgICAqL1xuICAgIE5ldXJvbi5wcm90b3R5cGUuY2FsY3VsYXRlSGlkZGVuTGF5ZXJEZWx0YSA9IGZ1bmN0aW9uIChuZXh0TGF5ZXIpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgaWYgKHRoaXMuaXNCaWFzKCkpXG4gICAgICAgICAgICB0aHJvdyAnVGhlcmUgc2hvdWxkIG5vdCBiZSBhbiBoaWRkZW4gbGF5ZXIgZGVsdGEgY2FsY3VsYXRpb24gZm9yIGEgYmlhcyB1bml0IGZvciBpdCBpcyBub3QgY29ubmVjdGVkIHRvIHRoZSBwcmV2aW91cyBsYXllci4nO1xuICAgICAgICB2YXIgc2lnbWEgPSAwO1xuICAgICAgICBuZXh0TGF5ZXIuZm9yRWFjaE5ldXJvbihmdW5jdGlvbiAobiwgaSkge1xuICAgICAgICAgICAgc2lnbWEgKz0gbi5kZWx0YSAqIF90aGlzLndlaWdodHNbaV0udmFsdWU7XG4gICAgICAgIH0sIHRydWUpO1xuICAgICAgICB0aGlzLnByZXZEZWx0YSA9IHRoaXMuZGVsdGEgfHwgMDtcbiAgICAgICAgdGhpcy5kZWx0YSA9IHRoaXMuYWN0aXZhdGlvbkZ1bmN0aW9uLmRlcih0aGlzLmlucHV0KSAqIHNpZ21hO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogVXBkYXRlcyB0aGUgd2VpZ2h0cyB3aGljaCBjb25uZWN0IHRoZSBwcmV2aW91cyBsYXllciB0byB0aGUgY3VycmVudCBvbmUgdXNpbmcgdGhpcyBsYXllciBuZXVyb25zIGRlbHRhIHZhbHVlcyBhbmQgdGhlIG91dHB1dCBvZiB0aGUgcHJldmlvdXMgbGF5ZXIgbmV1cm9uc1xuICAgICAqIEBwYXJhbSBwcmV2TGF5ZXIgdGhlIHByZXZpb3VzIGxheWVyIGlcbiAgICAgKi9cbiAgICBOZXVyb24ucHJvdG90eXBlLnVwZGF0ZVdlaWdodHMgPSBmdW5jdGlvbiAocHJldkxheWVyKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHByZXZMYXllci5mb3JFYWNoTmV1cm9uKGZ1bmN0aW9uIChuLCBpKSB7XG4gICAgICAgICAgICB2YXIgb2xkV2VpZ2h0ID0gbi53ZWlnaHRzW190aGlzLmdldEluZGV4KCldO1xuICAgICAgICAgICAgdmFyIGRlcml2YXRpdmVUZXJtID0gbi5vdXRwdXQgKiBfdGhpcy5kZWx0YTtcbiAgICAgICAgICAgIHZhciBtb21lbnR1bVRlcm0gPSBfdGhpcy5vcHRpb25zLm5ldE9wdGlvbnMubW9tZW50dW0gKiBfdGhpcy5wcmV2RGVsdGE7XG4gICAgICAgICAgICBvbGRXZWlnaHQudmFsdWUgLT0gX3RoaXMub3B0aW9ucy5uZXRPcHRpb25zLmxlYXJuaW5nUmF0ZSAqIGRlcml2YXRpdmVUZXJtICsgbW9tZW50dW1UZXJtO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIDtcbiAgICAvKipcbiAgICAgKiBHZXQgdGhlIHdlaWdodCB0byBhIG5ldXJvbiBpbiB0aGUgbmV4dCBsYXllciBrIGZyb20gY3VycmVudCBsYXllciBrXG4gICAgICogV2VpZ2h0cyB0byBsYXllciBrIGFyZSBzdG9yZWQgaW4gbmV1cm9ucyBvZiBsYXllciBqXG4gICAgICogQHBhcmFtIG4gTmV1cm9uIGluIG5leHQgbGF5ZXIga1xuICAgICAqL1xuICAgIE5ldXJvbi5wcm90b3R5cGUuZ2V0V2VpZ2h0VG8gPSBmdW5jdGlvbiAobikge1xuICAgICAgICByZXR1cm4gdGhpcy53ZWlnaHRzW24uZ2V0SW5kZXgoKV07XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcmV0dXJucyB0cnVlIGlmIHRoZSBuZXVyb24gaXMgYSBiaWFzIHVuaXQgd2hpY2ggbWVhbnMgaXQgaGFzIGEgY29uc3RhbnQgb3V0cHV0IG9mIDFcbiAgICAgKiBJbmZvOiBCaWFzIHVuaXRzIGFyZSB0aGUgbGFzdCBvbmVzIGluIHRoZSBuZXVyb25zIGFycmF5IGluIGVhY2ggbGF5ZXIgb2JqZWN0XG4gICAgICovXG4gICAgTmV1cm9uLnByb3RvdHlwZS5pc0JpYXMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm9wdGlvbnMuaXNCaWFzVW5pdDtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEByZXR1cm5zIHRoZSBpbmRleCBvZiB0aGUgY3VycmVudCBuZXVyb24gaW4gaXRzIGxheWVyIHJhbmdpbmcgZnJvbSAxIHRvIG51bWJlciBvZiBzcGVjaWZpZWQgbmV1cm9ucyBpbiBsYXllciArIDEgYmVjYXVzZSBhbiBleHRyYSBiaWFzIG5ldXJvbiBpcyBhZGRlZCBhdCB0aGUgZW5kIG9mIG5ldXJvbnMgYXJyYXkgaW4gYSBsYXllciBvYmplY3QuXG4gICAgICovXG4gICAgTmV1cm9uLnByb3RvdHlwZS5nZXRJbmRleCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMub3B0aW9ucy5pbmRleDtcbiAgICB9O1xuICAgIHJldHVybiBOZXVyb247XG59KCkpO1xudmFyIFdlaWdodCA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gV2VpZ2h0KHZhbHVlKSB7XG4gICAgICAgIGlmICh2YWx1ZSA9PT0gdm9pZCAwKSB7IHZhbHVlID0gTWF0aC5yYW5kb20oKTsgfVxuICAgICAgICB0aGlzLnZhbHVlID0gdmFsdWU7XG4gICAgfVxuICAgIHJldHVybiBXZWlnaHQ7XG59KCkpO1xudmFyIEZlZWRGb3J3YXJkTmV1cmFsTmV0d29yayA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gRmVlZEZvcndhcmROZXVyYWxOZXR3b3JrKG9wdGlvbnMpIHtcbiAgICAgICAgdGhpcy5vcHRpb25zID0gb3B0aW9ucztcbiAgICAgICAgdGhpcy5sYXllcnMgPSBbXTtcbiAgICAgICAgLy8gQ3JlYXRlIG5ldCdzIGxheWVyc1xuICAgICAgICBmb3IgKHZhciBsID0gMDsgbCA8IG9wdGlvbnMubGF5ZXJzLmxlbmd0aDsgbCsrKSB7XG4gICAgICAgICAgICB0aGlzLmxheWVycy5wdXNoKG5ldyBMYXllcih7XG4gICAgICAgICAgICAgICAgbmV0T3B0aW9uczogb3B0aW9ucyxcbiAgICAgICAgICAgICAgICBudW1iZXJPZk5ldXJvbnM6IG9wdGlvbnMubGF5ZXJzW2xdLFxuICAgICAgICAgICAgICAgIG51bWJlck9mTmV1cm9uc0luTmV4dExheWVyOiBvcHRpb25zLmxheWVyc1tsICsgMV0gfHwgMFxuICAgICAgICAgICAgfSkpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgbmV3IG5ldHdvcmsgd2l0aCBzcGVjaWZpZWQgd2VpZ2h0c1xuICAgICAqIEBwYXJhbSB3ZWlnaHREYXRhIHByZXZpb3VzbHkgc2F2ZWQgd2VpZ2h0cyAodXNpbmcgTmV0d29yay5leHBvcnRXZWlnaHRzKVxuICAgICAqIEBwYXJhbSBvcHRpb25zIG5ldHdvcmsgb3B0aW9uc1xuICAgICAqL1xuICAgIEZlZWRGb3J3YXJkTmV1cmFsTmV0d29yay5yZXN0b3JlID0gZnVuY3Rpb24gKHdlaWdodERhdGEsIG9wdGlvbnMpIHtcbiAgICAgICAgdmFyIGFubiA9IG5ldyBGZWVkRm9yd2FyZE5ldXJhbE5ldHdvcmsob3B0aW9ucyk7XG4gICAgICAgIGZvciAodmFyIGwgPSAwOyBsIDwgd2VpZ2h0RGF0YS5sZW5ndGg7IGwrKykge1xuICAgICAgICAgICAgZm9yICh2YXIgbiA9IDA7IG4gPCB3ZWlnaHREYXRhW2xdLmxlbmd0aDsgbisrKSB7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgdyA9IDA7IHcgPCB3ZWlnaHREYXRhW2xdW25dLmxlbmd0aDsgdysrKSB7XG4gICAgICAgICAgICAgICAgICAgIGFubi5sYXllcnNbbF0ubmV1cm9uc1tuXS53ZWlnaHRzW3ddLnZhbHVlID0gd2VpZ2h0RGF0YVtsXVtuXVt3XTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGFubjtcbiAgICB9O1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShGZWVkRm9yd2FyZE5ldXJhbE5ldHdvcmsucHJvdG90eXBlLCBcImlucHV0TGF5ZXJcIiwge1xuICAgICAgICAvKipcbiAgICAgICAgICogQHJldHVybnMgdGhlIGlucHV0IGxheWVyXG4gICAgICAgICAqL1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmxheWVyc1swXTtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEZlZWRGb3J3YXJkTmV1cmFsTmV0d29yay5wcm90b3R5cGUsIFwib3V0cHV0TGF5ZXJcIiwge1xuICAgICAgICAvKipcbiAgICAgICAgICogQHJldHVybnMgdGhlIG91dHB1dCBsYXllclxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5sYXllcnNbdGhpcy5sYXllcnMubGVuZ3RoIC0gMV07XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIC8qKlxuICAgICAqIEZvcndhcmQgUGFzcyBvZiB0aGUgbmV0d29yayB3aGVyZSB2YWx1ZXMgYXJlIHByb3BhZ2F0ZWQgdGhyb3VnaCB0aGUgbmV0d29ya1xuICAgICAqIEBwYXJhbSBpbnB1dHMgaW5wdXQgdmFsdWVzIG1hdGNoaW5nIHRoZSBzcGVjaWZpZWQgc2l6ZSBvZiB0aGUgbmV0d29yaydzIGlucHV0IGxheWVyXG4gICAgICovXG4gICAgRmVlZEZvcndhcmROZXVyYWxOZXR3b3JrLnByb3RvdHlwZS5wcm9wYWdhdGVGb3J3YXJkID0gZnVuY3Rpb24gKGlucHV0cykge1xuICAgICAgICBpZiAoaW5wdXRzLmxlbmd0aCAhPSB0aGlzLmlucHV0TGF5ZXIubmV1cm9ucy5sZW5ndGggLSAxKSB7XG4gICAgICAgICAgICB0aHJvdyBcIklucHV0cyBkbyBub3QgbWF0Y2ggbmV0d29yayBzaXplIVwiO1xuICAgICAgICB9XG4gICAgICAgIC8vIFNldCBpbnB1dCBsYXllciBuZXVyb25zIG91dHB1dCB0byBpbnB1dCB2YWx1ZXM7IGV4Y2x1ZGUgYmlhcyBvZiBjb3Vyc2VcbiAgICAgICAgdGhpcy5pbnB1dExheWVyLmZvckVhY2hOZXVyb24oZnVuY3Rpb24gKG4sIGkpIHsgcmV0dXJuIG4ub3V0cHV0ID0gaW5wdXRzW2ldOyB9LCB0cnVlKTtcbiAgICAgICAgdmFyIF9sb29wXzEgPSBmdW5jdGlvbiAobCkge1xuICAgICAgICAgICAgdmFyIGxheWVyID0gdGhpc18xLmxheWVyc1tsXTtcbiAgICAgICAgICAgIHZhciBwcmV2TGF5ZXIgPSB0aGlzXzEubGF5ZXJzW2wgLSAxXTtcbiAgICAgICAgICAgIGxheWVyLmZvckVhY2hOZXVyb24oZnVuY3Rpb24gKG4pIHsgcmV0dXJuIG4ucHJvcGFnYXRlRm9yd2FyZChwcmV2TGF5ZXIpOyB9LCB0cnVlKTtcbiAgICAgICAgfTtcbiAgICAgICAgdmFyIHRoaXNfMSA9IHRoaXM7XG4gICAgICAgIC8vIHByb3BhZ2F0ZSB2YWx1ZXMgZm9yd2FyZCB0aHJvdWdoIGxheWVyIHN0YXJ0aW5nIGZyb20gZmlyc3QgaGlkZGVuIGxheWVyXG4gICAgICAgIGZvciAodmFyIGwgPSAxOyBsIDwgdGhpcy5sYXllcnMubGVuZ3RoOyBsKyspIHtcbiAgICAgICAgICAgIF9sb29wXzEobCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcmV0dXJucyB0aGUgY3VycmVudCBvdXRwdXQgb2YgdGhlIG5ldHdvcmtcbiAgICAgKi9cbiAgICBGZWVkRm9yd2FyZE5ldXJhbE5ldHdvcmsucHJvdG90eXBlLmdldEN1cnJlbnRPdXRwdXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm91dHB1dExheWVyLm5ldXJvbnMubWFwKGZ1bmN0aW9uIChuKSB7IHJldHVybiBuLm91dHB1dDsgfSkuc2xpY2UoMCwgLTEpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQ2FsY3VsYXRlIGFsbCB0aGUgbmV1cm9ucyBkZWx0YSB2YWx1ZXNcbiAgICAgKiBAcGFyYW0gdGFyZ2V0VmFsdWVzIHRhcmdldCB2YWx1ZXMgZm9yIHRoZSBuZXR3b3JrIHdpdGggcmVzcGVjdCB0byBsYXN0IGZvcndhcmQgcGFzc1xuICAgICAqL1xuICAgIEZlZWRGb3J3YXJkTmV1cmFsTmV0d29yay5wcm90b3R5cGUuY2FsY3VsYXRlRGVsdGFzID0gZnVuY3Rpb24gKHRhcmdldFZhbHVlcykge1xuICAgICAgICAvLyBjYWxjdWxhdGUgT3V0cHV0IGxheWVyIGNhbGN1bGF0ZURlbHRhc1xuICAgICAgICB0aGlzLm91dHB1dExheWVyLmZvckVhY2hOZXVyb24oZnVuY3Rpb24gKG4sIGkpIHsgcmV0dXJuIG4uY2FsY3VsYXRlT3V0cHV0TGF5ZXJEZWx0YSh0YXJnZXRWYWx1ZXNbaV0pOyB9LCB0cnVlKTtcbiAgICAgICAgdmFyIF9sb29wXzIgPSBmdW5jdGlvbiAobCkge1xuICAgICAgICAgICAgdmFyIGxheWVyID0gdGhpc18yLmxheWVyc1tsXTtcbiAgICAgICAgICAgIHZhciBuZXh0TGF5ZXIgPSB0aGlzXzIubGF5ZXJzW2wgKyAxXTtcbiAgICAgICAgICAgIGxheWVyLmZvckVhY2hOZXVyb24oZnVuY3Rpb24gKG4pIHsgcmV0dXJuIG4uY2FsY3VsYXRlSGlkZGVuTGF5ZXJEZWx0YShuZXh0TGF5ZXIpOyB9LCB0cnVlKTtcbiAgICAgICAgfTtcbiAgICAgICAgdmFyIHRoaXNfMiA9IHRoaXM7XG4gICAgICAgIC8vIHByb3BhZ2F0ZSBlcnJvciBiYWNrd2FyZHMgdGhyb3VnaCBoaWRkZW4gbGF5ZXJzXG4gICAgICAgIGZvciAodmFyIGwgPSB0aGlzLmxheWVycy5sZW5ndGggLSAyOyBsID4gMDsgbC0tKSB7XG4gICAgICAgICAgICBfbG9vcF8yKGwpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogVXBkYXRlIHRoZSBjb25uZWN0aW9uIHdlaWdodHMgdXNpbmcgcHJldmlvdXMgY2FsY3VsYXRlZCBkZWx0YSB2YWx1ZXNcbiAgICAgKi9cbiAgICBGZWVkRm9yd2FyZE5ldXJhbE5ldHdvcmsucHJvdG90eXBlLnVwZGF0ZVdlaWdodHMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfbG9vcF8zID0gZnVuY3Rpb24gKGwpIHtcbiAgICAgICAgICAgIHZhciBsYXllciA9IHRoaXNfMy5sYXllcnNbbF07XG4gICAgICAgICAgICB2YXIgcHJldkxheWVyID0gdGhpc18zLmxheWVyc1tsIC0gMV07XG4gICAgICAgICAgICBsYXllci5mb3JFYWNoTmV1cm9uKGZ1bmN0aW9uIChuKSB7IHJldHVybiBuLnVwZGF0ZVdlaWdodHMocHJldkxheWVyKTsgfSwgdHJ1ZSk7XG4gICAgICAgIH07XG4gICAgICAgIHZhciB0aGlzXzMgPSB0aGlzO1xuICAgICAgICAvLyBnbyB0aHJvdWdoIGFsbCBsYXllcnMgZXhjZXB0IGlucHV0IGxheWVyIGFuZCB1cGRhdGUgYWxsIHRoZSB3ZWlnaHRzIHdpdGggdGhlIGNhbGN1bGF0ZWQgZGVsdGFWYWx1ZXMuXG4gICAgICAgIGZvciAodmFyIGwgPSAxOyBsIDwgdGhpcy5sYXllcnMubGVuZ3RoOyBsKyspIHtcbiAgICAgICAgICAgIF9sb29wXzMobCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBGaXRzIGdpdmVuIGlucHV0cyB0byBnaXZlbiB0YXJnZXQgdmFsdWVzIGJ5IHRyYWluaW5nIHRoZSBuZXR3b3JrXG4gICAgICogQHBhcmFtIGlucHV0cyBpbnB1dHMgdG8gdGhlIG5ldHdvcmtcbiAgICAgKiBAcGFyYW0gdGFyZ2V0VmFsdWVzIGV4cGVjdGVkIG91dHB1dHMgZm9yIGdpdmVuIGlucHV0XG4gICAgICovXG4gICAgRmVlZEZvcndhcmROZXVyYWxOZXR3b3JrLnByb3RvdHlwZS5maXQgPSBmdW5jdGlvbiAoaW5wdXRzLCB0YXJnZXRWYWx1ZXMpIHtcbiAgICAgICAgdGhpcy5wcm9wYWdhdGVGb3J3YXJkKGlucHV0cykuY2FsY3VsYXRlRGVsdGFzKHRhcmdldFZhbHVlcykudXBkYXRlV2VpZ2h0cygpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFByZWRpY3Qgb3V0cHV0IHZhbHVlcyBmb3IgZ2l2ZW4gaW5wdXRzXG4gICAgICogQHBhcmFtIGlucHV0cyBpbnB1dCB2YWx1ZXNcbiAgICAgKi9cbiAgICBGZWVkRm9yd2FyZE5ldXJhbE5ldHdvcmsucHJvdG90eXBlLnByZWRpY3QgPSBmdW5jdGlvbiAoaW5wdXRzKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnByb3BhZ2F0ZUZvcndhcmQoaW5wdXRzKS5nZXRDdXJyZW50T3V0cHV0KCk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBDYWxjdWxhdGUgdGhlIGVycm9yIGZvciBjdXJyZW50IG91dHB1dHMgKG5vdCBmb3J3YXJkIHBhc3MpXG4gICAgICogQHBhcmFtIHRhcmdldFZhbHVlcyB0YXJnZXQgdmFsdWVzXG4gICAgICovXG4gICAgRmVlZEZvcndhcmROZXVyYWxOZXR3b3JrLnByb3RvdHlwZS5nZXRDdXJyZW50RXJyb3IgPSBmdW5jdGlvbiAodGFyZ2V0VmFsdWVzKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHJldHVybiB0aGlzLmdldEN1cnJlbnRPdXRwdXQoKS5yZWR1Y2UoZnVuY3Rpb24gKHMsIG8sIGkpIHtcbiAgICAgICAgICAgIHJldHVybiBzICsgX3RoaXMub3B0aW9ucy5lcnJvckZ1bmN0aW9uLmVycm9yKG8sIHRhcmdldFZhbHVlc1tpXSk7XG4gICAgICAgIH0sIDApO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQ2FsY3VsYXRlcyB0aGUgZXJyb3IgZm9yIGdpdmVuIGlucHV0c1xuICAgICAqIEBwYXJhbSBpbnB1dHMgaW5wdXRzIHRvIG5ldHdvcmtcbiAgICAgKiBAcGFyYW0gdGFyZ2V0VmFsdWVzIGV4cGVjdGVkIG91dHB1dCBmb3IgZ2l2ZW4gaW5wdXRzXG4gICAgICovXG4gICAgRmVlZEZvcndhcmROZXVyYWxOZXR3b3JrLnByb3RvdHlwZS5lcnJvciA9IGZ1bmN0aW9uIChpbnB1dHMsIHRhcmdldFZhbHVlcykge1xuICAgICAgICB0aGlzLnByb3BhZ2F0ZUZvcndhcmQoaW5wdXRzKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0Q3VycmVudEVycm9yKHRhcmdldFZhbHVlcyk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBFeHBvcnQgdGhlIGN1cnJlbnQgd2VpZ2h0cyBvZiB0aGUgbmV0d29ya1xuICAgICAqL1xuICAgIEZlZWRGb3J3YXJkTmV1cmFsTmV0d29yay5wcm90b3R5cGUuZXhwb3J0V2VpZ2h0cyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGRhdGEgPSBbXTtcbiAgICAgICAgZm9yICh2YXIgbCA9IDA7IGwgPCB0aGlzLmxheWVycy5sZW5ndGggLSAxOyBsKyspIHtcbiAgICAgICAgICAgIHZhciBsYXllciA9IHRoaXMubGF5ZXJzW2xdO1xuICAgICAgICAgICAgdmFyIGxheWVyRGF0YSA9IGxheWVyLm5ldXJvbnMubWFwKGZ1bmN0aW9uIChuKSB7IHJldHVybiBuLndlaWdodHMubWFwKGZ1bmN0aW9uICh3KSB7IHJldHVybiB3LnZhbHVlOyB9KTsgfSk7XG4gICAgICAgICAgICBkYXRhLnB1c2gobGF5ZXJEYXRhKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZGF0YTtcbiAgICB9O1xuICAgIHJldHVybiBGZWVkRm9yd2FyZE5ldXJhbE5ldHdvcms7XG59KCkpO1xuZXhwb3J0cy5GZWVkRm9yd2FyZE5ldXJhbE5ldHdvcmsgPSBGZWVkRm9yd2FyZE5ldXJhbE5ldHdvcms7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL3NyYy9OZXVyYWxOZXR3b3Jrcy9hbm4udHNcbi8vIG1vZHVsZSBpZCA9IDJcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTsiLCJzb3VyY2VSb290IjoiIn0=");

/***/ }),
/* 3 */
/* unknown exports provided */
/* all exports used */
/*!************************************!*\
  !*** ./src/NeuralNetworks/ann2.ts ***!
  \************************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar __1 = __webpack_require__(/*! .. */ 0);\nvar ANN = (function () {\n    function ANN(options) {\n        this.options = options;\n        /*  Declare Tensors */\n        // Array of Matrices (#layers - 1)\n        this.weights = [];\n        // Array of Column Vectors (#layers - 1)\n        this.biases = [];\n        // Array of Column Vectors (#layers)\n        this.inputs = [];\n        // Array of Column Vectors (#layers)\n        this.outputs = [];\n        // Array of Column Vectors (#layers-1)\n        this.deltas = [];\n        options.momentum = options.momentum | 0;\n        var SIZE = this.options.size;\n        // Generate Weights\n        for (var j = 0; j < SIZE.length - 1; j++) {\n            this.weights.push(__1.Maths.Tensor2D.generate([SIZE[j + 1], SIZE[j]], Math.random));\n        }\n        // Generate Biases\n        for (var j = 1; j < SIZE.length; j++) {\n            this.biases.push(__1.Maths.Tensor2D.generate([SIZE[j], 1], Math.random));\n        }\n    }\n    ANN.prototype.cost = function (target) {\n        var targetVector = target.map(function (v) { return [v]; }); // Column Vector\n        var outputVector = this.outputs[this.outputs.length - 1]; // Column Vector\n        var outputLayerSize = this.options.size[this.options.size.length - 1];\n        var errorSum = 0;\n        for (var i = 0; i < outputLayerSize; i++) {\n            var o = outputVector[0][i], t = targetVector[0][i];\n            errorSum += this.options.error.error(o, t);\n        }\n        return errorSum;\n    };\n    ANN.prototype.backPropagate = function (target) {\n        var _this = this;\n        // Reset old deltas\n        this.deltas = [];\n        // Calculate output layer delta vector\n        var outputVector = this.outputs[this.outputs.length - 1];\n        // Error function derivative\n        var errorDerivative = [outputVector[0].map(function (o, i) {\n                return _this.options.error.der(o, target[i]);\n            })];\n        // Calculate Delta by multiplying with output layer g'(inputs)\n        var delta = __1.Maths.Tensor2D.ElementWise.multiply(errorDerivative, __1.Maths.Tensor2D.apply(this.inputs[this.inputs.length - 1], this.options.activation.der));\n        // Save output layer delta vector\n        this.deltas.unshift(delta);\n        for (var l = this.options.size.length - 2; l > 0; l--) {\n            var lastLayerDelta = this.deltas[0];\n            var weightsT = __1.Maths.Tensor2D.transpose(this.weights[l]);\n            var layerInput = this.inputs[l];\n            var dotWeightsT_LastLayerDelta = __1.Maths.Tensor2D.dot(weightsT, lastLayerDelta);\n            var delta_1 = __1.Maths.Tensor2D.ElementWise.multiply(dotWeightsT_LastLayerDelta, __1.Maths.Tensor2D.apply(layerInput, this.options.activation.der));\n            this.deltas.unshift(delta_1);\n        }\n    };\n    ANN.prototype.updateWeights = function () {\n        var weightsDerivatives = [];\n        for (var l = this.options.size.length - 1; l > 0; l--) {\n            var outputPrevLayer = this.outputs[l - 1];\n            var delta = this.outputs[l];\n            var weightsDerivative = __1.Maths.Tensor2D.dot(delta, __1.Maths.Tensor2D.transpose(outputPrevLayer));\n            var weights = this.weights[l - 1];\n            this.weights[l - 1] = __1.Maths.Tensor2D.ElementWise.subtract(weights, __1.Maths.Tensor2D.ElementWise.scale(weightsDerivative, this.options.learningRate));\n            this.biases[l - 1] = __1.Maths.Tensor2D.ElementWise.subtract(this.biases[l - 1], __1.Maths.Tensor2D.ElementWise.scale(delta, this.options.learningRate));\n            weightsDerivatives.unshift(weightsDerivative);\n        }\n        //console.log(derivatives);\n    };\n    /**\n     *\n     * @param input Vector of Input values matching network size\n     */\n    ANN.prototype.query = function (input) {\n        //Clear set tensors\n        this.inputs = [];\n        this.outputs = [];\n        // Convert to tensor, which is a column vector\n        var inputVector = input.map(function (i) { return [i]; });\n        // Store inputs in appropriate tensors\n        this.inputs.push(inputVector);\n        this.outputs.push(inputVector);\n        // Forward propagation\n        var tmp = inputVector;\n        for (var i = 0; i < this.weights.length; i++) {\n            // Calculate Input Values\n            var beforeActivation = __1.Maths.Tensor2D.dot(this.weights[i], tmp);\n            // Add Bias terms\n            beforeActivation = __1.Maths.Tensor2D.ElementWise.add(beforeActivation, this.biases[i]);\n            // Save beforeActivation vector\n            this.inputs.push(beforeActivation);\n            // Apply activation function to layer\n            var activity = __1.Maths.Tensor2D.apply(beforeActivation, this.options.activation.output);\n            // Save layer activity as output\n            this.outputs.push(activity);\n            // Set this for tmp\n            tmp = activity;\n        }\n        var output = tmp;\n        // Return result as array\n        return __1.Maths.Tensor2D.transpose(output)[0];\n    };\n    return ANN;\n}());\nexports.ANN = ANN;\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL3NyYy9OZXVyYWxOZXR3b3Jrcy9hbm4yLnRzPzM5YjEiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgX18xID0gcmVxdWlyZShcIi4uXCIpO1xudmFyIEFOTiA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gQU5OKG9wdGlvbnMpIHtcbiAgICAgICAgdGhpcy5vcHRpb25zID0gb3B0aW9ucztcbiAgICAgICAgLyogIERlY2xhcmUgVGVuc29ycyAqL1xuICAgICAgICAvLyBBcnJheSBvZiBNYXRyaWNlcyAoI2xheWVycyAtIDEpXG4gICAgICAgIHRoaXMud2VpZ2h0cyA9IFtdO1xuICAgICAgICAvLyBBcnJheSBvZiBDb2x1bW4gVmVjdG9ycyAoI2xheWVycyAtIDEpXG4gICAgICAgIHRoaXMuYmlhc2VzID0gW107XG4gICAgICAgIC8vIEFycmF5IG9mIENvbHVtbiBWZWN0b3JzICgjbGF5ZXJzKVxuICAgICAgICB0aGlzLmlucHV0cyA9IFtdO1xuICAgICAgICAvLyBBcnJheSBvZiBDb2x1bW4gVmVjdG9ycyAoI2xheWVycylcbiAgICAgICAgdGhpcy5vdXRwdXRzID0gW107XG4gICAgICAgIC8vIEFycmF5IG9mIENvbHVtbiBWZWN0b3JzICgjbGF5ZXJzLTEpXG4gICAgICAgIHRoaXMuZGVsdGFzID0gW107XG4gICAgICAgIG9wdGlvbnMubW9tZW50dW0gPSBvcHRpb25zLm1vbWVudHVtIHwgMDtcbiAgICAgICAgdmFyIFNJWkUgPSB0aGlzLm9wdGlvbnMuc2l6ZTtcbiAgICAgICAgLy8gR2VuZXJhdGUgV2VpZ2h0c1xuICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IFNJWkUubGVuZ3RoIC0gMTsgaisrKSB7XG4gICAgICAgICAgICB0aGlzLndlaWdodHMucHVzaChfXzEuTWF0aHMuVGVuc29yMkQuZ2VuZXJhdGUoW1NJWkVbaiArIDFdLCBTSVpFW2pdXSwgTWF0aC5yYW5kb20pKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBHZW5lcmF0ZSBCaWFzZXNcbiAgICAgICAgZm9yICh2YXIgaiA9IDE7IGogPCBTSVpFLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICB0aGlzLmJpYXNlcy5wdXNoKF9fMS5NYXRocy5UZW5zb3IyRC5nZW5lcmF0ZShbU0laRVtqXSwgMV0sIE1hdGgucmFuZG9tKSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgQU5OLnByb3RvdHlwZS5jb3N0ID0gZnVuY3Rpb24gKHRhcmdldCkge1xuICAgICAgICB2YXIgdGFyZ2V0VmVjdG9yID0gdGFyZ2V0Lm1hcChmdW5jdGlvbiAodikgeyByZXR1cm4gW3ZdOyB9KTsgLy8gQ29sdW1uIFZlY3RvclxuICAgICAgICB2YXIgb3V0cHV0VmVjdG9yID0gdGhpcy5vdXRwdXRzW3RoaXMub3V0cHV0cy5sZW5ndGggLSAxXTsgLy8gQ29sdW1uIFZlY3RvclxuICAgICAgICB2YXIgb3V0cHV0TGF5ZXJTaXplID0gdGhpcy5vcHRpb25zLnNpemVbdGhpcy5vcHRpb25zLnNpemUubGVuZ3RoIC0gMV07XG4gICAgICAgIHZhciBlcnJvclN1bSA9IDA7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgb3V0cHV0TGF5ZXJTaXplOyBpKyspIHtcbiAgICAgICAgICAgIHZhciBvID0gb3V0cHV0VmVjdG9yWzBdW2ldLCB0ID0gdGFyZ2V0VmVjdG9yWzBdW2ldO1xuICAgICAgICAgICAgZXJyb3JTdW0gKz0gdGhpcy5vcHRpb25zLmVycm9yLmVycm9yKG8sIHQpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBlcnJvclN1bTtcbiAgICB9O1xuICAgIEFOTi5wcm90b3R5cGUuYmFja1Byb3BhZ2F0ZSA9IGZ1bmN0aW9uICh0YXJnZXQpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgLy8gUmVzZXQgb2xkIGRlbHRhc1xuICAgICAgICB0aGlzLmRlbHRhcyA9IFtdO1xuICAgICAgICAvLyBDYWxjdWxhdGUgb3V0cHV0IGxheWVyIGRlbHRhIHZlY3RvclxuICAgICAgICB2YXIgb3V0cHV0VmVjdG9yID0gdGhpcy5vdXRwdXRzW3RoaXMub3V0cHV0cy5sZW5ndGggLSAxXTtcbiAgICAgICAgLy8gRXJyb3IgZnVuY3Rpb24gZGVyaXZhdGl2ZVxuICAgICAgICB2YXIgZXJyb3JEZXJpdmF0aXZlID0gW291dHB1dFZlY3RvclswXS5tYXAoZnVuY3Rpb24gKG8sIGkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gX3RoaXMub3B0aW9ucy5lcnJvci5kZXIobywgdGFyZ2V0W2ldKTtcbiAgICAgICAgICAgIH0pXTtcbiAgICAgICAgLy8gQ2FsY3VsYXRlIERlbHRhIGJ5IG11bHRpcGx5aW5nIHdpdGggb3V0cHV0IGxheWVyIGcnKGlucHV0cylcbiAgICAgICAgdmFyIGRlbHRhID0gX18xLk1hdGhzLlRlbnNvcjJELkVsZW1lbnRXaXNlLm11bHRpcGx5KGVycm9yRGVyaXZhdGl2ZSwgX18xLk1hdGhzLlRlbnNvcjJELmFwcGx5KHRoaXMuaW5wdXRzW3RoaXMuaW5wdXRzLmxlbmd0aCAtIDFdLCB0aGlzLm9wdGlvbnMuYWN0aXZhdGlvbi5kZXIpKTtcbiAgICAgICAgLy8gU2F2ZSBvdXRwdXQgbGF5ZXIgZGVsdGEgdmVjdG9yXG4gICAgICAgIHRoaXMuZGVsdGFzLnVuc2hpZnQoZGVsdGEpO1xuICAgICAgICBmb3IgKHZhciBsID0gdGhpcy5vcHRpb25zLnNpemUubGVuZ3RoIC0gMjsgbCA+IDA7IGwtLSkge1xuICAgICAgICAgICAgdmFyIGxhc3RMYXllckRlbHRhID0gdGhpcy5kZWx0YXNbMF07XG4gICAgICAgICAgICB2YXIgd2VpZ2h0c1QgPSBfXzEuTWF0aHMuVGVuc29yMkQudHJhbnNwb3NlKHRoaXMud2VpZ2h0c1tsXSk7XG4gICAgICAgICAgICB2YXIgbGF5ZXJJbnB1dCA9IHRoaXMuaW5wdXRzW2xdO1xuICAgICAgICAgICAgdmFyIGRvdFdlaWdodHNUX0xhc3RMYXllckRlbHRhID0gX18xLk1hdGhzLlRlbnNvcjJELmRvdCh3ZWlnaHRzVCwgbGFzdExheWVyRGVsdGEpO1xuICAgICAgICAgICAgdmFyIGRlbHRhXzEgPSBfXzEuTWF0aHMuVGVuc29yMkQuRWxlbWVudFdpc2UubXVsdGlwbHkoZG90V2VpZ2h0c1RfTGFzdExheWVyRGVsdGEsIF9fMS5NYXRocy5UZW5zb3IyRC5hcHBseShsYXllcklucHV0LCB0aGlzLm9wdGlvbnMuYWN0aXZhdGlvbi5kZXIpKTtcbiAgICAgICAgICAgIHRoaXMuZGVsdGFzLnVuc2hpZnQoZGVsdGFfMSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIEFOTi5wcm90b3R5cGUudXBkYXRlV2VpZ2h0cyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHdlaWdodHNEZXJpdmF0aXZlcyA9IFtdO1xuICAgICAgICBmb3IgKHZhciBsID0gdGhpcy5vcHRpb25zLnNpemUubGVuZ3RoIC0gMTsgbCA+IDA7IGwtLSkge1xuICAgICAgICAgICAgdmFyIG91dHB1dFByZXZMYXllciA9IHRoaXMub3V0cHV0c1tsIC0gMV07XG4gICAgICAgICAgICB2YXIgZGVsdGEgPSB0aGlzLm91dHB1dHNbbF07XG4gICAgICAgICAgICB2YXIgd2VpZ2h0c0Rlcml2YXRpdmUgPSBfXzEuTWF0aHMuVGVuc29yMkQuZG90KGRlbHRhLCBfXzEuTWF0aHMuVGVuc29yMkQudHJhbnNwb3NlKG91dHB1dFByZXZMYXllcikpO1xuICAgICAgICAgICAgdmFyIHdlaWdodHMgPSB0aGlzLndlaWdodHNbbCAtIDFdO1xuICAgICAgICAgICAgdGhpcy53ZWlnaHRzW2wgLSAxXSA9IF9fMS5NYXRocy5UZW5zb3IyRC5FbGVtZW50V2lzZS5zdWJ0cmFjdCh3ZWlnaHRzLCBfXzEuTWF0aHMuVGVuc29yMkQuRWxlbWVudFdpc2Uuc2NhbGUod2VpZ2h0c0Rlcml2YXRpdmUsIHRoaXMub3B0aW9ucy5sZWFybmluZ1JhdGUpKTtcbiAgICAgICAgICAgIHRoaXMuYmlhc2VzW2wgLSAxXSA9IF9fMS5NYXRocy5UZW5zb3IyRC5FbGVtZW50V2lzZS5zdWJ0cmFjdCh0aGlzLmJpYXNlc1tsIC0gMV0sIF9fMS5NYXRocy5UZW5zb3IyRC5FbGVtZW50V2lzZS5zY2FsZShkZWx0YSwgdGhpcy5vcHRpb25zLmxlYXJuaW5nUmF0ZSkpO1xuICAgICAgICAgICAgd2VpZ2h0c0Rlcml2YXRpdmVzLnVuc2hpZnQod2VpZ2h0c0Rlcml2YXRpdmUpO1xuICAgICAgICB9XG4gICAgICAgIC8vY29uc29sZS5sb2coZGVyaXZhdGl2ZXMpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBAcGFyYW0gaW5wdXQgVmVjdG9yIG9mIElucHV0IHZhbHVlcyBtYXRjaGluZyBuZXR3b3JrIHNpemVcbiAgICAgKi9cbiAgICBBTk4ucHJvdG90eXBlLnF1ZXJ5ID0gZnVuY3Rpb24gKGlucHV0KSB7XG4gICAgICAgIC8vQ2xlYXIgc2V0IHRlbnNvcnNcbiAgICAgICAgdGhpcy5pbnB1dHMgPSBbXTtcbiAgICAgICAgdGhpcy5vdXRwdXRzID0gW107XG4gICAgICAgIC8vIENvbnZlcnQgdG8gdGVuc29yLCB3aGljaCBpcyBhIGNvbHVtbiB2ZWN0b3JcbiAgICAgICAgdmFyIGlucHV0VmVjdG9yID0gaW5wdXQubWFwKGZ1bmN0aW9uIChpKSB7IHJldHVybiBbaV07IH0pO1xuICAgICAgICAvLyBTdG9yZSBpbnB1dHMgaW4gYXBwcm9wcmlhdGUgdGVuc29yc1xuICAgICAgICB0aGlzLmlucHV0cy5wdXNoKGlucHV0VmVjdG9yKTtcbiAgICAgICAgdGhpcy5vdXRwdXRzLnB1c2goaW5wdXRWZWN0b3IpO1xuICAgICAgICAvLyBGb3J3YXJkIHByb3BhZ2F0aW9uXG4gICAgICAgIHZhciB0bXAgPSBpbnB1dFZlY3RvcjtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLndlaWdodHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIC8vIENhbGN1bGF0ZSBJbnB1dCBWYWx1ZXNcbiAgICAgICAgICAgIHZhciBiZWZvcmVBY3RpdmF0aW9uID0gX18xLk1hdGhzLlRlbnNvcjJELmRvdCh0aGlzLndlaWdodHNbaV0sIHRtcCk7XG4gICAgICAgICAgICAvLyBBZGQgQmlhcyB0ZXJtc1xuICAgICAgICAgICAgYmVmb3JlQWN0aXZhdGlvbiA9IF9fMS5NYXRocy5UZW5zb3IyRC5FbGVtZW50V2lzZS5hZGQoYmVmb3JlQWN0aXZhdGlvbiwgdGhpcy5iaWFzZXNbaV0pO1xuICAgICAgICAgICAgLy8gU2F2ZSBiZWZvcmVBY3RpdmF0aW9uIHZlY3RvclxuICAgICAgICAgICAgdGhpcy5pbnB1dHMucHVzaChiZWZvcmVBY3RpdmF0aW9uKTtcbiAgICAgICAgICAgIC8vIEFwcGx5IGFjdGl2YXRpb24gZnVuY3Rpb24gdG8gbGF5ZXJcbiAgICAgICAgICAgIHZhciBhY3Rpdml0eSA9IF9fMS5NYXRocy5UZW5zb3IyRC5hcHBseShiZWZvcmVBY3RpdmF0aW9uLCB0aGlzLm9wdGlvbnMuYWN0aXZhdGlvbi5vdXRwdXQpO1xuICAgICAgICAgICAgLy8gU2F2ZSBsYXllciBhY3Rpdml0eSBhcyBvdXRwdXRcbiAgICAgICAgICAgIHRoaXMub3V0cHV0cy5wdXNoKGFjdGl2aXR5KTtcbiAgICAgICAgICAgIC8vIFNldCB0aGlzIGZvciB0bXBcbiAgICAgICAgICAgIHRtcCA9IGFjdGl2aXR5O1xuICAgICAgICB9XG4gICAgICAgIHZhciBvdXRwdXQgPSB0bXA7XG4gICAgICAgIC8vIFJldHVybiByZXN1bHQgYXMgYXJyYXlcbiAgICAgICAgcmV0dXJuIF9fMS5NYXRocy5UZW5zb3IyRC50cmFuc3Bvc2Uob3V0cHV0KVswXTtcbiAgICB9O1xuICAgIHJldHVybiBBTk47XG59KCkpO1xuZXhwb3J0cy5BTk4gPSBBTk47XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL3NyYy9OZXVyYWxOZXR3b3Jrcy9hbm4yLnRzXG4vLyBtb2R1bGUgaWQgPSAzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOyIsInNvdXJjZVJvb3QiOiIifQ==");

/***/ }),
/* 4 */
/* unknown exports provided */
/* all exports used */
/*!**********************************************!*\
  !*** ./src/NeuralNetworks/errorFunctions.ts ***!
  \**********************************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar Errors = (function () {\n    function Errors() {\n    }\n    return Errors;\n}());\nErrors.SQUARE = {\n    error: function (output, target) { return 0.5 * Math.pow(output - target, 2); },\n    der: function (output, target) { return output - target; }\n};\nErrors.CROSS_ENTROPY = {\n    error: function (output, target) {\n        return -(target * Math.log(output) + (1 - target) * Math.log(1 - output));\n    },\n    der: function (output, target) {\n        return (output - target) / ((1 - output) * output);\n    }\n};\nexports.Errors = Errors;\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNC5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL3NyYy9OZXVyYWxOZXR3b3Jrcy9lcnJvckZ1bmN0aW9ucy50cz9kYzkzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIEVycm9ycyA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gRXJyb3JzKCkge1xuICAgIH1cbiAgICByZXR1cm4gRXJyb3JzO1xufSgpKTtcbkVycm9ycy5TUVVBUkUgPSB7XG4gICAgZXJyb3I6IGZ1bmN0aW9uIChvdXRwdXQsIHRhcmdldCkgeyByZXR1cm4gMC41ICogTWF0aC5wb3cob3V0cHV0IC0gdGFyZ2V0LCAyKTsgfSxcbiAgICBkZXI6IGZ1bmN0aW9uIChvdXRwdXQsIHRhcmdldCkgeyByZXR1cm4gb3V0cHV0IC0gdGFyZ2V0OyB9XG59O1xuRXJyb3JzLkNST1NTX0VOVFJPUFkgPSB7XG4gICAgZXJyb3I6IGZ1bmN0aW9uIChvdXRwdXQsIHRhcmdldCkge1xuICAgICAgICByZXR1cm4gLSh0YXJnZXQgKiBNYXRoLmxvZyhvdXRwdXQpICsgKDEgLSB0YXJnZXQpICogTWF0aC5sb2coMSAtIG91dHB1dCkpO1xuICAgIH0sXG4gICAgZGVyOiBmdW5jdGlvbiAob3V0cHV0LCB0YXJnZXQpIHtcbiAgICAgICAgcmV0dXJuIChvdXRwdXQgLSB0YXJnZXQpIC8gKCgxIC0gb3V0cHV0KSAqIG91dHB1dCk7XG4gICAgfVxufTtcbmV4cG9ydHMuRXJyb3JzID0gRXJyb3JzO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9zcmMvTmV1cmFsTmV0d29ya3MvZXJyb3JGdW5jdGlvbnMudHNcbi8vIG1vZHVsZSBpZCA9IDRcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOyIsInNvdXJjZVJvb3QiOiIifQ==");

/***/ }),
/* 5 */
/* unknown exports provided */
/* all exports used */
/*!**********************************!*\
  !*** ./src/helper/generators.ts ***!
  \**********************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar __1 = __webpack_require__(/*! .. */ 0);\nvar Generators;\n(function (Generators) {\n    function clouds(clouds, dataPointsForCloud, dimensions, min, max, spread) {\n        if (dataPointsForCloud === void 0) { dataPointsForCloud = 10; }\n        if (dimensions === void 0) { dimensions = 2; }\n        if (min === void 0) { min = 0; }\n        if (max === void 0) { max = 1; }\n        if (spread === void 0) { spread = 0.1; }\n        var range = max - min;\n        var clusterCenters = new Array(clouds).fill(0).map(function (c) { return new Array(dimensions).fill(0).map(function (c) { return __1.Maths.random(min, max); }); });\n        var data = [];\n        for (var _i = 0, clusterCenters_1 = clusterCenters; _i < clusterCenters_1.length; _i++) {\n            var center = clusterCenters_1[_i];\n            var points = [];\n            for (var i = 0; i < dataPointsForCloud; i++) {\n                points.push(center.map(function (c) { return c += (__1.Maths.randomBool() ? -1 : 1) * spread * __1.Maths.random(min, max); }));\n            }\n            data.push({ center: center, points: points });\n        }\n        return data;\n    }\n    Generators.clouds = clouds;\n})(Generators = exports.Generators || (exports.Generators = {}));\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNS5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL3NyYy9oZWxwZXIvZ2VuZXJhdG9ycy50cz85M2ZiIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIF9fMSA9IHJlcXVpcmUoXCIuLlwiKTtcbnZhciBHZW5lcmF0b3JzO1xuKGZ1bmN0aW9uIChHZW5lcmF0b3JzKSB7XG4gICAgZnVuY3Rpb24gY2xvdWRzKGNsb3VkcywgZGF0YVBvaW50c0ZvckNsb3VkLCBkaW1lbnNpb25zLCBtaW4sIG1heCwgc3ByZWFkKSB7XG4gICAgICAgIGlmIChkYXRhUG9pbnRzRm9yQ2xvdWQgPT09IHZvaWQgMCkgeyBkYXRhUG9pbnRzRm9yQ2xvdWQgPSAxMDsgfVxuICAgICAgICBpZiAoZGltZW5zaW9ucyA9PT0gdm9pZCAwKSB7IGRpbWVuc2lvbnMgPSAyOyB9XG4gICAgICAgIGlmIChtaW4gPT09IHZvaWQgMCkgeyBtaW4gPSAwOyB9XG4gICAgICAgIGlmIChtYXggPT09IHZvaWQgMCkgeyBtYXggPSAxOyB9XG4gICAgICAgIGlmIChzcHJlYWQgPT09IHZvaWQgMCkgeyBzcHJlYWQgPSAwLjE7IH1cbiAgICAgICAgdmFyIHJhbmdlID0gbWF4IC0gbWluO1xuICAgICAgICB2YXIgY2x1c3RlckNlbnRlcnMgPSBuZXcgQXJyYXkoY2xvdWRzKS5maWxsKDApLm1hcChmdW5jdGlvbiAoYykgeyByZXR1cm4gbmV3IEFycmF5KGRpbWVuc2lvbnMpLmZpbGwoMCkubWFwKGZ1bmN0aW9uIChjKSB7IHJldHVybiBfXzEuTWF0aHMucmFuZG9tKG1pbiwgbWF4KTsgfSk7IH0pO1xuICAgICAgICB2YXIgZGF0YSA9IFtdO1xuICAgICAgICBmb3IgKHZhciBfaSA9IDAsIGNsdXN0ZXJDZW50ZXJzXzEgPSBjbHVzdGVyQ2VudGVyczsgX2kgPCBjbHVzdGVyQ2VudGVyc18xLmxlbmd0aDsgX2krKykge1xuICAgICAgICAgICAgdmFyIGNlbnRlciA9IGNsdXN0ZXJDZW50ZXJzXzFbX2ldO1xuICAgICAgICAgICAgdmFyIHBvaW50cyA9IFtdO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBkYXRhUG9pbnRzRm9yQ2xvdWQ7IGkrKykge1xuICAgICAgICAgICAgICAgIHBvaW50cy5wdXNoKGNlbnRlci5tYXAoZnVuY3Rpb24gKGMpIHsgcmV0dXJuIGMgKz0gKF9fMS5NYXRocy5yYW5kb21Cb29sKCkgPyAtMSA6IDEpICogc3ByZWFkICogX18xLk1hdGhzLnJhbmRvbShtaW4sIG1heCk7IH0pKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGRhdGEucHVzaCh7IGNlbnRlcjogY2VudGVyLCBwb2ludHM6IHBvaW50cyB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZGF0YTtcbiAgICB9XG4gICAgR2VuZXJhdG9ycy5jbG91ZHMgPSBjbG91ZHM7XG59KShHZW5lcmF0b3JzID0gZXhwb3J0cy5HZW5lcmF0b3JzIHx8IChleHBvcnRzLkdlbmVyYXRvcnMgPSB7fSkpO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9zcmMvaGVscGVyL2dlbmVyYXRvcnMudHNcbi8vIG1vZHVsZSBpZCA9IDVcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOyIsInNvdXJjZVJvb3QiOiIifQ==");

/***/ }),
/* 6 */
/* unknown exports provided */
/* all exports used */
/*!************************************!*\
  !*** ./src/helper/labelToValue.ts ***!
  \************************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar LabelToValue = (function () {\n    function LabelToValue() {\n        this.dictionary = [];\n    }\n    LabelToValue.prototype.toValue = function (label) {\n        if (this.dictionary.includes(label)) {\n            return this.dictionary.indexOf(label);\n        }\n        else {\n            this.dictionary.push(label);\n            return this.dictionary.length - 1;\n        }\n    };\n    LabelToValue.prototype.toLabel = function (value) {\n        return this.dictionary[value];\n    };\n    return LabelToValue;\n}());\nexports.LabelToValue = LabelToValue;\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNi5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL3NyYy9oZWxwZXIvbGFiZWxUb1ZhbHVlLnRzP2JiMjQiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgTGFiZWxUb1ZhbHVlID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBMYWJlbFRvVmFsdWUoKSB7XG4gICAgICAgIHRoaXMuZGljdGlvbmFyeSA9IFtdO1xuICAgIH1cbiAgICBMYWJlbFRvVmFsdWUucHJvdG90eXBlLnRvVmFsdWUgPSBmdW5jdGlvbiAobGFiZWwpIHtcbiAgICAgICAgaWYgKHRoaXMuZGljdGlvbmFyeS5pbmNsdWRlcyhsYWJlbCkpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmRpY3Rpb25hcnkuaW5kZXhPZihsYWJlbCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmRpY3Rpb25hcnkucHVzaChsYWJlbCk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5kaWN0aW9uYXJ5Lmxlbmd0aCAtIDE7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIExhYmVsVG9WYWx1ZS5wcm90b3R5cGUudG9MYWJlbCA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5kaWN0aW9uYXJ5W3ZhbHVlXTtcbiAgICB9O1xuICAgIHJldHVybiBMYWJlbFRvVmFsdWU7XG59KCkpO1xuZXhwb3J0cy5MYWJlbFRvVmFsdWUgPSBMYWJlbFRvVmFsdWU7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL3NyYy9oZWxwZXIvbGFiZWxUb1ZhbHVlLnRzXG4vLyBtb2R1bGUgaWQgPSA2XG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOyIsInNvdXJjZVJvb3QiOiIifQ==");

/***/ }),
/* 7 */
/* unknown exports provided */
/* all exports used */
/*!*********************************!*\
  !*** ./src/helper/utilities.ts ***!
  \*********************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar __1 = __webpack_require__(/*! .. */ 0);\nvar Utilities;\n(function (Utilities) {\n    function repeat(func, iterations) {\n        for (var i = 0; i < iterations; i++) {\n            func(i);\n        }\n    }\n    Utilities.repeat = repeat;\n    function csvStringToJSON(csv, tryObjectParseIfPossible, columnSeparator, rowSeparator) {\n        if (tryObjectParseIfPossible === void 0) { tryObjectParseIfPossible = true; }\n        if (columnSeparator === void 0) { columnSeparator = ','; }\n        if (rowSeparator === void 0) { rowSeparator = '\\r\\n'; }\n        var data = csv.trim().split(rowSeparator).map(function (r) { return r.split(columnSeparator).map(function (c) { return isNaN(c) ? c : parseFloat(c); }); });\n        if (data[0].every(function (c) { return typeof c == 'string'; }) && tryObjectParseIfPossible) {\n            var labels_1 = data.splice(0, 1)[0];\n            var jsonData = data.map(function (r, i) {\n                var rowObject = {};\n                for (var i_1 = 0; i_1 < labels_1.length; i_1++) {\n                    rowObject[labels_1[i_1]] = r[i_1];\n                }\n                return rowObject;\n            });\n            return jsonData;\n        }\n        else {\n            return data;\n        }\n    }\n    Utilities.csvStringToJSON = csvStringToJSON;\n    function pickRandomFromArray(array) {\n        return array[__1.Maths.randomInt(0, array.length - 1)];\n    }\n    Utilities.pickRandomFromArray = pickRandomFromArray;\n    function tokenize(str, exp) {\n        if (exp === void 0) { exp = /\\W/; }\n        return str.split(exp).filter(function (t) { return t.trim() != ''; });\n    }\n    Utilities.tokenize = tokenize;\n})(Utilities = exports.Utilities || (exports.Utilities = {}));\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL3NyYy9oZWxwZXIvdXRpbGl0aWVzLnRzP2VlYmQiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgX18xID0gcmVxdWlyZShcIi4uXCIpO1xudmFyIFV0aWxpdGllcztcbihmdW5jdGlvbiAoVXRpbGl0aWVzKSB7XG4gICAgZnVuY3Rpb24gcmVwZWF0KGZ1bmMsIGl0ZXJhdGlvbnMpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBpdGVyYXRpb25zOyBpKyspIHtcbiAgICAgICAgICAgIGZ1bmMoaSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgVXRpbGl0aWVzLnJlcGVhdCA9IHJlcGVhdDtcbiAgICBmdW5jdGlvbiBjc3ZTdHJpbmdUb0pTT04oY3N2LCB0cnlPYmplY3RQYXJzZUlmUG9zc2libGUsIGNvbHVtblNlcGFyYXRvciwgcm93U2VwYXJhdG9yKSB7XG4gICAgICAgIGlmICh0cnlPYmplY3RQYXJzZUlmUG9zc2libGUgPT09IHZvaWQgMCkgeyB0cnlPYmplY3RQYXJzZUlmUG9zc2libGUgPSB0cnVlOyB9XG4gICAgICAgIGlmIChjb2x1bW5TZXBhcmF0b3IgPT09IHZvaWQgMCkgeyBjb2x1bW5TZXBhcmF0b3IgPSAnLCc7IH1cbiAgICAgICAgaWYgKHJvd1NlcGFyYXRvciA9PT0gdm9pZCAwKSB7IHJvd1NlcGFyYXRvciA9ICdcXHJcXG4nOyB9XG4gICAgICAgIHZhciBkYXRhID0gY3N2LnRyaW0oKS5zcGxpdChyb3dTZXBhcmF0b3IpLm1hcChmdW5jdGlvbiAocikgeyByZXR1cm4gci5zcGxpdChjb2x1bW5TZXBhcmF0b3IpLm1hcChmdW5jdGlvbiAoYykgeyByZXR1cm4gaXNOYU4oYykgPyBjIDogcGFyc2VGbG9hdChjKTsgfSk7IH0pO1xuICAgICAgICBpZiAoZGF0YVswXS5ldmVyeShmdW5jdGlvbiAoYykgeyByZXR1cm4gdHlwZW9mIGMgPT0gJ3N0cmluZyc7IH0pICYmIHRyeU9iamVjdFBhcnNlSWZQb3NzaWJsZSkge1xuICAgICAgICAgICAgdmFyIGxhYmVsc18xID0gZGF0YS5zcGxpY2UoMCwgMSlbMF07XG4gICAgICAgICAgICB2YXIganNvbkRhdGEgPSBkYXRhLm1hcChmdW5jdGlvbiAociwgaSkge1xuICAgICAgICAgICAgICAgIHZhciByb3dPYmplY3QgPSB7fTtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpXzEgPSAwOyBpXzEgPCBsYWJlbHNfMS5sZW5ndGg7IGlfMSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIHJvd09iamVjdFtsYWJlbHNfMVtpXzFdXSA9IHJbaV8xXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJvd09iamVjdDtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIGpzb25EYXRhO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIGRhdGE7XG4gICAgICAgIH1cbiAgICB9XG4gICAgVXRpbGl0aWVzLmNzdlN0cmluZ1RvSlNPTiA9IGNzdlN0cmluZ1RvSlNPTjtcbiAgICBmdW5jdGlvbiBwaWNrUmFuZG9tRnJvbUFycmF5KGFycmF5KSB7XG4gICAgICAgIHJldHVybiBhcnJheVtfXzEuTWF0aHMucmFuZG9tSW50KDAsIGFycmF5Lmxlbmd0aCAtIDEpXTtcbiAgICB9XG4gICAgVXRpbGl0aWVzLnBpY2tSYW5kb21Gcm9tQXJyYXkgPSBwaWNrUmFuZG9tRnJvbUFycmF5O1xuICAgIGZ1bmN0aW9uIHRva2VuaXplKHN0ciwgZXhwKSB7XG4gICAgICAgIGlmIChleHAgPT09IHZvaWQgMCkgeyBleHAgPSAvXFxXLzsgfVxuICAgICAgICByZXR1cm4gc3RyLnNwbGl0KGV4cCkuZmlsdGVyKGZ1bmN0aW9uICh0KSB7IHJldHVybiB0LnRyaW0oKSAhPSAnJzsgfSk7XG4gICAgfVxuICAgIFV0aWxpdGllcy50b2tlbml6ZSA9IHRva2VuaXplO1xufSkoVXRpbGl0aWVzID0gZXhwb3J0cy5VdGlsaXRpZXMgfHwgKGV4cG9ydHMuVXRpbGl0aWVzID0ge30pKTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vc3JjL2hlbHBlci91dGlsaXRpZXMudHNcbi8vIG1vZHVsZSBpZCA9IDdcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Iiwic291cmNlUm9vdCI6IiJ9");

/***/ }),
/* 8 */
/* unknown exports provided */
/* all exports used */
/*!************************!*\
  !*** ./src/k-means.ts ***!
  \************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar _1 = __webpack_require__(/*! . */ 0);\nvar KMeans = (function () {\n    function KMeans(data, numberOfClusters) {\n        var _this = this;\n        this.data = data;\n        this.numberOfClusters = numberOfClusters;\n        this.clusters = [];\n        _1.Utilities.repeat(function () {\n            _this.clusters.push(_1.Utilities.pickRandomFromArray(data));\n        }, numberOfClusters);\n    }\n    KMeans.prototype.fitClusters = function (distanceFunction) {\n        /*console.log('Data');\n        console.log(this.data[0]);*/\n        var _this = this;\n        if (distanceFunction === void 0) { distanceFunction = _1.Distances.EUCLIDEAN; }\n        var clusterChanged;\n        var _loop_1 = function () {\n            clusterChanged = false;\n            var clusterRecord = [];\n            var _loop_2 = function (point) {\n                var distances = this_1.clusters.map(function (c) { return distanceFunction(point, c); });\n                //console.log(distances);\n                var min = Math.min.apply(Math, distances);\n                var clusterIndex = distances.indexOf(min);\n                clusterRecord.push(clusterIndex);\n            };\n            for (var _i = 0, _a = this_1.data; _i < _a.length; _i++) {\n                var point = _a[_i];\n                _loop_2(point);\n            }\n            //console.log(clusterRecord);\n            this_1.clusters.forEach(function (c, ci) {\n                var pointsForCluster = clusterRecord.map(function (cr, i) { return cr == ci ? _this.data[i] : null; }).filter(function (c) { return c != null; });\n                var numberOfPoints = pointsForCluster.length;\n                var meanPoint = pointsForCluster.reduce(function (s, p) {\n                    if (p != undefined) {\n                        return s.map(function (v, i) { return v + p[i]; });\n                    }\n                }, new Array(_this.data[0].length).fill(0)).map(function (c) { return c / numberOfPoints; });\n                if (meanPoint.every(function (v, i) { return v != c[i]; })) {\n                    _this.clusters[ci] = meanPoint;\n                    clusterChanged = true;\n                }\n            });\n        };\n        var this_1 = this;\n        do {\n            _loop_1();\n        } while (clusterChanged);\n        return this.clusters;\n    };\n    return KMeans;\n}());\nexports.KMeans = KMeans;\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiOC5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL3NyYy9rLW1lYW5zLnRzPzc0ODIiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgXzEgPSByZXF1aXJlKFwiLlwiKTtcbnZhciBLTWVhbnMgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIEtNZWFucyhkYXRhLCBudW1iZXJPZkNsdXN0ZXJzKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHRoaXMuZGF0YSA9IGRhdGE7XG4gICAgICAgIHRoaXMubnVtYmVyT2ZDbHVzdGVycyA9IG51bWJlck9mQ2x1c3RlcnM7XG4gICAgICAgIHRoaXMuY2x1c3RlcnMgPSBbXTtcbiAgICAgICAgXzEuVXRpbGl0aWVzLnJlcGVhdChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBfdGhpcy5jbHVzdGVycy5wdXNoKF8xLlV0aWxpdGllcy5waWNrUmFuZG9tRnJvbUFycmF5KGRhdGEpKTtcbiAgICAgICAgfSwgbnVtYmVyT2ZDbHVzdGVycyk7XG4gICAgfVxuICAgIEtNZWFucy5wcm90b3R5cGUuZml0Q2x1c3RlcnMgPSBmdW5jdGlvbiAoZGlzdGFuY2VGdW5jdGlvbikge1xuICAgICAgICAvKmNvbnNvbGUubG9nKCdEYXRhJyk7XG4gICAgICAgIGNvbnNvbGUubG9nKHRoaXMuZGF0YVswXSk7Ki9cbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgaWYgKGRpc3RhbmNlRnVuY3Rpb24gPT09IHZvaWQgMCkgeyBkaXN0YW5jZUZ1bmN0aW9uID0gXzEuRGlzdGFuY2VzLkVVQ0xJREVBTjsgfVxuICAgICAgICB2YXIgY2x1c3RlckNoYW5nZWQ7XG4gICAgICAgIHZhciBfbG9vcF8xID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgY2x1c3RlckNoYW5nZWQgPSBmYWxzZTtcbiAgICAgICAgICAgIHZhciBjbHVzdGVyUmVjb3JkID0gW107XG4gICAgICAgICAgICB2YXIgX2xvb3BfMiA9IGZ1bmN0aW9uIChwb2ludCkge1xuICAgICAgICAgICAgICAgIHZhciBkaXN0YW5jZXMgPSB0aGlzXzEuY2x1c3RlcnMubWFwKGZ1bmN0aW9uIChjKSB7IHJldHVybiBkaXN0YW5jZUZ1bmN0aW9uKHBvaW50LCBjKTsgfSk7XG4gICAgICAgICAgICAgICAgLy9jb25zb2xlLmxvZyhkaXN0YW5jZXMpO1xuICAgICAgICAgICAgICAgIHZhciBtaW4gPSBNYXRoLm1pbi5hcHBseShNYXRoLCBkaXN0YW5jZXMpO1xuICAgICAgICAgICAgICAgIHZhciBjbHVzdGVySW5kZXggPSBkaXN0YW5jZXMuaW5kZXhPZihtaW4pO1xuICAgICAgICAgICAgICAgIGNsdXN0ZXJSZWNvcmQucHVzaChjbHVzdGVySW5kZXgpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGZvciAodmFyIF9pID0gMCwgX2EgPSB0aGlzXzEuZGF0YTsgX2kgPCBfYS5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICAgICAgICB2YXIgcG9pbnQgPSBfYVtfaV07XG4gICAgICAgICAgICAgICAgX2xvb3BfMihwb2ludCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvL2NvbnNvbGUubG9nKGNsdXN0ZXJSZWNvcmQpO1xuICAgICAgICAgICAgdGhpc18xLmNsdXN0ZXJzLmZvckVhY2goZnVuY3Rpb24gKGMsIGNpKSB7XG4gICAgICAgICAgICAgICAgdmFyIHBvaW50c0ZvckNsdXN0ZXIgPSBjbHVzdGVyUmVjb3JkLm1hcChmdW5jdGlvbiAoY3IsIGkpIHsgcmV0dXJuIGNyID09IGNpID8gX3RoaXMuZGF0YVtpXSA6IG51bGw7IH0pLmZpbHRlcihmdW5jdGlvbiAoYykgeyByZXR1cm4gYyAhPSBudWxsOyB9KTtcbiAgICAgICAgICAgICAgICB2YXIgbnVtYmVyT2ZQb2ludHMgPSBwb2ludHNGb3JDbHVzdGVyLmxlbmd0aDtcbiAgICAgICAgICAgICAgICB2YXIgbWVhblBvaW50ID0gcG9pbnRzRm9yQ2x1c3Rlci5yZWR1Y2UoZnVuY3Rpb24gKHMsIHApIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHAgIT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcy5tYXAoZnVuY3Rpb24gKHYsIGkpIHsgcmV0dXJuIHYgKyBwW2ldOyB9KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0sIG5ldyBBcnJheShfdGhpcy5kYXRhWzBdLmxlbmd0aCkuZmlsbCgwKSkubWFwKGZ1bmN0aW9uIChjKSB7IHJldHVybiBjIC8gbnVtYmVyT2ZQb2ludHM7IH0pO1xuICAgICAgICAgICAgICAgIGlmIChtZWFuUG9pbnQuZXZlcnkoZnVuY3Rpb24gKHYsIGkpIHsgcmV0dXJuIHYgIT0gY1tpXTsgfSkpIHtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuY2x1c3RlcnNbY2ldID0gbWVhblBvaW50O1xuICAgICAgICAgICAgICAgICAgICBjbHVzdGVyQ2hhbmdlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH07XG4gICAgICAgIHZhciB0aGlzXzEgPSB0aGlzO1xuICAgICAgICBkbyB7XG4gICAgICAgICAgICBfbG9vcF8xKCk7XG4gICAgICAgIH0gd2hpbGUgKGNsdXN0ZXJDaGFuZ2VkKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2x1c3RlcnM7XG4gICAgfTtcbiAgICByZXR1cm4gS01lYW5zO1xufSgpKTtcbmV4cG9ydHMuS01lYW5zID0gS01lYW5zO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9zcmMvay1tZWFucy50c1xuLy8gbW9kdWxlIGlkID0gOFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTsiLCJzb3VyY2VSb290IjoiIn0=");

/***/ }),
/* 9 */
/* unknown exports provided */
/* all exports used */
/*!********************!*\
  !*** ./src/knn.ts ***!
  \********************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar _1 = __webpack_require__(/*! . */ 0);\nvar KNNClassifier = (function () {\n    function KNNClassifier(k, distanceFunction) {\n        if (k === void 0) { k = 3; }\n        if (distanceFunction === void 0) { distanceFunction = _1.Distances.EUCLIDEAN; }\n        this.k = k;\n        this.distanceFunction = distanceFunction;\n        this.data = [];\n        return this;\n    }\n    KNNClassifier.prototype.addData = function (classes, data) {\n        var _this = this;\n        classes.forEach(function (c, i) {\n            _this.data.push({\n                c: c,\n                attr: data[i]\n            });\n        });\n        return this;\n    };\n    KNNClassifier.prototype.predict = function (input, l2v) {\n        var _this = this;\n        var distances = [];\n        // Calculate distances\n        this.data.forEach(function (entry, i) {\n            return distances.push({\n                index: i,\n                distance: _this.distanceFunction(input, entry.attr)\n            });\n        });\n        // Sort distances\n        distances = distances.sort(function (a, b) {\n            if (a.distance > b.distance)\n                return 1;\n            if (a.distance < b.distance)\n                return -1;\n            return 0;\n        });\n        // get k smallest distances\n        var kNearest = distances.slice(0, this.k);\n        // get classes to those k distances from data array\n        var kNearestClasses = kNearest.map(function (e) { return _this.data[e.index].c; });\n        // get the most often occurring class\n        var c = _1.Maths.argmax(kNearestClasses);\n        // return value or class if l2v is passed\n        return l2v ? l2v.toLabel(c) : c;\n    };\n    return KNNClassifier;\n}());\nexports.KNNClassifier = KNNClassifier;\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiOS5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL3NyYy9rbm4udHM/MDNiNyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBfMSA9IHJlcXVpcmUoXCIuXCIpO1xudmFyIEtOTkNsYXNzaWZpZXIgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIEtOTkNsYXNzaWZpZXIoaywgZGlzdGFuY2VGdW5jdGlvbikge1xuICAgICAgICBpZiAoayA9PT0gdm9pZCAwKSB7IGsgPSAzOyB9XG4gICAgICAgIGlmIChkaXN0YW5jZUZ1bmN0aW9uID09PSB2b2lkIDApIHsgZGlzdGFuY2VGdW5jdGlvbiA9IF8xLkRpc3RhbmNlcy5FVUNMSURFQU47IH1cbiAgICAgICAgdGhpcy5rID0gaztcbiAgICAgICAgdGhpcy5kaXN0YW5jZUZ1bmN0aW9uID0gZGlzdGFuY2VGdW5jdGlvbjtcbiAgICAgICAgdGhpcy5kYXRhID0gW107XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICBLTk5DbGFzc2lmaWVyLnByb3RvdHlwZS5hZGREYXRhID0gZnVuY3Rpb24gKGNsYXNzZXMsIGRhdGEpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgY2xhc3Nlcy5mb3JFYWNoKGZ1bmN0aW9uIChjLCBpKSB7XG4gICAgICAgICAgICBfdGhpcy5kYXRhLnB1c2goe1xuICAgICAgICAgICAgICAgIGM6IGMsXG4gICAgICAgICAgICAgICAgYXR0cjogZGF0YVtpXVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuICAgIEtOTkNsYXNzaWZpZXIucHJvdG90eXBlLnByZWRpY3QgPSBmdW5jdGlvbiAoaW5wdXQsIGwydikge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB2YXIgZGlzdGFuY2VzID0gW107XG4gICAgICAgIC8vIENhbGN1bGF0ZSBkaXN0YW5jZXNcbiAgICAgICAgdGhpcy5kYXRhLmZvckVhY2goZnVuY3Rpb24gKGVudHJ5LCBpKSB7XG4gICAgICAgICAgICByZXR1cm4gZGlzdGFuY2VzLnB1c2goe1xuICAgICAgICAgICAgICAgIGluZGV4OiBpLFxuICAgICAgICAgICAgICAgIGRpc3RhbmNlOiBfdGhpcy5kaXN0YW5jZUZ1bmN0aW9uKGlucHV0LCBlbnRyeS5hdHRyKVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgICAgICAvLyBTb3J0IGRpc3RhbmNlc1xuICAgICAgICBkaXN0YW5jZXMgPSBkaXN0YW5jZXMuc29ydChmdW5jdGlvbiAoYSwgYikge1xuICAgICAgICAgICAgaWYgKGEuZGlzdGFuY2UgPiBiLmRpc3RhbmNlKVxuICAgICAgICAgICAgICAgIHJldHVybiAxO1xuICAgICAgICAgICAgaWYgKGEuZGlzdGFuY2UgPCBiLmRpc3RhbmNlKVxuICAgICAgICAgICAgICAgIHJldHVybiAtMTtcbiAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICB9KTtcbiAgICAgICAgLy8gZ2V0IGsgc21hbGxlc3QgZGlzdGFuY2VzXG4gICAgICAgIHZhciBrTmVhcmVzdCA9IGRpc3RhbmNlcy5zbGljZSgwLCB0aGlzLmspO1xuICAgICAgICAvLyBnZXQgY2xhc3NlcyB0byB0aG9zZSBrIGRpc3RhbmNlcyBmcm9tIGRhdGEgYXJyYXlcbiAgICAgICAgdmFyIGtOZWFyZXN0Q2xhc3NlcyA9IGtOZWFyZXN0Lm1hcChmdW5jdGlvbiAoZSkgeyByZXR1cm4gX3RoaXMuZGF0YVtlLmluZGV4XS5jOyB9KTtcbiAgICAgICAgLy8gZ2V0IHRoZSBtb3N0IG9mdGVuIG9jY3VycmluZyBjbGFzc1xuICAgICAgICB2YXIgYyA9IF8xLk1hdGhzLmFyZ21heChrTmVhcmVzdENsYXNzZXMpO1xuICAgICAgICAvLyByZXR1cm4gdmFsdWUgb3IgY2xhc3MgaWYgbDJ2IGlzIHBhc3NlZFxuICAgICAgICByZXR1cm4gbDJ2ID8gbDJ2LnRvTGFiZWwoYykgOiBjO1xuICAgIH07XG4gICAgcmV0dXJuIEtOTkNsYXNzaWZpZXI7XG59KCkpO1xuZXhwb3J0cy5LTk5DbGFzc2lmaWVyID0gS05OQ2xhc3NpZmllcjtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vc3JjL2tubi50c1xuLy8gbW9kdWxlIGlkID0gOVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOyIsInNvdXJjZVJvb3QiOiIifQ==");

/***/ }),
/* 10 */
/* unknown exports provided */
/* all exports used */
/*!*******************************!*\
  !*** ./src/math/distances.ts ***!
  \*******************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar Distances = (function () {\n    function Distances() {\n    }\n    return Distances;\n}());\nDistances.EUCLIDEAN = function (a, b) {\n    return Math.sqrt(a.reduce(function (s, a, i) {\n        return s + Math.pow(a - b[i], 2);\n    }, 0));\n};\nDistances.TAXI = function (a, b) {\n    return a.reduce(function (s, a, i) {\n        return s + Math.abs(a - b[i]);\n    }, 0);\n};\n// TODO: Understand\n// https://en.wikibooks.org/wiki/Algorithm_Implementation/Strings/Levenshtein_distance#JavaScript\nDistances.LEVENSHTEIN = function (a, b) {\n    if (a.length === 0)\n        return b.length;\n    if (b.length === 0)\n        return a.length;\n    return Math.min(Distances.LEVENSHTEIN(a.substr(1), b) + 1, Distances.LEVENSHTEIN(b.substr(1), a) + 1, Distances.LEVENSHTEIN(a.substr(1), b.substr(1)) + (a[0] !== b[0] ? 1 : 0));\n};\nexports.Distances = Distances;\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTAuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvbWF0aC9kaXN0YW5jZXMudHM/YzA5YyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBEaXN0YW5jZXMgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIERpc3RhbmNlcygpIHtcbiAgICB9XG4gICAgcmV0dXJuIERpc3RhbmNlcztcbn0oKSk7XG5EaXN0YW5jZXMuRVVDTElERUFOID0gZnVuY3Rpb24gKGEsIGIpIHtcbiAgICByZXR1cm4gTWF0aC5zcXJ0KGEucmVkdWNlKGZ1bmN0aW9uIChzLCBhLCBpKSB7XG4gICAgICAgIHJldHVybiBzICsgTWF0aC5wb3coYSAtIGJbaV0sIDIpO1xuICAgIH0sIDApKTtcbn07XG5EaXN0YW5jZXMuVEFYSSA9IGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgcmV0dXJuIGEucmVkdWNlKGZ1bmN0aW9uIChzLCBhLCBpKSB7XG4gICAgICAgIHJldHVybiBzICsgTWF0aC5hYnMoYSAtIGJbaV0pO1xuICAgIH0sIDApO1xufTtcbi8vIFRPRE86IFVuZGVyc3RhbmRcbi8vIGh0dHBzOi8vZW4ud2lraWJvb2tzLm9yZy93aWtpL0FsZ29yaXRobV9JbXBsZW1lbnRhdGlvbi9TdHJpbmdzL0xldmVuc2h0ZWluX2Rpc3RhbmNlI0phdmFTY3JpcHRcbkRpc3RhbmNlcy5MRVZFTlNIVEVJTiA9IGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgaWYgKGEubGVuZ3RoID09PSAwKVxuICAgICAgICByZXR1cm4gYi5sZW5ndGg7XG4gICAgaWYgKGIubGVuZ3RoID09PSAwKVxuICAgICAgICByZXR1cm4gYS5sZW5ndGg7XG4gICAgcmV0dXJuIE1hdGgubWluKERpc3RhbmNlcy5MRVZFTlNIVEVJTihhLnN1YnN0cigxKSwgYikgKyAxLCBEaXN0YW5jZXMuTEVWRU5TSFRFSU4oYi5zdWJzdHIoMSksIGEpICsgMSwgRGlzdGFuY2VzLkxFVkVOU0hURUlOKGEuc3Vic3RyKDEpLCBiLnN1YnN0cigxKSkgKyAoYVswXSAhPT0gYlswXSA/IDEgOiAwKSk7XG59O1xuZXhwb3J0cy5EaXN0YW5jZXMgPSBEaXN0YW5jZXM7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL3NyYy9tYXRoL2Rpc3RhbmNlcy50c1xuLy8gbW9kdWxlIGlkID0gMTBcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Iiwic291cmNlUm9vdCI6IiJ9");

/***/ }),
/* 11 */
/* unknown exports provided */
/* all exports used */
/*!***************************!*\
  !*** ./src/math/maths.ts ***!
  \***************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar __1 = __webpack_require__(/*! .. */ 0);\nvar Maths;\n(function (Maths) {\n    function randomInt(min, max) {\n        return Math.floor(Math.random() * (max + 1 - min) + min);\n    }\n    Maths.randomInt = randomInt;\n    function random(min, max) {\n        return Math.random() * (max - min) + min;\n    }\n    Maths.random = random;\n    function argmax(args) {\n        var record = {};\n        args.forEach(function (a) { return record[a] = record[a] + 1 || 1; });\n        var max = record[args[0]];\n        var arg = args[0];\n        for (var _i = 0, args_1 = args; _i < args_1.length; _i++) {\n            var key = args_1[_i];\n            if (record[key] > max) {\n                max = record[key];\n                arg = key;\n            }\n        }\n        return arg;\n    }\n    Maths.argmax = argmax;\n    function randomBool() {\n        return Math.random() > 0.5 ? true : false;\n    }\n    Maths.randomBool = randomBool;\n    function round(value, decimals) {\n        if (decimals === void 0) { decimals = 1; }\n        var f = Math.pow(10, decimals);\n        return Math.round(value * f) / f;\n    }\n    Maths.round = round;\n    function sum(c) {\n        var M = c instanceof __1.Matrix ? c.getColumnAsRowVector(0).getArray()[0] : c;\n        return M.reduce(function (s, x) { return s + x; }, 0);\n    }\n    Maths.sum = sum;\n    var Tensor2D;\n    (function (Tensor2D) {\n        var NOT_VALID = new Error('The tensor is not valid.');\n        var SIZE_NOT_MATCHING = new Error('Tensors do not have matching sizes.');\n        function getAsString(t, markup, joinChar, lineSpaceChar, end, fixed) {\n            if (markup === void 0) { markup = true; }\n            if (joinChar === void 0) { joinChar = '\\t'; }\n            if (lineSpaceChar === void 0) { lineSpaceChar = ' '; }\n            if (end === void 0) { end = '\\n'; }\n            if (fixed === void 0) { fixed = 3; }\n            if (!markup) {\n                return t.map(function (r) { return r.map(function (n) { return n.toFixed(fixed); }).join('\\t'); }).join('\\n') + end;\n            }\n            else {\n                return t.map(function (r, i) {\n                    var middlePart = r.map(function (n) { return n.toFixed(fixed); }).join(joinChar);\n                    if (i == 0 && t.length == 1) {\n                        return \"[\" + lineSpaceChar + middlePart + lineSpaceChar + \"]\";\n                    }\n                    else if (i == 0) {\n                        return \"\\u23A1\" + lineSpaceChar + middlePart + lineSpaceChar + \"\\u23A4\";\n                    }\n                    else if (i == t.length - 1) {\n                        return \"\\u23A3\" + lineSpaceChar + middlePart + lineSpaceChar + \"\\u23A6\";\n                    }\n                    else {\n                        return \"\\u239C\" + lineSpaceChar + middlePart + lineSpaceChar + \"\\u239F\";\n                    }\n                }).join('\\n') + end;\n            }\n        }\n        Tensor2D.getAsString = getAsString;\n        var ElementWise;\n        (function (ElementWise) {\n            function add() {\n                var tensors = [];\n                for (var _i = 0; _i < arguments.length; _i++) {\n                    tensors[_i] = arguments[_i];\n                }\n                if (!sameSize.apply(void 0, tensors))\n                    throw SIZE_NOT_MATCHING;\n                var result = tensors[0].slice();\n                var _loop_1 = function (i) {\n                    var tensor = tensors[i];\n                    result = result.map(function (r, i) { return r.map(function (c, j) { return c + tensor[i][j]; }); });\n                };\n                for (var i = 1; i < tensors.length; i++) {\n                    _loop_1(i);\n                }\n                return result;\n            }\n            ElementWise.add = add;\n            function subtract() {\n                var tensors = [];\n                for (var _i = 0; _i < arguments.length; _i++) {\n                    tensors[_i] = arguments[_i];\n                }\n                if (!sameSize.apply(void 0, tensors))\n                    throw SIZE_NOT_MATCHING;\n                var result = tensors[0].slice();\n                var _loop_2 = function (i) {\n                    var tensor = tensors[i];\n                    result = result.map(function (r, i) { return r.map(function (c, j) { return c - tensor[i][j]; }); });\n                };\n                for (var i = 1; i < tensors.length; i++) {\n                    _loop_2(i);\n                }\n                return result;\n            }\n            ElementWise.subtract = subtract;\n            function multiply() {\n                var tensors = [];\n                for (var _i = 0; _i < arguments.length; _i++) {\n                    tensors[_i] = arguments[_i];\n                }\n                if (!sameSize.apply(void 0, tensors))\n                    throw SIZE_NOT_MATCHING;\n                var result = tensors[0].slice();\n                var _loop_3 = function (i) {\n                    var tensor = tensors[i];\n                    result = result.map(function (r, i) { return r.map(function (c, j) { return c * tensor[i][j]; }); });\n                };\n                for (var i = 1; i < tensors.length; i++) {\n                    _loop_3(i);\n                }\n                return result;\n            }\n            ElementWise.multiply = multiply;\n            function divide() {\n                var tensors = [];\n                for (var _i = 0; _i < arguments.length; _i++) {\n                    tensors[_i] = arguments[_i];\n                }\n                if (!sameSize.apply(void 0, tensors))\n                    throw SIZE_NOT_MATCHING;\n                var result = tensors[0].slice();\n                var _loop_4 = function (i) {\n                    var tensor = tensors[i];\n                    result = result.map(function (r, i) { return r.map(function (c, j) { return c / tensor[i][j]; }); });\n                };\n                for (var i = 1; i < tensors.length; i++) {\n                    _loop_4(i);\n                }\n                return result;\n            }\n            ElementWise.divide = divide;\n            function scale(t, scl) {\n                return t.map(function (row, r) { return row.map(function (col, c) { return col * scl; }); });\n            }\n            ElementWise.scale = scale;\n        })(ElementWise = Tensor2D.ElementWise || (Tensor2D.ElementWise = {}));\n        function dot(t1, t2) {\n            var _a = getSize(t1), ROWS_T1 = _a[0], COLS_T1 = _a[1];\n            var _b = getSize(t2), ROWS_T2 = _b[0], COLS_T2 = _b[1];\n            if (COLS_T1 != ROWS_T2)\n                throw SIZE_NOT_MATCHING;\n            var resultTensor = new Array(COLS_T2).fill(new Array());\n            //generate([ROWS_T1, COLS_T2])\n            for (var colOfT2 = 0; colOfT2 < COLS_T2; colOfT2++) {\n                for (var rowOfT1 = 0; rowOfT1 < ROWS_T1; rowOfT1++) {\n                    var sum_1 = 0;\n                    for (var numberAt_T1_Or_T2 = 0; numberAt_T1_Or_T2 < COLS_T1; numberAt_T1_Or_T2++) {\n                        sum_1 += t1[rowOfT1][numberAt_T1_Or_T2] * t2[numberAt_T1_Or_T2][colOfT2];\n                    }\n                    resultTensor[rowOfT1][colOfT2] = sum_1;\n                }\n            }\n            return resultTensor;\n        }\n        Tensor2D.dot = dot;\n        function transpose(t) {\n            var _a = getSize(t), ROWS = _a[0], COLS = _a[1];\n            var newSize = getSize(t).reverse();\n            var resultTensor = generate(newSize);\n            for (var row = 0; row < ROWS; row++) {\n                for (var col = 0; col < COLS; col++) {\n                    resultTensor[col][row] = t[row][col];\n                }\n            }\n            return resultTensor;\n        }\n        Tensor2D.transpose = transpose;\n        function sameSize() {\n            var tensors = [];\n            for (var _i = 0; _i < arguments.length; _i++) {\n                tensors[_i] = arguments[_i];\n            }\n            var firstTensorSize = getSize(tensors[0]);\n            return tensors.every(function (t) {\n                var size = getSize(t);\n                return isValid(t) && firstTensorSize[0] == size[0] && firstTensorSize[1] == size[1];\n            });\n        }\n        Tensor2D.sameSize = sameSize;\n        /**\n         *\n         * @param size - Size of the 2D Tensor as an array with [#rows, #columns]\n         * @param fill\n         */\n        function generate(size, fillValue) {\n            if (fillValue === void 0) { fillValue = 0; }\n            var tensor = new Array(size[0]).fill(0).map(function (r) { return new Array(size[1]).fill(0); });\n            return fillValue === 0 ? tensor : fill(tensor, fillValue);\n        }\n        Tensor2D.generate = generate;\n        function fill(tensor, fillValue) {\n            throwIfNotValid(tensor);\n            if (typeof fillValue == 'number') {\n                return tensor.map(function (r) { return r.map(function (v) { return v = fillValue; }); });\n            }\n            else {\n                return tensor.map(function (r, row) { return r.map(function (v, col) { return v = fillValue(row, col); }); });\n            }\n        }\n        Tensor2D.fill = fill;\n        function getSize(t) {\n            return isValid(t) ? [t.length, t[0].length] : null;\n        }\n        Tensor2D.getSize = getSize;\n        function throwIfNotValid(t) {\n            if (!isValid(t))\n                throw NOT_VALID;\n        }\n        function isValid(t) {\n            return t.every(function (r) { return r.length == t[0].length && r.every(function (n) { return typeof n == 'number'; }); });\n        }\n        Tensor2D.isValid = isValid;\n        function apply(t, func) {\n            var copy = t.slice();\n            return copy.map(function (r, i) { return r.map(function (c, j) { return func(c, i, j); }); });\n        }\n        Tensor2D.apply = apply;\n    })(Tensor2D = Maths.Tensor2D || (Maths.Tensor2D = {}));\n})(Maths = exports.Maths || (exports.Maths = {}));\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTEuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvbWF0aC9tYXRocy50cz9hMzcwIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIF9fMSA9IHJlcXVpcmUoXCIuLlwiKTtcbnZhciBNYXRocztcbihmdW5jdGlvbiAoTWF0aHMpIHtcbiAgICBmdW5jdGlvbiByYW5kb21JbnQobWluLCBtYXgpIHtcbiAgICAgICAgcmV0dXJuIE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIChtYXggKyAxIC0gbWluKSArIG1pbik7XG4gICAgfVxuICAgIE1hdGhzLnJhbmRvbUludCA9IHJhbmRvbUludDtcbiAgICBmdW5jdGlvbiByYW5kb20obWluLCBtYXgpIHtcbiAgICAgICAgcmV0dXJuIE1hdGgucmFuZG9tKCkgKiAobWF4IC0gbWluKSArIG1pbjtcbiAgICB9XG4gICAgTWF0aHMucmFuZG9tID0gcmFuZG9tO1xuICAgIGZ1bmN0aW9uIGFyZ21heChhcmdzKSB7XG4gICAgICAgIHZhciByZWNvcmQgPSB7fTtcbiAgICAgICAgYXJncy5mb3JFYWNoKGZ1bmN0aW9uIChhKSB7IHJldHVybiByZWNvcmRbYV0gPSByZWNvcmRbYV0gKyAxIHx8IDE7IH0pO1xuICAgICAgICB2YXIgbWF4ID0gcmVjb3JkW2FyZ3NbMF1dO1xuICAgICAgICB2YXIgYXJnID0gYXJnc1swXTtcbiAgICAgICAgZm9yICh2YXIgX2kgPSAwLCBhcmdzXzEgPSBhcmdzOyBfaSA8IGFyZ3NfMS5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICAgIHZhciBrZXkgPSBhcmdzXzFbX2ldO1xuICAgICAgICAgICAgaWYgKHJlY29yZFtrZXldID4gbWF4KSB7XG4gICAgICAgICAgICAgICAgbWF4ID0gcmVjb3JkW2tleV07XG4gICAgICAgICAgICAgICAgYXJnID0ga2V5O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBhcmc7XG4gICAgfVxuICAgIE1hdGhzLmFyZ21heCA9IGFyZ21heDtcbiAgICBmdW5jdGlvbiByYW5kb21Cb29sKCkge1xuICAgICAgICByZXR1cm4gTWF0aC5yYW5kb20oKSA+IDAuNSA/IHRydWUgOiBmYWxzZTtcbiAgICB9XG4gICAgTWF0aHMucmFuZG9tQm9vbCA9IHJhbmRvbUJvb2w7XG4gICAgZnVuY3Rpb24gcm91bmQodmFsdWUsIGRlY2ltYWxzKSB7XG4gICAgICAgIGlmIChkZWNpbWFscyA9PT0gdm9pZCAwKSB7IGRlY2ltYWxzID0gMTsgfVxuICAgICAgICB2YXIgZiA9IE1hdGgucG93KDEwLCBkZWNpbWFscyk7XG4gICAgICAgIHJldHVybiBNYXRoLnJvdW5kKHZhbHVlICogZikgLyBmO1xuICAgIH1cbiAgICBNYXRocy5yb3VuZCA9IHJvdW5kO1xuICAgIGZ1bmN0aW9uIHN1bShjKSB7XG4gICAgICAgIHZhciBNID0gYyBpbnN0YW5jZW9mIF9fMS5NYXRyaXggPyBjLmdldENvbHVtbkFzUm93VmVjdG9yKDApLmdldEFycmF5KClbMF0gOiBjO1xuICAgICAgICByZXR1cm4gTS5yZWR1Y2UoZnVuY3Rpb24gKHMsIHgpIHsgcmV0dXJuIHMgKyB4OyB9LCAwKTtcbiAgICB9XG4gICAgTWF0aHMuc3VtID0gc3VtO1xuICAgIHZhciBUZW5zb3IyRDtcbiAgICAoZnVuY3Rpb24gKFRlbnNvcjJEKSB7XG4gICAgICAgIHZhciBOT1RfVkFMSUQgPSBuZXcgRXJyb3IoJ1RoZSB0ZW5zb3IgaXMgbm90IHZhbGlkLicpO1xuICAgICAgICB2YXIgU0laRV9OT1RfTUFUQ0hJTkcgPSBuZXcgRXJyb3IoJ1RlbnNvcnMgZG8gbm90IGhhdmUgbWF0Y2hpbmcgc2l6ZXMuJyk7XG4gICAgICAgIGZ1bmN0aW9uIGdldEFzU3RyaW5nKHQsIG1hcmt1cCwgam9pbkNoYXIsIGxpbmVTcGFjZUNoYXIsIGVuZCwgZml4ZWQpIHtcbiAgICAgICAgICAgIGlmIChtYXJrdXAgPT09IHZvaWQgMCkgeyBtYXJrdXAgPSB0cnVlOyB9XG4gICAgICAgICAgICBpZiAoam9pbkNoYXIgPT09IHZvaWQgMCkgeyBqb2luQ2hhciA9ICdcXHQnOyB9XG4gICAgICAgICAgICBpZiAobGluZVNwYWNlQ2hhciA9PT0gdm9pZCAwKSB7IGxpbmVTcGFjZUNoYXIgPSAnICc7IH1cbiAgICAgICAgICAgIGlmIChlbmQgPT09IHZvaWQgMCkgeyBlbmQgPSAnXFxuJzsgfVxuICAgICAgICAgICAgaWYgKGZpeGVkID09PSB2b2lkIDApIHsgZml4ZWQgPSAzOyB9XG4gICAgICAgICAgICBpZiAoIW1hcmt1cCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0Lm1hcChmdW5jdGlvbiAocikgeyByZXR1cm4gci5tYXAoZnVuY3Rpb24gKG4pIHsgcmV0dXJuIG4udG9GaXhlZChmaXhlZCk7IH0pLmpvaW4oJ1xcdCcpOyB9KS5qb2luKCdcXG4nKSArIGVuZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiB0Lm1hcChmdW5jdGlvbiAociwgaSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgbWlkZGxlUGFydCA9IHIubWFwKGZ1bmN0aW9uIChuKSB7IHJldHVybiBuLnRvRml4ZWQoZml4ZWQpOyB9KS5qb2luKGpvaW5DaGFyKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGkgPT0gMCAmJiB0Lmxlbmd0aCA9PSAxKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gXCJbXCIgKyBsaW5lU3BhY2VDaGFyICsgbWlkZGxlUGFydCArIGxpbmVTcGFjZUNoYXIgKyBcIl1cIjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChpID09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBcIlxcdTIzQTFcIiArIGxpbmVTcGFjZUNoYXIgKyBtaWRkbGVQYXJ0ICsgbGluZVNwYWNlQ2hhciArIFwiXFx1MjNBNFwiO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKGkgPT0gdC5sZW5ndGggLSAxKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gXCJcXHUyM0EzXCIgKyBsaW5lU3BhY2VDaGFyICsgbWlkZGxlUGFydCArIGxpbmVTcGFjZUNoYXIgKyBcIlxcdTIzQTZcIjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBcIlxcdTIzOUNcIiArIGxpbmVTcGFjZUNoYXIgKyBtaWRkbGVQYXJ0ICsgbGluZVNwYWNlQ2hhciArIFwiXFx1MjM5RlwiO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSkuam9pbignXFxuJykgKyBlbmQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgVGVuc29yMkQuZ2V0QXNTdHJpbmcgPSBnZXRBc1N0cmluZztcbiAgICAgICAgdmFyIEVsZW1lbnRXaXNlO1xuICAgICAgICAoZnVuY3Rpb24gKEVsZW1lbnRXaXNlKSB7XG4gICAgICAgICAgICBmdW5jdGlvbiBhZGQoKSB7XG4gICAgICAgICAgICAgICAgdmFyIHRlbnNvcnMgPSBbXTtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgYXJndW1lbnRzLmxlbmd0aDsgX2krKykge1xuICAgICAgICAgICAgICAgICAgICB0ZW5zb3JzW19pXSA9IGFyZ3VtZW50c1tfaV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICghc2FtZVNpemUuYXBwbHkodm9pZCAwLCB0ZW5zb3JzKSlcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgU0laRV9OT1RfTUFUQ0hJTkc7XG4gICAgICAgICAgICAgICAgdmFyIHJlc3VsdCA9IHRlbnNvcnNbMF0uc2xpY2UoKTtcbiAgICAgICAgICAgICAgICB2YXIgX2xvb3BfMSA9IGZ1bmN0aW9uIChpKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciB0ZW5zb3IgPSB0ZW5zb3JzW2ldO1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSByZXN1bHQubWFwKGZ1bmN0aW9uIChyLCBpKSB7IHJldHVybiByLm1hcChmdW5jdGlvbiAoYywgaikgeyByZXR1cm4gYyArIHRlbnNvcltpXVtqXTsgfSk7IH0pO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDE7IGkgPCB0ZW5zb3JzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIF9sb29wXzEoaSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBFbGVtZW50V2lzZS5hZGQgPSBhZGQ7XG4gICAgICAgICAgICBmdW5jdGlvbiBzdWJ0cmFjdCgpIHtcbiAgICAgICAgICAgICAgICB2YXIgdGVuc29ycyA9IFtdO1xuICAgICAgICAgICAgICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBhcmd1bWVudHMubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIHRlbnNvcnNbX2ldID0gYXJndW1lbnRzW19pXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKCFzYW1lU2l6ZS5hcHBseSh2b2lkIDAsIHRlbnNvcnMpKVxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBTSVpFX05PVF9NQVRDSElORztcbiAgICAgICAgICAgICAgICB2YXIgcmVzdWx0ID0gdGVuc29yc1swXS5zbGljZSgpO1xuICAgICAgICAgICAgICAgIHZhciBfbG9vcF8yID0gZnVuY3Rpb24gKGkpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHRlbnNvciA9IHRlbnNvcnNbaV07XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IHJlc3VsdC5tYXAoZnVuY3Rpb24gKHIsIGkpIHsgcmV0dXJuIHIubWFwKGZ1bmN0aW9uIChjLCBqKSB7IHJldHVybiBjIC0gdGVuc29yW2ldW2pdOyB9KTsgfSk7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMTsgaSA8IHRlbnNvcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgX2xvb3BfMihpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIEVsZW1lbnRXaXNlLnN1YnRyYWN0ID0gc3VidHJhY3Q7XG4gICAgICAgICAgICBmdW5jdGlvbiBtdWx0aXBseSgpIHtcbiAgICAgICAgICAgICAgICB2YXIgdGVuc29ycyA9IFtdO1xuICAgICAgICAgICAgICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBhcmd1bWVudHMubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIHRlbnNvcnNbX2ldID0gYXJndW1lbnRzW19pXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKCFzYW1lU2l6ZS5hcHBseSh2b2lkIDAsIHRlbnNvcnMpKVxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBTSVpFX05PVF9NQVRDSElORztcbiAgICAgICAgICAgICAgICB2YXIgcmVzdWx0ID0gdGVuc29yc1swXS5zbGljZSgpO1xuICAgICAgICAgICAgICAgIHZhciBfbG9vcF8zID0gZnVuY3Rpb24gKGkpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHRlbnNvciA9IHRlbnNvcnNbaV07XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IHJlc3VsdC5tYXAoZnVuY3Rpb24gKHIsIGkpIHsgcmV0dXJuIHIubWFwKGZ1bmN0aW9uIChjLCBqKSB7IHJldHVybiBjICogdGVuc29yW2ldW2pdOyB9KTsgfSk7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMTsgaSA8IHRlbnNvcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgX2xvb3BfMyhpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIEVsZW1lbnRXaXNlLm11bHRpcGx5ID0gbXVsdGlwbHk7XG4gICAgICAgICAgICBmdW5jdGlvbiBkaXZpZGUoKSB7XG4gICAgICAgICAgICAgICAgdmFyIHRlbnNvcnMgPSBbXTtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgYXJndW1lbnRzLmxlbmd0aDsgX2krKykge1xuICAgICAgICAgICAgICAgICAgICB0ZW5zb3JzW19pXSA9IGFyZ3VtZW50c1tfaV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICghc2FtZVNpemUuYXBwbHkodm9pZCAwLCB0ZW5zb3JzKSlcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgU0laRV9OT1RfTUFUQ0hJTkc7XG4gICAgICAgICAgICAgICAgdmFyIHJlc3VsdCA9IHRlbnNvcnNbMF0uc2xpY2UoKTtcbiAgICAgICAgICAgICAgICB2YXIgX2xvb3BfNCA9IGZ1bmN0aW9uIChpKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciB0ZW5zb3IgPSB0ZW5zb3JzW2ldO1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSByZXN1bHQubWFwKGZ1bmN0aW9uIChyLCBpKSB7IHJldHVybiByLm1hcChmdW5jdGlvbiAoYywgaikgeyByZXR1cm4gYyAvIHRlbnNvcltpXVtqXTsgfSk7IH0pO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDE7IGkgPCB0ZW5zb3JzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIF9sb29wXzQoaSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBFbGVtZW50V2lzZS5kaXZpZGUgPSBkaXZpZGU7XG4gICAgICAgICAgICBmdW5jdGlvbiBzY2FsZSh0LCBzY2wpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdC5tYXAoZnVuY3Rpb24gKHJvdywgcikgeyByZXR1cm4gcm93Lm1hcChmdW5jdGlvbiAoY29sLCBjKSB7IHJldHVybiBjb2wgKiBzY2w7IH0pOyB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIEVsZW1lbnRXaXNlLnNjYWxlID0gc2NhbGU7XG4gICAgICAgIH0pKEVsZW1lbnRXaXNlID0gVGVuc29yMkQuRWxlbWVudFdpc2UgfHwgKFRlbnNvcjJELkVsZW1lbnRXaXNlID0ge30pKTtcbiAgICAgICAgZnVuY3Rpb24gZG90KHQxLCB0Mikge1xuICAgICAgICAgICAgdmFyIF9hID0gZ2V0U2l6ZSh0MSksIFJPV1NfVDEgPSBfYVswXSwgQ09MU19UMSA9IF9hWzFdO1xuICAgICAgICAgICAgdmFyIF9iID0gZ2V0U2l6ZSh0MiksIFJPV1NfVDIgPSBfYlswXSwgQ09MU19UMiA9IF9iWzFdO1xuICAgICAgICAgICAgaWYgKENPTFNfVDEgIT0gUk9XU19UMilcbiAgICAgICAgICAgICAgICB0aHJvdyBTSVpFX05PVF9NQVRDSElORztcbiAgICAgICAgICAgIHZhciByZXN1bHRUZW5zb3IgPSBuZXcgQXJyYXkoQ09MU19UMikuZmlsbChuZXcgQXJyYXkoKSk7XG4gICAgICAgICAgICAvL2dlbmVyYXRlKFtST1dTX1QxLCBDT0xTX1QyXSlcbiAgICAgICAgICAgIGZvciAodmFyIGNvbE9mVDIgPSAwOyBjb2xPZlQyIDwgQ09MU19UMjsgY29sT2ZUMisrKSB7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgcm93T2ZUMSA9IDA7IHJvd09mVDEgPCBST1dTX1QxOyByb3dPZlQxKyspIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHN1bV8xID0gMDtcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgbnVtYmVyQXRfVDFfT3JfVDIgPSAwOyBudW1iZXJBdF9UMV9Pcl9UMiA8IENPTFNfVDE7IG51bWJlckF0X1QxX09yX1QyKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN1bV8xICs9IHQxW3Jvd09mVDFdW251bWJlckF0X1QxX09yX1QyXSAqIHQyW251bWJlckF0X1QxX09yX1QyXVtjb2xPZlQyXTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXN1bHRUZW5zb3Jbcm93T2ZUMV1bY29sT2ZUMl0gPSBzdW1fMTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0VGVuc29yO1xuICAgICAgICB9XG4gICAgICAgIFRlbnNvcjJELmRvdCA9IGRvdDtcbiAgICAgICAgZnVuY3Rpb24gdHJhbnNwb3NlKHQpIHtcbiAgICAgICAgICAgIHZhciBfYSA9IGdldFNpemUodCksIFJPV1MgPSBfYVswXSwgQ09MUyA9IF9hWzFdO1xuICAgICAgICAgICAgdmFyIG5ld1NpemUgPSBnZXRTaXplKHQpLnJldmVyc2UoKTtcbiAgICAgICAgICAgIHZhciByZXN1bHRUZW5zb3IgPSBnZW5lcmF0ZShuZXdTaXplKTtcbiAgICAgICAgICAgIGZvciAodmFyIHJvdyA9IDA7IHJvdyA8IFJPV1M7IHJvdysrKSB7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgY29sID0gMDsgY29sIDwgQ09MUzsgY29sKyspIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0VGVuc29yW2NvbF1bcm93XSA9IHRbcm93XVtjb2xdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiByZXN1bHRUZW5zb3I7XG4gICAgICAgIH1cbiAgICAgICAgVGVuc29yMkQudHJhbnNwb3NlID0gdHJhbnNwb3NlO1xuICAgICAgICBmdW5jdGlvbiBzYW1lU2l6ZSgpIHtcbiAgICAgICAgICAgIHZhciB0ZW5zb3JzID0gW107XG4gICAgICAgICAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgYXJndW1lbnRzLmxlbmd0aDsgX2krKykge1xuICAgICAgICAgICAgICAgIHRlbnNvcnNbX2ldID0gYXJndW1lbnRzW19pXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBmaXJzdFRlbnNvclNpemUgPSBnZXRTaXplKHRlbnNvcnNbMF0pO1xuICAgICAgICAgICAgcmV0dXJuIHRlbnNvcnMuZXZlcnkoZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgICAgICAgICB2YXIgc2l6ZSA9IGdldFNpemUodCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGlzVmFsaWQodCkgJiYgZmlyc3RUZW5zb3JTaXplWzBdID09IHNpemVbMF0gJiYgZmlyc3RUZW5zb3JTaXplWzFdID09IHNpemVbMV07XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBUZW5zb3IyRC5zYW1lU2l6ZSA9IHNhbWVTaXplO1xuICAgICAgICAvKipcbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIHNpemUgLSBTaXplIG9mIHRoZSAyRCBUZW5zb3IgYXMgYW4gYXJyYXkgd2l0aCBbI3Jvd3MsICNjb2x1bW5zXVxuICAgICAgICAgKiBAcGFyYW0gZmlsbFxuICAgICAgICAgKi9cbiAgICAgICAgZnVuY3Rpb24gZ2VuZXJhdGUoc2l6ZSwgZmlsbFZhbHVlKSB7XG4gICAgICAgICAgICBpZiAoZmlsbFZhbHVlID09PSB2b2lkIDApIHsgZmlsbFZhbHVlID0gMDsgfVxuICAgICAgICAgICAgdmFyIHRlbnNvciA9IG5ldyBBcnJheShzaXplWzBdKS5maWxsKDApLm1hcChmdW5jdGlvbiAocikgeyByZXR1cm4gbmV3IEFycmF5KHNpemVbMV0pLmZpbGwoMCk7IH0pO1xuICAgICAgICAgICAgcmV0dXJuIGZpbGxWYWx1ZSA9PT0gMCA/IHRlbnNvciA6IGZpbGwodGVuc29yLCBmaWxsVmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIFRlbnNvcjJELmdlbmVyYXRlID0gZ2VuZXJhdGU7XG4gICAgICAgIGZ1bmN0aW9uIGZpbGwodGVuc29yLCBmaWxsVmFsdWUpIHtcbiAgICAgICAgICAgIHRocm93SWZOb3RWYWxpZCh0ZW5zb3IpO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBmaWxsVmFsdWUgPT0gJ251bWJlcicpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGVuc29yLm1hcChmdW5jdGlvbiAocikgeyByZXR1cm4gci5tYXAoZnVuY3Rpb24gKHYpIHsgcmV0dXJuIHYgPSBmaWxsVmFsdWU7IH0pOyB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiB0ZW5zb3IubWFwKGZ1bmN0aW9uIChyLCByb3cpIHsgcmV0dXJuIHIubWFwKGZ1bmN0aW9uICh2LCBjb2wpIHsgcmV0dXJuIHYgPSBmaWxsVmFsdWUocm93LCBjb2wpOyB9KTsgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgVGVuc29yMkQuZmlsbCA9IGZpbGw7XG4gICAgICAgIGZ1bmN0aW9uIGdldFNpemUodCkge1xuICAgICAgICAgICAgcmV0dXJuIGlzVmFsaWQodCkgPyBbdC5sZW5ndGgsIHRbMF0ubGVuZ3RoXSA6IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgVGVuc29yMkQuZ2V0U2l6ZSA9IGdldFNpemU7XG4gICAgICAgIGZ1bmN0aW9uIHRocm93SWZOb3RWYWxpZCh0KSB7XG4gICAgICAgICAgICBpZiAoIWlzVmFsaWQodCkpXG4gICAgICAgICAgICAgICAgdGhyb3cgTk9UX1ZBTElEO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIGlzVmFsaWQodCkge1xuICAgICAgICAgICAgcmV0dXJuIHQuZXZlcnkoZnVuY3Rpb24gKHIpIHsgcmV0dXJuIHIubGVuZ3RoID09IHRbMF0ubGVuZ3RoICYmIHIuZXZlcnkoZnVuY3Rpb24gKG4pIHsgcmV0dXJuIHR5cGVvZiBuID09ICdudW1iZXInOyB9KTsgfSk7XG4gICAgICAgIH1cbiAgICAgICAgVGVuc29yMkQuaXNWYWxpZCA9IGlzVmFsaWQ7XG4gICAgICAgIGZ1bmN0aW9uIGFwcGx5KHQsIGZ1bmMpIHtcbiAgICAgICAgICAgIHZhciBjb3B5ID0gdC5zbGljZSgpO1xuICAgICAgICAgICAgcmV0dXJuIGNvcHkubWFwKGZ1bmN0aW9uIChyLCBpKSB7IHJldHVybiByLm1hcChmdW5jdGlvbiAoYywgaikgeyByZXR1cm4gZnVuYyhjLCBpLCBqKTsgfSk7IH0pO1xuICAgICAgICB9XG4gICAgICAgIFRlbnNvcjJELmFwcGx5ID0gYXBwbHk7XG4gICAgfSkoVGVuc29yMkQgPSBNYXRocy5UZW5zb3IyRCB8fCAoTWF0aHMuVGVuc29yMkQgPSB7fSkpO1xufSkoTWF0aHMgPSBleHBvcnRzLk1hdGhzIHx8IChleHBvcnRzLk1hdGhzID0ge30pKTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vc3JjL21hdGgvbWF0aHMudHNcbi8vIG1vZHVsZSBpZCA9IDExXG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOyIsInNvdXJjZVJvb3QiOiIifQ==");

/***/ }),
/* 12 */
/* unknown exports provided */
/* all exports used */
/*!****************************!*\
  !*** ./src/math/matrix.ts ***!
  \****************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar Matrix = (function () {\n    function Matrix(p1, p2) {\n        if (typeof p1 == 'object') {\n            this.data = p1;\n        }\n        else {\n            this.data = Matrix.get2DArray(p1, p2);\n        }\n    }\n    Matrix.get2DArray = function (m, n, fill) {\n        if (fill === void 0) { fill = 0; }\n        return new Array(m).fill(0).map(function (r) { return new Array(n).fill(fill); });\n    };\n    Matrix.rowVector = function () {\n        var components = [];\n        for (var _i = 0; _i < arguments.length; _i++) {\n            components[_i] = arguments[_i];\n        }\n        return new Matrix([components]);\n    };\n    Matrix.columnVector = function () {\n        var components = [];\n        for (var _i = 0; _i < arguments.length; _i++) {\n            components[_i] = arguments[_i];\n        }\n        var v = components.map(function (c) { return [c]; });\n        return new Matrix(v);\n    };\n    Matrix.rand = function (rows, columns) {\n        var m = new Matrix(rows, columns);\n        m.map(function (v) { return Math.random(); });\n        return m;\n    };\n    Matrix.ones = function (rows, columns) {\n        var m = new Matrix(rows, columns);\n        m.fill(1);\n        return m;\n    };\n    Matrix.eye = function (size) {\n        var m = new Matrix(size, size);\n        for (var i = 0; i < size; i++)\n            m.set(i, i, 1);\n        return m;\n    };\n    Matrix.prototype.apply = function (func) {\n        this.map(function (v) { return func(v); });\n    };\n    Matrix.join = function (m1, m2, pos) {\n        if (pos === void 0) { pos = 'bottom'; }\n        var newData;\n        switch (pos) {\n            case 'top':\n                newData = m2.data.concat(m1.data);\n                break;\n            case 'bottom':\n                newData = m1.data.concat(m2.data);\n                break;\n            case 'left':\n                newData = m1.data.map(function (r, i) { return m2.data[i].concat(r); });\n                break;\n            case 'right':\n                newData = m1.data.map(function (r, i) { return r.concat(m2.data[i]); });\n                break;\n            default:\n                break;\n        }\n        return new Matrix(newData);\n    };\n    Matrix.prototype.size = function () {\n        return [this.getNumberOfRows(), this.getNumberOfColumns()];\n    };\n    Matrix.prototype.getNumberOfRows = function () {\n        return this.data.length;\n    };\n    Matrix.prototype.getNumberOfColumns = function () {\n        return this.data[0].length;\n    };\n    Matrix.prototype.getDimensions = function () {\n        return [this.getNumberOfRows(), this.getNumberOfColumns()];\n    };\n    Matrix.prototype.set = function (row, column, val) {\n        this.data[row][column] = val;\n    };\n    Matrix.prototype.get = function (row, column) {\n        return this.data[row][column];\n    };\n    Matrix.prototype.getRowAsRowVector = function (row) {\n        // Copy without reference\n        var v = new Matrix([this.data[row].slice()]);\n        return v;\n    };\n    Matrix.prototype.getColumnAsRowVector = function (column) {\n        // Copy without reference\n        var v = [];\n        for (var _i = 0, _a = this.data; _i < _a.length; _i++) {\n            var row = _a[_i];\n            v.push(row[column]);\n        }\n        return new Matrix([v]);\n    };\n    Matrix.prototype.getAsScalar = function () {\n        if (this.getDimensions().every(function (d) { return d == 1; })) {\n            return this.get(0, 0);\n        }\n        else {\n            this.error('size', 'getAsFloat (matrix must be 1x1)');\n        }\n    };\n    Matrix.prototype.getArray = function () {\n        // Deep copy without reference\n        return this.data.map(function (r) { return r.slice(); });\n    };\n    Matrix.prototype.copy = function () {\n        return new Matrix(this.getArray());\n    };\n    // endRow and endColumn exclusive if positive\n    // startRow and startColumn exclusive if negative\n    Matrix.prototype.slice = function (startRow, endRow, startColumn, endColumn) {\n        //Handle negatives\n        if (endRow < 0) {\n            endRow = this.getNumberOfRows() + (endRow + 1);\n        }\n        if (startRow < 0) {\n            startRow = this.getNumberOfRows() + (startRow + 1);\n        }\n        if (endColumn < 0) {\n            endColumn = this.getNumberOfColumns() + (endColumn + 1);\n        }\n        if (startColumn < 0) {\n            startColumn = this.getNumberOfColumns() + (startColumn + 1);\n        }\n        var res = new Matrix(endRow - startRow, endColumn - startColumn);\n        for (var row = startRow; row < endRow; row++) {\n            for (var column = startColumn; column < endColumn; column++) {\n                res.set(row - startRow, column - startColumn, this.get(row, column));\n            }\n        }\n        return res;\n    };\n    Matrix.prototype.map = function (func) {\n        for (var i = 0; i < this.getNumberOfRows(); i++) {\n            for (var j = 0; j < this.getNumberOfColumns(); j++) {\n                this.data[i][j] = func(this.data[i][j], i, j);\n            }\n        }\n        return this;\n    };\n    Matrix.prototype.forEach = function (func) {\n        for (var i = 0; i < this.getNumberOfRows(); i++) {\n            for (var j = 0; j < this.getNumberOfColumns(); j++) {\n                func(this.data[i][j], i, j);\n            }\n        }\n        return this;\n    };\n    Matrix.prototype.fill = function (newVal) {\n        return this.map(function (v) { return newVal; });\n    };\n    Matrix.prototype.scale = function (scl) {\n        return this.map(function (v) { return v * scl; });\n    };\n    Matrix.prototype.add = function (tensor) {\n        var m = this.transformVectorToMatrix(tensor);\n        if (!this.hasSameDimensions(m))\n            this.error('size', 'addition');\n        return this.map(function (v, row, col) { return v + m.get(row, col); });\n    };\n    Matrix.prototype.subtract = function (tensor) {\n        var m = this.transformVectorToMatrix(tensor);\n        if (!this.hasSameDimensions(m))\n            this.error('size', 'subtraction');\n        return this.map(function (v, row, col) { return v - m.get(row, col); });\n    };\n    Matrix.prototype.multiply = function (tensor) {\n        var m = this.transformVectorToMatrix(tensor);\n        if (!this.hasSameDimensions(m))\n            this.error('size', 'multiplication');\n        return this.map(function (v, row, col) { return v * m.get(row, col); });\n    };\n    Matrix.prototype.divide = function (tensor) {\n        var m = this.transformVectorToMatrix(tensor);\n        if (!this.hasSameDimensions(m))\n            this.error('size', 'division');\n        return this.map(function (v, row, col) { return v / m.get(row, col); });\n    };\n    Matrix.prototype.dot = function (tensor) {\n        var m = this.transformVectorToMatrix(tensor);\n        if (!(this.getNumberOfColumns() == m.getNumberOfRows()))\n            this.error('size', 'dot product');\n        var newData = Matrix.get2DArray(this.getNumberOfRows(), m.getNumberOfColumns());\n        for (var v = 0; v < m.getNumberOfColumns(); v++) {\n            for (var r = 0; r < this.getNumberOfRows(); r++) {\n                for (var i = 0; i < m.getNumberOfRows(); i++) {\n                    newData[r][v] += m.get(i, v) * this.get(r, i);\n                }\n            }\n        }\n        this.data = newData;\n        return this;\n    };\n    Matrix.prototype.transformVectorToMatrix = function (tentativeVec) {\n        return tentativeVec instanceof Matrix ? tentativeVec : Matrix.columnVector.apply(Matrix, tentativeVec.getArray());\n    };\n    Matrix.prototype.getVector = function () {\n    };\n    Matrix.prototype.transpose = function () {\n        var newData = Matrix.get2DArray(this.getNumberOfColumns(), this.getNumberOfRows());\n        this.forEach(function (v, row, col) {\n            newData[col][row] = v;\n        });\n        this.data = newData;\n        return this;\n    };\n    Matrix.prototype.min = function () {\n        var minValues = [];\n        for (var c = 0; c < this.getNumberOfColumns(); c++) {\n            var column = this.getColumnAsRowVector(c).getArray()[0];\n            minValues.push(Math.min.apply(Math, column));\n        }\n        return Matrix.rowVector.apply(Matrix, minValues);\n    };\n    Matrix.prototype.max = function () {\n        var maxValues = [];\n        for (var c = 0; c < this.getNumberOfColumns(); c++) {\n            var column = this.getColumnAsRowVector(c).getArray()[0];\n            maxValues.push(Math.max.apply(Math, column));\n        }\n        return Matrix.rowVector.apply(Matrix, maxValues);\n    };\n    Matrix.prototype.hasSameDimensions = function (m) {\n        if (m.getNumberOfColumns() == this.getNumberOfColumns() && m.getNumberOfRows() == this.getNumberOfRows()) {\n            return true;\n        }\n        else {\n            return false;\n        }\n    };\n    Matrix.prototype.error = function (code, operation) {\n        switch (code) {\n            case 'size':\n                throw \"Matrices not not have the right sizes for operation \" + operation;\n            default:\n                throw \"Error!\";\n        }\n    };\n    Matrix.prototype.show = function () {\n        console.log(this.getAsString());\n        return this;\n    };\n    Matrix.prototype.getAsString = function (markup, joinChar, lineSpaceChar, end, fixed) {\n        var _this = this;\n        if (markup === void 0) { markup = true; }\n        if (joinChar === void 0) { joinChar = '\\t'; }\n        if (lineSpaceChar === void 0) { lineSpaceChar = ' '; }\n        if (end === void 0) { end = '\\n'; }\n        if (fixed === void 0) { fixed = 3; }\n        if (!markup) {\n            return this.data.map(function (r) { return r.map(function (n) { return n.toFixed(fixed); }).join('\\t'); }).join('\\n') + end;\n        }\n        else {\n            return this.data.map(function (r, i) {\n                var middlePart = r.map(function (n) { return n.toFixed(fixed); }).join(joinChar);\n                if (i == 0 && _this.data.length == 1) {\n                    return \"[\" + lineSpaceChar + middlePart + lineSpaceChar + \"]\";\n                }\n                else if (i == 0) {\n                    return \"\\u23A1\" + lineSpaceChar + middlePart + lineSpaceChar + \"\\u23A4\";\n                }\n                else if (i == _this.data.length - 1) {\n                    return \"\\u23A3\" + lineSpaceChar + middlePart + lineSpaceChar + \"\\u23A6\";\n                }\n                else {\n                    return \"\\u239C\" + lineSpaceChar + middlePart + lineSpaceChar + \"\\u239F\";\n                }\n            }).join('\\n') + end;\n        }\n    };\n    return Matrix;\n}());\nexports.Matrix = Matrix;\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTIuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvbWF0aC9tYXRyaXgudHM/NzQ4NSJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBNYXRyaXggPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIE1hdHJpeChwMSwgcDIpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBwMSA9PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgdGhpcy5kYXRhID0gcDE7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmRhdGEgPSBNYXRyaXguZ2V0MkRBcnJheShwMSwgcDIpO1xuICAgICAgICB9XG4gICAgfVxuICAgIE1hdHJpeC5nZXQyREFycmF5ID0gZnVuY3Rpb24gKG0sIG4sIGZpbGwpIHtcbiAgICAgICAgaWYgKGZpbGwgPT09IHZvaWQgMCkgeyBmaWxsID0gMDsgfVxuICAgICAgICByZXR1cm4gbmV3IEFycmF5KG0pLmZpbGwoMCkubWFwKGZ1bmN0aW9uIChyKSB7IHJldHVybiBuZXcgQXJyYXkobikuZmlsbChmaWxsKTsgfSk7XG4gICAgfTtcbiAgICBNYXRyaXgucm93VmVjdG9yID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgY29tcG9uZW50cyA9IFtdO1xuICAgICAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgYXJndW1lbnRzLmxlbmd0aDsgX2krKykge1xuICAgICAgICAgICAgY29tcG9uZW50c1tfaV0gPSBhcmd1bWVudHNbX2ldO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgTWF0cml4KFtjb21wb25lbnRzXSk7XG4gICAgfTtcbiAgICBNYXRyaXguY29sdW1uVmVjdG9yID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgY29tcG9uZW50cyA9IFtdO1xuICAgICAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgYXJndW1lbnRzLmxlbmd0aDsgX2krKykge1xuICAgICAgICAgICAgY29tcG9uZW50c1tfaV0gPSBhcmd1bWVudHNbX2ldO1xuICAgICAgICB9XG4gICAgICAgIHZhciB2ID0gY29tcG9uZW50cy5tYXAoZnVuY3Rpb24gKGMpIHsgcmV0dXJuIFtjXTsgfSk7XG4gICAgICAgIHJldHVybiBuZXcgTWF0cml4KHYpO1xuICAgIH07XG4gICAgTWF0cml4LnJhbmQgPSBmdW5jdGlvbiAocm93cywgY29sdW1ucykge1xuICAgICAgICB2YXIgbSA9IG5ldyBNYXRyaXgocm93cywgY29sdW1ucyk7XG4gICAgICAgIG0ubWFwKGZ1bmN0aW9uICh2KSB7IHJldHVybiBNYXRoLnJhbmRvbSgpOyB9KTtcbiAgICAgICAgcmV0dXJuIG07XG4gICAgfTtcbiAgICBNYXRyaXgub25lcyA9IGZ1bmN0aW9uIChyb3dzLCBjb2x1bW5zKSB7XG4gICAgICAgIHZhciBtID0gbmV3IE1hdHJpeChyb3dzLCBjb2x1bW5zKTtcbiAgICAgICAgbS5maWxsKDEpO1xuICAgICAgICByZXR1cm4gbTtcbiAgICB9O1xuICAgIE1hdHJpeC5leWUgPSBmdW5jdGlvbiAoc2l6ZSkge1xuICAgICAgICB2YXIgbSA9IG5ldyBNYXRyaXgoc2l6ZSwgc2l6ZSk7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc2l6ZTsgaSsrKVxuICAgICAgICAgICAgbS5zZXQoaSwgaSwgMSk7XG4gICAgICAgIHJldHVybiBtO1xuICAgIH07XG4gICAgTWF0cml4LnByb3RvdHlwZS5hcHBseSA9IGZ1bmN0aW9uIChmdW5jKSB7XG4gICAgICAgIHRoaXMubWFwKGZ1bmN0aW9uICh2KSB7IHJldHVybiBmdW5jKHYpOyB9KTtcbiAgICB9O1xuICAgIE1hdHJpeC5qb2luID0gZnVuY3Rpb24gKG0xLCBtMiwgcG9zKSB7XG4gICAgICAgIGlmIChwb3MgPT09IHZvaWQgMCkgeyBwb3MgPSAnYm90dG9tJzsgfVxuICAgICAgICB2YXIgbmV3RGF0YTtcbiAgICAgICAgc3dpdGNoIChwb3MpIHtcbiAgICAgICAgICAgIGNhc2UgJ3RvcCc6XG4gICAgICAgICAgICAgICAgbmV3RGF0YSA9IG0yLmRhdGEuY29uY2F0KG0xLmRhdGEpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnYm90dG9tJzpcbiAgICAgICAgICAgICAgICBuZXdEYXRhID0gbTEuZGF0YS5jb25jYXQobTIuZGF0YSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdsZWZ0JzpcbiAgICAgICAgICAgICAgICBuZXdEYXRhID0gbTEuZGF0YS5tYXAoZnVuY3Rpb24gKHIsIGkpIHsgcmV0dXJuIG0yLmRhdGFbaV0uY29uY2F0KHIpOyB9KTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ3JpZ2h0JzpcbiAgICAgICAgICAgICAgICBuZXdEYXRhID0gbTEuZGF0YS5tYXAoZnVuY3Rpb24gKHIsIGkpIHsgcmV0dXJuIHIuY29uY2F0KG0yLmRhdGFbaV0pOyB9KTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBNYXRyaXgobmV3RGF0YSk7XG4gICAgfTtcbiAgICBNYXRyaXgucHJvdG90eXBlLnNpemUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBbdGhpcy5nZXROdW1iZXJPZlJvd3MoKSwgdGhpcy5nZXROdW1iZXJPZkNvbHVtbnMoKV07XG4gICAgfTtcbiAgICBNYXRyaXgucHJvdG90eXBlLmdldE51bWJlck9mUm93cyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZGF0YS5sZW5ndGg7XG4gICAgfTtcbiAgICBNYXRyaXgucHJvdG90eXBlLmdldE51bWJlck9mQ29sdW1ucyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZGF0YVswXS5sZW5ndGg7XG4gICAgfTtcbiAgICBNYXRyaXgucHJvdG90eXBlLmdldERpbWVuc2lvbnMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBbdGhpcy5nZXROdW1iZXJPZlJvd3MoKSwgdGhpcy5nZXROdW1iZXJPZkNvbHVtbnMoKV07XG4gICAgfTtcbiAgICBNYXRyaXgucHJvdG90eXBlLnNldCA9IGZ1bmN0aW9uIChyb3csIGNvbHVtbiwgdmFsKSB7XG4gICAgICAgIHRoaXMuZGF0YVtyb3ddW2NvbHVtbl0gPSB2YWw7XG4gICAgfTtcbiAgICBNYXRyaXgucHJvdG90eXBlLmdldCA9IGZ1bmN0aW9uIChyb3csIGNvbHVtbikge1xuICAgICAgICByZXR1cm4gdGhpcy5kYXRhW3Jvd11bY29sdW1uXTtcbiAgICB9O1xuICAgIE1hdHJpeC5wcm90b3R5cGUuZ2V0Um93QXNSb3dWZWN0b3IgPSBmdW5jdGlvbiAocm93KSB7XG4gICAgICAgIC8vIENvcHkgd2l0aG91dCByZWZlcmVuY2VcbiAgICAgICAgdmFyIHYgPSBuZXcgTWF0cml4KFt0aGlzLmRhdGFbcm93XS5zbGljZSgpXSk7XG4gICAgICAgIHJldHVybiB2O1xuICAgIH07XG4gICAgTWF0cml4LnByb3RvdHlwZS5nZXRDb2x1bW5Bc1Jvd1ZlY3RvciA9IGZ1bmN0aW9uIChjb2x1bW4pIHtcbiAgICAgICAgLy8gQ29weSB3aXRob3V0IHJlZmVyZW5jZVxuICAgICAgICB2YXIgdiA9IFtdO1xuICAgICAgICBmb3IgKHZhciBfaSA9IDAsIF9hID0gdGhpcy5kYXRhOyBfaSA8IF9hLmxlbmd0aDsgX2krKykge1xuICAgICAgICAgICAgdmFyIHJvdyA9IF9hW19pXTtcbiAgICAgICAgICAgIHYucHVzaChyb3dbY29sdW1uXSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBNYXRyaXgoW3ZdKTtcbiAgICB9O1xuICAgIE1hdHJpeC5wcm90b3R5cGUuZ2V0QXNTY2FsYXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0aGlzLmdldERpbWVuc2lvbnMoKS5ldmVyeShmdW5jdGlvbiAoZCkgeyByZXR1cm4gZCA9PSAxOyB9KSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZ2V0KDAsIDApO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5lcnJvcignc2l6ZScsICdnZXRBc0Zsb2F0IChtYXRyaXggbXVzdCBiZSAxeDEpJyk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIE1hdHJpeC5wcm90b3R5cGUuZ2V0QXJyYXkgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIC8vIERlZXAgY29weSB3aXRob3V0IHJlZmVyZW5jZVxuICAgICAgICByZXR1cm4gdGhpcy5kYXRhLm1hcChmdW5jdGlvbiAocikgeyByZXR1cm4gci5zbGljZSgpOyB9KTtcbiAgICB9O1xuICAgIE1hdHJpeC5wcm90b3R5cGUuY29weSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBNYXRyaXgodGhpcy5nZXRBcnJheSgpKTtcbiAgICB9O1xuICAgIC8vIGVuZFJvdyBhbmQgZW5kQ29sdW1uIGV4Y2x1c2l2ZSBpZiBwb3NpdGl2ZVxuICAgIC8vIHN0YXJ0Um93IGFuZCBzdGFydENvbHVtbiBleGNsdXNpdmUgaWYgbmVnYXRpdmVcbiAgICBNYXRyaXgucHJvdG90eXBlLnNsaWNlID0gZnVuY3Rpb24gKHN0YXJ0Um93LCBlbmRSb3csIHN0YXJ0Q29sdW1uLCBlbmRDb2x1bW4pIHtcbiAgICAgICAgLy9IYW5kbGUgbmVnYXRpdmVzXG4gICAgICAgIGlmIChlbmRSb3cgPCAwKSB7XG4gICAgICAgICAgICBlbmRSb3cgPSB0aGlzLmdldE51bWJlck9mUm93cygpICsgKGVuZFJvdyArIDEpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzdGFydFJvdyA8IDApIHtcbiAgICAgICAgICAgIHN0YXJ0Um93ID0gdGhpcy5nZXROdW1iZXJPZlJvd3MoKSArIChzdGFydFJvdyArIDEpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChlbmRDb2x1bW4gPCAwKSB7XG4gICAgICAgICAgICBlbmRDb2x1bW4gPSB0aGlzLmdldE51bWJlck9mQ29sdW1ucygpICsgKGVuZENvbHVtbiArIDEpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzdGFydENvbHVtbiA8IDApIHtcbiAgICAgICAgICAgIHN0YXJ0Q29sdW1uID0gdGhpcy5nZXROdW1iZXJPZkNvbHVtbnMoKSArIChzdGFydENvbHVtbiArIDEpO1xuICAgICAgICB9XG4gICAgICAgIHZhciByZXMgPSBuZXcgTWF0cml4KGVuZFJvdyAtIHN0YXJ0Um93LCBlbmRDb2x1bW4gLSBzdGFydENvbHVtbik7XG4gICAgICAgIGZvciAodmFyIHJvdyA9IHN0YXJ0Um93OyByb3cgPCBlbmRSb3c7IHJvdysrKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBjb2x1bW4gPSBzdGFydENvbHVtbjsgY29sdW1uIDwgZW5kQ29sdW1uOyBjb2x1bW4rKykge1xuICAgICAgICAgICAgICAgIHJlcy5zZXQocm93IC0gc3RhcnRSb3csIGNvbHVtbiAtIHN0YXJ0Q29sdW1uLCB0aGlzLmdldChyb3csIGNvbHVtbikpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXM7XG4gICAgfTtcbiAgICBNYXRyaXgucHJvdG90eXBlLm1hcCA9IGZ1bmN0aW9uIChmdW5jKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5nZXROdW1iZXJPZlJvd3MoKTsgaSsrKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IHRoaXMuZ2V0TnVtYmVyT2ZDb2x1bW5zKCk7IGorKykge1xuICAgICAgICAgICAgICAgIHRoaXMuZGF0YVtpXVtqXSA9IGZ1bmModGhpcy5kYXRhW2ldW2pdLCBpLCBqKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuICAgIE1hdHJpeC5wcm90b3R5cGUuZm9yRWFjaCA9IGZ1bmN0aW9uIChmdW5jKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5nZXROdW1iZXJPZlJvd3MoKTsgaSsrKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IHRoaXMuZ2V0TnVtYmVyT2ZDb2x1bW5zKCk7IGorKykge1xuICAgICAgICAgICAgICAgIGZ1bmModGhpcy5kYXRhW2ldW2pdLCBpLCBqKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuICAgIE1hdHJpeC5wcm90b3R5cGUuZmlsbCA9IGZ1bmN0aW9uIChuZXdWYWwpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubWFwKGZ1bmN0aW9uICh2KSB7IHJldHVybiBuZXdWYWw7IH0pO1xuICAgIH07XG4gICAgTWF0cml4LnByb3RvdHlwZS5zY2FsZSA9IGZ1bmN0aW9uIChzY2wpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubWFwKGZ1bmN0aW9uICh2KSB7IHJldHVybiB2ICogc2NsOyB9KTtcbiAgICB9O1xuICAgIE1hdHJpeC5wcm90b3R5cGUuYWRkID0gZnVuY3Rpb24gKHRlbnNvcikge1xuICAgICAgICB2YXIgbSA9IHRoaXMudHJhbnNmb3JtVmVjdG9yVG9NYXRyaXgodGVuc29yKTtcbiAgICAgICAgaWYgKCF0aGlzLmhhc1NhbWVEaW1lbnNpb25zKG0pKVxuICAgICAgICAgICAgdGhpcy5lcnJvcignc2l6ZScsICdhZGRpdGlvbicpO1xuICAgICAgICByZXR1cm4gdGhpcy5tYXAoZnVuY3Rpb24gKHYsIHJvdywgY29sKSB7IHJldHVybiB2ICsgbS5nZXQocm93LCBjb2wpOyB9KTtcbiAgICB9O1xuICAgIE1hdHJpeC5wcm90b3R5cGUuc3VidHJhY3QgPSBmdW5jdGlvbiAodGVuc29yKSB7XG4gICAgICAgIHZhciBtID0gdGhpcy50cmFuc2Zvcm1WZWN0b3JUb01hdHJpeCh0ZW5zb3IpO1xuICAgICAgICBpZiAoIXRoaXMuaGFzU2FtZURpbWVuc2lvbnMobSkpXG4gICAgICAgICAgICB0aGlzLmVycm9yKCdzaXplJywgJ3N1YnRyYWN0aW9uJyk7XG4gICAgICAgIHJldHVybiB0aGlzLm1hcChmdW5jdGlvbiAodiwgcm93LCBjb2wpIHsgcmV0dXJuIHYgLSBtLmdldChyb3csIGNvbCk7IH0pO1xuICAgIH07XG4gICAgTWF0cml4LnByb3RvdHlwZS5tdWx0aXBseSA9IGZ1bmN0aW9uICh0ZW5zb3IpIHtcbiAgICAgICAgdmFyIG0gPSB0aGlzLnRyYW5zZm9ybVZlY3RvclRvTWF0cml4KHRlbnNvcik7XG4gICAgICAgIGlmICghdGhpcy5oYXNTYW1lRGltZW5zaW9ucyhtKSlcbiAgICAgICAgICAgIHRoaXMuZXJyb3IoJ3NpemUnLCAnbXVsdGlwbGljYXRpb24nKTtcbiAgICAgICAgcmV0dXJuIHRoaXMubWFwKGZ1bmN0aW9uICh2LCByb3csIGNvbCkgeyByZXR1cm4gdiAqIG0uZ2V0KHJvdywgY29sKTsgfSk7XG4gICAgfTtcbiAgICBNYXRyaXgucHJvdG90eXBlLmRpdmlkZSA9IGZ1bmN0aW9uICh0ZW5zb3IpIHtcbiAgICAgICAgdmFyIG0gPSB0aGlzLnRyYW5zZm9ybVZlY3RvclRvTWF0cml4KHRlbnNvcik7XG4gICAgICAgIGlmICghdGhpcy5oYXNTYW1lRGltZW5zaW9ucyhtKSlcbiAgICAgICAgICAgIHRoaXMuZXJyb3IoJ3NpemUnLCAnZGl2aXNpb24nKTtcbiAgICAgICAgcmV0dXJuIHRoaXMubWFwKGZ1bmN0aW9uICh2LCByb3csIGNvbCkgeyByZXR1cm4gdiAvIG0uZ2V0KHJvdywgY29sKTsgfSk7XG4gICAgfTtcbiAgICBNYXRyaXgucHJvdG90eXBlLmRvdCA9IGZ1bmN0aW9uICh0ZW5zb3IpIHtcbiAgICAgICAgdmFyIG0gPSB0aGlzLnRyYW5zZm9ybVZlY3RvclRvTWF0cml4KHRlbnNvcik7XG4gICAgICAgIGlmICghKHRoaXMuZ2V0TnVtYmVyT2ZDb2x1bW5zKCkgPT0gbS5nZXROdW1iZXJPZlJvd3MoKSkpXG4gICAgICAgICAgICB0aGlzLmVycm9yKCdzaXplJywgJ2RvdCBwcm9kdWN0Jyk7XG4gICAgICAgIHZhciBuZXdEYXRhID0gTWF0cml4LmdldDJEQXJyYXkodGhpcy5nZXROdW1iZXJPZlJvd3MoKSwgbS5nZXROdW1iZXJPZkNvbHVtbnMoKSk7XG4gICAgICAgIGZvciAodmFyIHYgPSAwOyB2IDwgbS5nZXROdW1iZXJPZkNvbHVtbnMoKTsgdisrKSB7XG4gICAgICAgICAgICBmb3IgKHZhciByID0gMDsgciA8IHRoaXMuZ2V0TnVtYmVyT2ZSb3dzKCk7IHIrKykge1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbS5nZXROdW1iZXJPZlJvd3MoKTsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIG5ld0RhdGFbcl1bdl0gKz0gbS5nZXQoaSwgdikgKiB0aGlzLmdldChyLCBpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5kYXRhID0gbmV3RGF0YTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcbiAgICBNYXRyaXgucHJvdG90eXBlLnRyYW5zZm9ybVZlY3RvclRvTWF0cml4ID0gZnVuY3Rpb24gKHRlbnRhdGl2ZVZlYykge1xuICAgICAgICByZXR1cm4gdGVudGF0aXZlVmVjIGluc3RhbmNlb2YgTWF0cml4ID8gdGVudGF0aXZlVmVjIDogTWF0cml4LmNvbHVtblZlY3Rvci5hcHBseShNYXRyaXgsIHRlbnRhdGl2ZVZlYy5nZXRBcnJheSgpKTtcbiAgICB9O1xuICAgIE1hdHJpeC5wcm90b3R5cGUuZ2V0VmVjdG9yID0gZnVuY3Rpb24gKCkge1xuICAgIH07XG4gICAgTWF0cml4LnByb3RvdHlwZS50cmFuc3Bvc2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBuZXdEYXRhID0gTWF0cml4LmdldDJEQXJyYXkodGhpcy5nZXROdW1iZXJPZkNvbHVtbnMoKSwgdGhpcy5nZXROdW1iZXJPZlJvd3MoKSk7XG4gICAgICAgIHRoaXMuZm9yRWFjaChmdW5jdGlvbiAodiwgcm93LCBjb2wpIHtcbiAgICAgICAgICAgIG5ld0RhdGFbY29sXVtyb3ddID0gdjtcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuZGF0YSA9IG5ld0RhdGE7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG4gICAgTWF0cml4LnByb3RvdHlwZS5taW4gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBtaW5WYWx1ZXMgPSBbXTtcbiAgICAgICAgZm9yICh2YXIgYyA9IDA7IGMgPCB0aGlzLmdldE51bWJlck9mQ29sdW1ucygpOyBjKyspIHtcbiAgICAgICAgICAgIHZhciBjb2x1bW4gPSB0aGlzLmdldENvbHVtbkFzUm93VmVjdG9yKGMpLmdldEFycmF5KClbMF07XG4gICAgICAgICAgICBtaW5WYWx1ZXMucHVzaChNYXRoLm1pbi5hcHBseShNYXRoLCBjb2x1bW4pKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gTWF0cml4LnJvd1ZlY3Rvci5hcHBseShNYXRyaXgsIG1pblZhbHVlcyk7XG4gICAgfTtcbiAgICBNYXRyaXgucHJvdG90eXBlLm1heCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIG1heFZhbHVlcyA9IFtdO1xuICAgICAgICBmb3IgKHZhciBjID0gMDsgYyA8IHRoaXMuZ2V0TnVtYmVyT2ZDb2x1bW5zKCk7IGMrKykge1xuICAgICAgICAgICAgdmFyIGNvbHVtbiA9IHRoaXMuZ2V0Q29sdW1uQXNSb3dWZWN0b3IoYykuZ2V0QXJyYXkoKVswXTtcbiAgICAgICAgICAgIG1heFZhbHVlcy5wdXNoKE1hdGgubWF4LmFwcGx5KE1hdGgsIGNvbHVtbikpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBNYXRyaXgucm93VmVjdG9yLmFwcGx5KE1hdHJpeCwgbWF4VmFsdWVzKTtcbiAgICB9O1xuICAgIE1hdHJpeC5wcm90b3R5cGUuaGFzU2FtZURpbWVuc2lvbnMgPSBmdW5jdGlvbiAobSkge1xuICAgICAgICBpZiAobS5nZXROdW1iZXJPZkNvbHVtbnMoKSA9PSB0aGlzLmdldE51bWJlck9mQ29sdW1ucygpICYmIG0uZ2V0TnVtYmVyT2ZSb3dzKCkgPT0gdGhpcy5nZXROdW1iZXJPZlJvd3MoKSkge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIE1hdHJpeC5wcm90b3R5cGUuZXJyb3IgPSBmdW5jdGlvbiAoY29kZSwgb3BlcmF0aW9uKSB7XG4gICAgICAgIHN3aXRjaCAoY29kZSkge1xuICAgICAgICAgICAgY2FzZSAnc2l6ZSc6XG4gICAgICAgICAgICAgICAgdGhyb3cgXCJNYXRyaWNlcyBub3Qgbm90IGhhdmUgdGhlIHJpZ2h0IHNpemVzIGZvciBvcGVyYXRpb24gXCIgKyBvcGVyYXRpb247XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIHRocm93IFwiRXJyb3IhXCI7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIE1hdHJpeC5wcm90b3R5cGUuc2hvdyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgY29uc29sZS5sb2codGhpcy5nZXRBc1N0cmluZygpKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcbiAgICBNYXRyaXgucHJvdG90eXBlLmdldEFzU3RyaW5nID0gZnVuY3Rpb24gKG1hcmt1cCwgam9pbkNoYXIsIGxpbmVTcGFjZUNoYXIsIGVuZCwgZml4ZWQpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgaWYgKG1hcmt1cCA9PT0gdm9pZCAwKSB7IG1hcmt1cCA9IHRydWU7IH1cbiAgICAgICAgaWYgKGpvaW5DaGFyID09PSB2b2lkIDApIHsgam9pbkNoYXIgPSAnXFx0JzsgfVxuICAgICAgICBpZiAobGluZVNwYWNlQ2hhciA9PT0gdm9pZCAwKSB7IGxpbmVTcGFjZUNoYXIgPSAnICc7IH1cbiAgICAgICAgaWYgKGVuZCA9PT0gdm9pZCAwKSB7IGVuZCA9ICdcXG4nOyB9XG4gICAgICAgIGlmIChmaXhlZCA9PT0gdm9pZCAwKSB7IGZpeGVkID0gMzsgfVxuICAgICAgICBpZiAoIW1hcmt1cCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZGF0YS5tYXAoZnVuY3Rpb24gKHIpIHsgcmV0dXJuIHIubWFwKGZ1bmN0aW9uIChuKSB7IHJldHVybiBuLnRvRml4ZWQoZml4ZWQpOyB9KS5qb2luKCdcXHQnKTsgfSkuam9pbignXFxuJykgKyBlbmQ7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5kYXRhLm1hcChmdW5jdGlvbiAociwgaSkge1xuICAgICAgICAgICAgICAgIHZhciBtaWRkbGVQYXJ0ID0gci5tYXAoZnVuY3Rpb24gKG4pIHsgcmV0dXJuIG4udG9GaXhlZChmaXhlZCk7IH0pLmpvaW4oam9pbkNoYXIpO1xuICAgICAgICAgICAgICAgIGlmIChpID09IDAgJiYgX3RoaXMuZGF0YS5sZW5ndGggPT0gMSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gXCJbXCIgKyBsaW5lU3BhY2VDaGFyICsgbWlkZGxlUGFydCArIGxpbmVTcGFjZUNoYXIgKyBcIl1cIjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoaSA9PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBcIlxcdTIzQTFcIiArIGxpbmVTcGFjZUNoYXIgKyBtaWRkbGVQYXJ0ICsgbGluZVNwYWNlQ2hhciArIFwiXFx1MjNBNFwiO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChpID09IF90aGlzLmRhdGEubGVuZ3RoIC0gMSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gXCJcXHUyM0EzXCIgKyBsaW5lU3BhY2VDaGFyICsgbWlkZGxlUGFydCArIGxpbmVTcGFjZUNoYXIgKyBcIlxcdTIzQTZcIjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBcIlxcdTIzOUNcIiArIGxpbmVTcGFjZUNoYXIgKyBtaWRkbGVQYXJ0ICsgbGluZVNwYWNlQ2hhciArIFwiXFx1MjM5RlwiO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pLmpvaW4oJ1xcbicpICsgZW5kO1xuICAgICAgICB9XG4gICAgfTtcbiAgICByZXR1cm4gTWF0cml4O1xufSgpKTtcbmV4cG9ydHMuTWF0cml4ID0gTWF0cml4O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9zcmMvbWF0aC9tYXRyaXgudHNcbi8vIG1vZHVsZSBpZCA9IDEyXG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOyIsInNvdXJjZVJvb3QiOiIifQ==");

/***/ }),
/* 13 */
/* unknown exports provided */
/* all exports used */
/*!***********************************!*\
  !*** ./src/math/normalization.ts ***!
  \***********************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar Normalization;\n(function (Normalization) {\n    var MinMaxNormalizer = (function () {\n        function MinMaxNormalizer(data) {\n            this.data = data;\n            this.minValues = [];\n            this.maxValues = [];\n            var columns = data[0].length;\n            var _loop_1 = function (c) {\n                var column = data.map(function (r) { return r[c]; });\n                this_1.minValues.push(Math.min.apply(Math, column));\n                this_1.maxValues.push(Math.max.apply(Math, column));\n            };\n            var this_1 = this;\n            for (var c = 0; c < columns; c++) {\n                _loop_1(c);\n            }\n        }\n        MinMaxNormalizer.prototype.normalizeExampleData = function () {\n            var _this = this;\n            return this.data.map(function (row, r) { return row.map(function (x, column) {\n                return (x - _this.minValues[column]) / (_this.maxValues[column] - _this.minValues[column]);\n            }); });\n        };\n        MinMaxNormalizer.prototype.normalizeNewDataRow = function (row) {\n            var _this = this;\n            return row.map(function (value, v) {\n                return (v - _this.minValues[v]) / (_this.maxValues[v] - _this.minValues[v]);\n            });\n        };\n        MinMaxNormalizer.prototype.denormalize = function (row) {\n            var _this = this;\n            return row.map(function (value, v) {\n                return v * (_this.maxValues[v] - _this.minValues[v]) + _this.minValues[v];\n            });\n        };\n        return MinMaxNormalizer;\n    }());\n    Normalization.MinMaxNormalizer = MinMaxNormalizer;\n})(Normalization = exports.Normalization || (exports.Normalization = {}));\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvbWF0aC9ub3JtYWxpemF0aW9uLnRzPzQ2MWQiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgTm9ybWFsaXphdGlvbjtcbihmdW5jdGlvbiAoTm9ybWFsaXphdGlvbikge1xuICAgIHZhciBNaW5NYXhOb3JtYWxpemVyID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZnVuY3Rpb24gTWluTWF4Tm9ybWFsaXplcihkYXRhKSB7XG4gICAgICAgICAgICB0aGlzLmRhdGEgPSBkYXRhO1xuICAgICAgICAgICAgdGhpcy5taW5WYWx1ZXMgPSBbXTtcbiAgICAgICAgICAgIHRoaXMubWF4VmFsdWVzID0gW107XG4gICAgICAgICAgICB2YXIgY29sdW1ucyA9IGRhdGFbMF0ubGVuZ3RoO1xuICAgICAgICAgICAgdmFyIF9sb29wXzEgPSBmdW5jdGlvbiAoYykge1xuICAgICAgICAgICAgICAgIHZhciBjb2x1bW4gPSBkYXRhLm1hcChmdW5jdGlvbiAocikgeyByZXR1cm4gcltjXTsgfSk7XG4gICAgICAgICAgICAgICAgdGhpc18xLm1pblZhbHVlcy5wdXNoKE1hdGgubWluLmFwcGx5KE1hdGgsIGNvbHVtbikpO1xuICAgICAgICAgICAgICAgIHRoaXNfMS5tYXhWYWx1ZXMucHVzaChNYXRoLm1heC5hcHBseShNYXRoLCBjb2x1bW4pKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICB2YXIgdGhpc18xID0gdGhpcztcbiAgICAgICAgICAgIGZvciAodmFyIGMgPSAwOyBjIDwgY29sdW1uczsgYysrKSB7XG4gICAgICAgICAgICAgICAgX2xvb3BfMShjKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBNaW5NYXhOb3JtYWxpemVyLnByb3RvdHlwZS5ub3JtYWxpemVFeGFtcGxlRGF0YSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5kYXRhLm1hcChmdW5jdGlvbiAocm93LCByKSB7IHJldHVybiByb3cubWFwKGZ1bmN0aW9uICh4LCBjb2x1bW4pIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gKHggLSBfdGhpcy5taW5WYWx1ZXNbY29sdW1uXSkgLyAoX3RoaXMubWF4VmFsdWVzW2NvbHVtbl0gLSBfdGhpcy5taW5WYWx1ZXNbY29sdW1uXSk7XG4gICAgICAgICAgICB9KTsgfSk7XG4gICAgICAgIH07XG4gICAgICAgIE1pbk1heE5vcm1hbGl6ZXIucHJvdG90eXBlLm5vcm1hbGl6ZU5ld0RhdGFSb3cgPSBmdW5jdGlvbiAocm93KSB7XG4gICAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICAgICAgcmV0dXJuIHJvdy5tYXAoZnVuY3Rpb24gKHZhbHVlLCB2KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICh2IC0gX3RoaXMubWluVmFsdWVzW3ZdKSAvIChfdGhpcy5tYXhWYWx1ZXNbdl0gLSBfdGhpcy5taW5WYWx1ZXNbdl0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH07XG4gICAgICAgIE1pbk1heE5vcm1hbGl6ZXIucHJvdG90eXBlLmRlbm9ybWFsaXplID0gZnVuY3Rpb24gKHJvdykge1xuICAgICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgICAgIHJldHVybiByb3cubWFwKGZ1bmN0aW9uICh2YWx1ZSwgdikge1xuICAgICAgICAgICAgICAgIHJldHVybiB2ICogKF90aGlzLm1heFZhbHVlc1t2XSAtIF90aGlzLm1pblZhbHVlc1t2XSkgKyBfdGhpcy5taW5WYWx1ZXNbdl07XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIE1pbk1heE5vcm1hbGl6ZXI7XG4gICAgfSgpKTtcbiAgICBOb3JtYWxpemF0aW9uLk1pbk1heE5vcm1hbGl6ZXIgPSBNaW5NYXhOb3JtYWxpemVyO1xufSkoTm9ybWFsaXphdGlvbiA9IGV4cG9ydHMuTm9ybWFsaXphdGlvbiB8fCAoZXhwb3J0cy5Ob3JtYWxpemF0aW9uID0ge30pKTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vc3JjL21hdGgvbm9ybWFsaXphdGlvbi50c1xuLy8gbW9kdWxlIGlkID0gMTNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Iiwic291cmNlUm9vdCI6IiJ9");

/***/ }),
/* 14 */
/* unknown exports provided */
/* all exports used */
/*!****************************!*\
  !*** ./src/math/vector.ts ***!
  \****************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar __1 = __webpack_require__(/*! .. */ 0);\nvar Vector = (function () {\n    function Vector(components) {\n        this.components = components;\n    }\n    Vector.rand = function (size) {\n        return new Vector(new Array(size).fill(0).map(function (v) { return Math.random(); }));\n    };\n    Vector.prototype.copy = function () {\n        return new Vector(this.components.slice());\n    };\n    Vector.prototype.getArray = function () {\n        return this.components;\n    };\n    Vector.prototype.append = function (vec) {\n        (_a = this.components).push.apply(_a, vec.components);\n        return this;\n        var _a;\n    };\n    Vector.prototype.prepend = function (vec) {\n        (_a = this.components).unshift.apply(_a, vec.components);\n        return this;\n        var _a;\n    };\n    Object.defineProperty(Vector.prototype, \"size\", {\n        get: function () {\n            return this.components.length;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(Vector.prototype, \"magnitude\", {\n        get: function () {\n            return Math.sqrt(this.components.reduce(function (s, c) { return s + (c * c); }, 0));\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Vector.prototype.get = function (component) {\n        return this.components[component];\n    };\n    Vector.prototype.set = function (component, value) {\n        this.components[component] = value;\n        return this;\n    };\n    Vector.prototype.add = function (vec) {\n        this.assertSameSize(vec);\n        this.components.map(function (c, i) { return c + vec.get(i); });\n        return this;\n    };\n    Vector.prototype.subtract = function (vec) {\n        this.assertSameSize(vec);\n        this.components.map(function (c, i) { return c - vec.get(i); });\n        return this;\n    };\n    Vector.prototype.multiply = function (vec) {\n        this.assertSameSize(vec);\n        this.components.map(function (c, i) { return c * vec.get(i); });\n        return this;\n    };\n    Vector.prototype.divide = function (vec) {\n        this.assertSameSize(vec);\n        this.components.map(function (c, i) { return c / vec.get(i); });\n        return this;\n    };\n    Vector.prototype.pow = function (exponent) {\n        this.components.map(function (c, i) { return Math.pow(c, exponent); });\n        return this;\n    };\n    Vector.prototype.sum = function () {\n        return __1.Maths.sum(this.components);\n    };\n    Vector.prototype.scale = function (scl) {\n        this.components.map(function (c) { return c * scl; });\n        return this;\n    };\n    /**\n     * this vector will be a row vector\n     * @param vec column vector\n     */\n    Vector.prototype.dot = function (vec) {\n        var val = 0;\n        this.assertSameSize(vec);\n        return __1.Maths.sum(this.components.map(function (c, i) { return c * vec.get(i); }));\n    };\n    Vector.prototype.apply = function (func) {\n        this.components = this.components.map(function (c) { return func(c); });\n        return this;\n    };\n    Vector.prototype.assertSameSize = function (vec) {\n        if (this.size != vec.size)\n            new Error('Vectors do not have matching sizes');\n    };\n    return Vector;\n}());\nexports.Vector = Vector;\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTQuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvbWF0aC92ZWN0b3IudHM/NDI2MCJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBfXzEgPSByZXF1aXJlKFwiLi5cIik7XG52YXIgVmVjdG9yID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBWZWN0b3IoY29tcG9uZW50cykge1xuICAgICAgICB0aGlzLmNvbXBvbmVudHMgPSBjb21wb25lbnRzO1xuICAgIH1cbiAgICBWZWN0b3IucmFuZCA9IGZ1bmN0aW9uIChzaXplKSB7XG4gICAgICAgIHJldHVybiBuZXcgVmVjdG9yKG5ldyBBcnJheShzaXplKS5maWxsKDApLm1hcChmdW5jdGlvbiAodikgeyByZXR1cm4gTWF0aC5yYW5kb20oKTsgfSkpO1xuICAgIH07XG4gICAgVmVjdG9yLnByb3RvdHlwZS5jb3B5ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gbmV3IFZlY3Rvcih0aGlzLmNvbXBvbmVudHMuc2xpY2UoKSk7XG4gICAgfTtcbiAgICBWZWN0b3IucHJvdG90eXBlLmdldEFycmF5ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jb21wb25lbnRzO1xuICAgIH07XG4gICAgVmVjdG9yLnByb3RvdHlwZS5hcHBlbmQgPSBmdW5jdGlvbiAodmVjKSB7XG4gICAgICAgIChfYSA9IHRoaXMuY29tcG9uZW50cykucHVzaC5hcHBseShfYSwgdmVjLmNvbXBvbmVudHMpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgdmFyIF9hO1xuICAgIH07XG4gICAgVmVjdG9yLnByb3RvdHlwZS5wcmVwZW5kID0gZnVuY3Rpb24gKHZlYykge1xuICAgICAgICAoX2EgPSB0aGlzLmNvbXBvbmVudHMpLnVuc2hpZnQuYXBwbHkoX2EsIHZlYy5jb21wb25lbnRzKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIHZhciBfYTtcbiAgICB9O1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShWZWN0b3IucHJvdG90eXBlLCBcInNpemVcIiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmNvbXBvbmVudHMubGVuZ3RoO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoVmVjdG9yLnByb3RvdHlwZSwgXCJtYWduaXR1ZGVcIiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiBNYXRoLnNxcnQodGhpcy5jb21wb25lbnRzLnJlZHVjZShmdW5jdGlvbiAocywgYykgeyByZXR1cm4gcyArIChjICogYyk7IH0sIDApKTtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgVmVjdG9yLnByb3RvdHlwZS5nZXQgPSBmdW5jdGlvbiAoY29tcG9uZW50KSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNvbXBvbmVudHNbY29tcG9uZW50XTtcbiAgICB9O1xuICAgIFZlY3Rvci5wcm90b3R5cGUuc2V0ID0gZnVuY3Rpb24gKGNvbXBvbmVudCwgdmFsdWUpIHtcbiAgICAgICAgdGhpcy5jb21wb25lbnRzW2NvbXBvbmVudF0gPSB2YWx1ZTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcbiAgICBWZWN0b3IucHJvdG90eXBlLmFkZCA9IGZ1bmN0aW9uICh2ZWMpIHtcbiAgICAgICAgdGhpcy5hc3NlcnRTYW1lU2l6ZSh2ZWMpO1xuICAgICAgICB0aGlzLmNvbXBvbmVudHMubWFwKGZ1bmN0aW9uIChjLCBpKSB7IHJldHVybiBjICsgdmVjLmdldChpKTsgfSk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG4gICAgVmVjdG9yLnByb3RvdHlwZS5zdWJ0cmFjdCA9IGZ1bmN0aW9uICh2ZWMpIHtcbiAgICAgICAgdGhpcy5hc3NlcnRTYW1lU2l6ZSh2ZWMpO1xuICAgICAgICB0aGlzLmNvbXBvbmVudHMubWFwKGZ1bmN0aW9uIChjLCBpKSB7IHJldHVybiBjIC0gdmVjLmdldChpKTsgfSk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG4gICAgVmVjdG9yLnByb3RvdHlwZS5tdWx0aXBseSA9IGZ1bmN0aW9uICh2ZWMpIHtcbiAgICAgICAgdGhpcy5hc3NlcnRTYW1lU2l6ZSh2ZWMpO1xuICAgICAgICB0aGlzLmNvbXBvbmVudHMubWFwKGZ1bmN0aW9uIChjLCBpKSB7IHJldHVybiBjICogdmVjLmdldChpKTsgfSk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG4gICAgVmVjdG9yLnByb3RvdHlwZS5kaXZpZGUgPSBmdW5jdGlvbiAodmVjKSB7XG4gICAgICAgIHRoaXMuYXNzZXJ0U2FtZVNpemUodmVjKTtcbiAgICAgICAgdGhpcy5jb21wb25lbnRzLm1hcChmdW5jdGlvbiAoYywgaSkgeyByZXR1cm4gYyAvIHZlYy5nZXQoaSk7IH0pO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuICAgIFZlY3Rvci5wcm90b3R5cGUucG93ID0gZnVuY3Rpb24gKGV4cG9uZW50KSB7XG4gICAgICAgIHRoaXMuY29tcG9uZW50cy5tYXAoZnVuY3Rpb24gKGMsIGkpIHsgcmV0dXJuIE1hdGgucG93KGMsIGV4cG9uZW50KTsgfSk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG4gICAgVmVjdG9yLnByb3RvdHlwZS5zdW0gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBfXzEuTWF0aHMuc3VtKHRoaXMuY29tcG9uZW50cyk7XG4gICAgfTtcbiAgICBWZWN0b3IucHJvdG90eXBlLnNjYWxlID0gZnVuY3Rpb24gKHNjbCkge1xuICAgICAgICB0aGlzLmNvbXBvbmVudHMubWFwKGZ1bmN0aW9uIChjKSB7IHJldHVybiBjICogc2NsOyB9KTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiB0aGlzIHZlY3RvciB3aWxsIGJlIGEgcm93IHZlY3RvclxuICAgICAqIEBwYXJhbSB2ZWMgY29sdW1uIHZlY3RvclxuICAgICAqL1xuICAgIFZlY3Rvci5wcm90b3R5cGUuZG90ID0gZnVuY3Rpb24gKHZlYykge1xuICAgICAgICB2YXIgdmFsID0gMDtcbiAgICAgICAgdGhpcy5hc3NlcnRTYW1lU2l6ZSh2ZWMpO1xuICAgICAgICByZXR1cm4gX18xLk1hdGhzLnN1bSh0aGlzLmNvbXBvbmVudHMubWFwKGZ1bmN0aW9uIChjLCBpKSB7IHJldHVybiBjICogdmVjLmdldChpKTsgfSkpO1xuICAgIH07XG4gICAgVmVjdG9yLnByb3RvdHlwZS5hcHBseSA9IGZ1bmN0aW9uIChmdW5jKSB7XG4gICAgICAgIHRoaXMuY29tcG9uZW50cyA9IHRoaXMuY29tcG9uZW50cy5tYXAoZnVuY3Rpb24gKGMpIHsgcmV0dXJuIGZ1bmMoYyk7IH0pO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuICAgIFZlY3Rvci5wcm90b3R5cGUuYXNzZXJ0U2FtZVNpemUgPSBmdW5jdGlvbiAodmVjKSB7XG4gICAgICAgIGlmICh0aGlzLnNpemUgIT0gdmVjLnNpemUpXG4gICAgICAgICAgICBuZXcgRXJyb3IoJ1ZlY3RvcnMgZG8gbm90IGhhdmUgbWF0Y2hpbmcgc2l6ZXMnKTtcbiAgICB9O1xuICAgIHJldHVybiBWZWN0b3I7XG59KCkpO1xuZXhwb3J0cy5WZWN0b3IgPSBWZWN0b3I7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL3NyYy9tYXRoL3ZlY3Rvci50c1xuLy8gbW9kdWxlIGlkID0gMTRcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOyIsInNvdXJjZVJvb3QiOiIifQ==");

/***/ }),
/* 15 */
/* unknown exports provided */
/* all exports used */
/*!****************************!*\
  !*** ./src/naive-bayes.ts ***!
  \****************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("//https://www.youtube.com/watch?v=EGKeC2S44Rs\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar _1 = __webpack_require__(/*! . */ 0);\nvar NaiveBayesClassifier = (function () {\n    function NaiveBayesClassifier(tokenizeMethod) {\n        if (tokenizeMethod === void 0) { tokenizeMethod = _1.Utilities.tokenize; }\n        this.tokenizeMethod = tokenizeMethod;\n        /**\n         * words = {\n         *  \"word1\": {\n         *     \"label1\": count\n         *     \"label2\": count\n         *  }\n         *  \"word2\": {\n         *     \"label1\": count\n         *     \"label2\": count\n         *  }\n         * }\n         */\n        this.words = [];\n        this.docs = {};\n        this.labels = [];\n    }\n    NaiveBayesClassifier.prototype.add = function (text, _label) {\n        var label = (typeof _label == 'string') ? _label : _label.toString();\n        var tokens = this.tokenizeMethod(text);\n        // Count doc\n        this.docs[label] = this.docs[label] ? this.docs[label] + 1 : 1;\n        // Save label\n        if (!this.labels.includes(label))\n            this.labels.push(label);\n        for (var _i = 0, tokens_1 = tokens; _i < tokens_1.length; _i++) {\n            var token = tokens_1[_i];\n            if (!this.words[token]) {\n                this.words[token] = {};\n                this.words[token][label] = 1;\n            }\n            else {\n                this.words[token][label] = this.words[token][label] ? this.words[token][label] + 1 : 1;\n            }\n        }\n    };\n    NaiveBayesClassifier.prototype.classify = function (text) {\n        var words = this.tokenizeMethod(text);\n        var propForLabels = {};\n        for (var _i = 0, _a = this.labels; _i < _a.length; _i++) {\n            var label = _a[_i];\n            var prop = 1;\n            for (var _b = 0, words_1 = words; _b < words_1.length; _b++) {\n                var word = words_1[_b];\n                prop *= this.propWordGivenLabel(word, label);\n            }\n            propForLabels[label] = prop;\n        }\n        // Get biggest prop\n        var tentativeBiggest = propForLabels[this.labels[0]];\n        var tentativeLabel = this.labels[0];\n        for (var _c = 0, _d = this.labels; _c < _d.length; _c++) {\n            var label = _d[_c];\n            if (tentativeBiggest < propForLabels[label]) {\n                tentativeBiggest = propForLabels[label];\n                tentativeLabel = label;\n            }\n        }\n        return tentativeLabel;\n    };\n    NaiveBayesClassifier.prototype.getUnique = function () {\n        return Object.keys(this.words);\n    };\n    NaiveBayesClassifier.prototype.propLabel = function (label) {\n        return this.docs[label] / this.numberOfDocs;\n    };\n    NaiveBayesClassifier.prototype.propWordGivenLabel = function (word, label) {\n        var wordOccurrences = this.words[word] ? this.words[word][label] || 0 : 0;\n        return (wordOccurrences + 1) / (this.getNumberWordsForLabel(label) + this.numberOfUniqueWords);\n    };\n    Object.defineProperty(NaiveBayesClassifier.prototype, \"numberOfDocs\", {\n        get: function () {\n            var sum = 0;\n            for (var key in this.docs) {\n                sum += this.docs[key];\n            }\n            return sum;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(NaiveBayesClassifier.prototype, \"numberOfUniqueWords\", {\n        get: function () {\n            return this.getUnique().length;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    NaiveBayesClassifier.prototype.getNumberWordsForLabel = function (label) {\n        var sum = 0;\n        for (var key in this.words) {\n            sum += this.words[key][label] || 0;\n        }\n        return sum;\n    };\n    return NaiveBayesClassifier;\n}());\nexports.NaiveBayesClassifier = NaiveBayesClassifier;\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTUuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvbmFpdmUtYmF5ZXMudHM/MDI4NSJdLCJzb3VyY2VzQ29udGVudCI6WyIvL2h0dHBzOi8vd3d3LnlvdXR1YmUuY29tL3dhdGNoP3Y9RUdLZUMyUzQ0UnNcblwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIF8xID0gcmVxdWlyZShcIi5cIik7XG52YXIgTmFpdmVCYXllc0NsYXNzaWZpZXIgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIE5haXZlQmF5ZXNDbGFzc2lmaWVyKHRva2VuaXplTWV0aG9kKSB7XG4gICAgICAgIGlmICh0b2tlbml6ZU1ldGhvZCA9PT0gdm9pZCAwKSB7IHRva2VuaXplTWV0aG9kID0gXzEuVXRpbGl0aWVzLnRva2VuaXplOyB9XG4gICAgICAgIHRoaXMudG9rZW5pemVNZXRob2QgPSB0b2tlbml6ZU1ldGhvZDtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIHdvcmRzID0ge1xuICAgICAgICAgKiAgXCJ3b3JkMVwiOiB7XG4gICAgICAgICAqICAgICBcImxhYmVsMVwiOiBjb3VudFxuICAgICAgICAgKiAgICAgXCJsYWJlbDJcIjogY291bnRcbiAgICAgICAgICogIH1cbiAgICAgICAgICogIFwid29yZDJcIjoge1xuICAgICAgICAgKiAgICAgXCJsYWJlbDFcIjogY291bnRcbiAgICAgICAgICogICAgIFwibGFiZWwyXCI6IGNvdW50XG4gICAgICAgICAqICB9XG4gICAgICAgICAqIH1cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMud29yZHMgPSBbXTtcbiAgICAgICAgdGhpcy5kb2NzID0ge307XG4gICAgICAgIHRoaXMubGFiZWxzID0gW107XG4gICAgfVxuICAgIE5haXZlQmF5ZXNDbGFzc2lmaWVyLnByb3RvdHlwZS5hZGQgPSBmdW5jdGlvbiAodGV4dCwgX2xhYmVsKSB7XG4gICAgICAgIHZhciBsYWJlbCA9ICh0eXBlb2YgX2xhYmVsID09ICdzdHJpbmcnKSA/IF9sYWJlbCA6IF9sYWJlbC50b1N0cmluZygpO1xuICAgICAgICB2YXIgdG9rZW5zID0gdGhpcy50b2tlbml6ZU1ldGhvZCh0ZXh0KTtcbiAgICAgICAgLy8gQ291bnQgZG9jXG4gICAgICAgIHRoaXMuZG9jc1tsYWJlbF0gPSB0aGlzLmRvY3NbbGFiZWxdID8gdGhpcy5kb2NzW2xhYmVsXSArIDEgOiAxO1xuICAgICAgICAvLyBTYXZlIGxhYmVsXG4gICAgICAgIGlmICghdGhpcy5sYWJlbHMuaW5jbHVkZXMobGFiZWwpKVxuICAgICAgICAgICAgdGhpcy5sYWJlbHMucHVzaChsYWJlbCk7XG4gICAgICAgIGZvciAodmFyIF9pID0gMCwgdG9rZW5zXzEgPSB0b2tlbnM7IF9pIDwgdG9rZW5zXzEubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgICB2YXIgdG9rZW4gPSB0b2tlbnNfMVtfaV07XG4gICAgICAgICAgICBpZiAoIXRoaXMud29yZHNbdG9rZW5dKSB7XG4gICAgICAgICAgICAgICAgdGhpcy53b3Jkc1t0b2tlbl0gPSB7fTtcbiAgICAgICAgICAgICAgICB0aGlzLndvcmRzW3Rva2VuXVtsYWJlbF0gPSAxO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy53b3Jkc1t0b2tlbl1bbGFiZWxdID0gdGhpcy53b3Jkc1t0b2tlbl1bbGFiZWxdID8gdGhpcy53b3Jkc1t0b2tlbl1bbGFiZWxdICsgMSA6IDE7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuICAgIE5haXZlQmF5ZXNDbGFzc2lmaWVyLnByb3RvdHlwZS5jbGFzc2lmeSA9IGZ1bmN0aW9uICh0ZXh0KSB7XG4gICAgICAgIHZhciB3b3JkcyA9IHRoaXMudG9rZW5pemVNZXRob2QodGV4dCk7XG4gICAgICAgIHZhciBwcm9wRm9yTGFiZWxzID0ge307XG4gICAgICAgIGZvciAodmFyIF9pID0gMCwgX2EgPSB0aGlzLmxhYmVsczsgX2kgPCBfYS5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICAgIHZhciBsYWJlbCA9IF9hW19pXTtcbiAgICAgICAgICAgIHZhciBwcm9wID0gMTtcbiAgICAgICAgICAgIGZvciAodmFyIF9iID0gMCwgd29yZHNfMSA9IHdvcmRzOyBfYiA8IHdvcmRzXzEubGVuZ3RoOyBfYisrKSB7XG4gICAgICAgICAgICAgICAgdmFyIHdvcmQgPSB3b3Jkc18xW19iXTtcbiAgICAgICAgICAgICAgICBwcm9wICo9IHRoaXMucHJvcFdvcmRHaXZlbkxhYmVsKHdvcmQsIGxhYmVsKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHByb3BGb3JMYWJlbHNbbGFiZWxdID0gcHJvcDtcbiAgICAgICAgfVxuICAgICAgICAvLyBHZXQgYmlnZ2VzdCBwcm9wXG4gICAgICAgIHZhciB0ZW50YXRpdmVCaWdnZXN0ID0gcHJvcEZvckxhYmVsc1t0aGlzLmxhYmVsc1swXV07XG4gICAgICAgIHZhciB0ZW50YXRpdmVMYWJlbCA9IHRoaXMubGFiZWxzWzBdO1xuICAgICAgICBmb3IgKHZhciBfYyA9IDAsIF9kID0gdGhpcy5sYWJlbHM7IF9jIDwgX2QubGVuZ3RoOyBfYysrKSB7XG4gICAgICAgICAgICB2YXIgbGFiZWwgPSBfZFtfY107XG4gICAgICAgICAgICBpZiAodGVudGF0aXZlQmlnZ2VzdCA8IHByb3BGb3JMYWJlbHNbbGFiZWxdKSB7XG4gICAgICAgICAgICAgICAgdGVudGF0aXZlQmlnZ2VzdCA9IHByb3BGb3JMYWJlbHNbbGFiZWxdO1xuICAgICAgICAgICAgICAgIHRlbnRhdGl2ZUxhYmVsID0gbGFiZWw7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRlbnRhdGl2ZUxhYmVsO1xuICAgIH07XG4gICAgTmFpdmVCYXllc0NsYXNzaWZpZXIucHJvdG90eXBlLmdldFVuaXF1ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIE9iamVjdC5rZXlzKHRoaXMud29yZHMpO1xuICAgIH07XG4gICAgTmFpdmVCYXllc0NsYXNzaWZpZXIucHJvdG90eXBlLnByb3BMYWJlbCA9IGZ1bmN0aW9uIChsYWJlbCkge1xuICAgICAgICByZXR1cm4gdGhpcy5kb2NzW2xhYmVsXSAvIHRoaXMubnVtYmVyT2ZEb2NzO1xuICAgIH07XG4gICAgTmFpdmVCYXllc0NsYXNzaWZpZXIucHJvdG90eXBlLnByb3BXb3JkR2l2ZW5MYWJlbCA9IGZ1bmN0aW9uICh3b3JkLCBsYWJlbCkge1xuICAgICAgICB2YXIgd29yZE9jY3VycmVuY2VzID0gdGhpcy53b3Jkc1t3b3JkXSA/IHRoaXMud29yZHNbd29yZF1bbGFiZWxdIHx8IDAgOiAwO1xuICAgICAgICByZXR1cm4gKHdvcmRPY2N1cnJlbmNlcyArIDEpIC8gKHRoaXMuZ2V0TnVtYmVyV29yZHNGb3JMYWJlbChsYWJlbCkgKyB0aGlzLm51bWJlck9mVW5pcXVlV29yZHMpO1xuICAgIH07XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KE5haXZlQmF5ZXNDbGFzc2lmaWVyLnByb3RvdHlwZSwgXCJudW1iZXJPZkRvY3NcIiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBzdW0gPSAwO1xuICAgICAgICAgICAgZm9yICh2YXIga2V5IGluIHRoaXMuZG9jcykge1xuICAgICAgICAgICAgICAgIHN1bSArPSB0aGlzLmRvY3Nba2V5XTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBzdW07XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShOYWl2ZUJheWVzQ2xhc3NpZmllci5wcm90b3R5cGUsIFwibnVtYmVyT2ZVbmlxdWVXb3Jkc1wiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZ2V0VW5pcXVlKCkubGVuZ3RoO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBOYWl2ZUJheWVzQ2xhc3NpZmllci5wcm90b3R5cGUuZ2V0TnVtYmVyV29yZHNGb3JMYWJlbCA9IGZ1bmN0aW9uIChsYWJlbCkge1xuICAgICAgICB2YXIgc3VtID0gMDtcbiAgICAgICAgZm9yICh2YXIga2V5IGluIHRoaXMud29yZHMpIHtcbiAgICAgICAgICAgIHN1bSArPSB0aGlzLndvcmRzW2tleV1bbGFiZWxdIHx8IDA7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHN1bTtcbiAgICB9O1xuICAgIHJldHVybiBOYWl2ZUJheWVzQ2xhc3NpZmllcjtcbn0oKSk7XG5leHBvcnRzLk5haXZlQmF5ZXNDbGFzc2lmaWVyID0gTmFpdmVCYXllc0NsYXNzaWZpZXI7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL3NyYy9uYWl2ZS1iYXllcy50c1xuLy8gbW9kdWxlIGlkID0gMTVcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Iiwic291cmNlUm9vdCI6IiJ9");

/***/ })
/******/ ]);
});